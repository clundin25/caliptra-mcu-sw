// Licensed under the Apache-2.0 license.
//
// generated by registers_generator with caliptra-rtl repo at 9f80a2bebb755233696929bf1da5ca0b90eba9a1
// , caliptra-ss repo at 9911c2b0e4bac9e4b48f6c2155c86cb116159734
// , and i3c-core repo at d5c715103f529ade0e5d375a53c5692daaa9c54b
//
#[derive(Clone, Copy, Default)]
pub struct HcControlReadVal(u32);
impl HcControlReadVal {
    /// Host Controller Bus Enable
    #[inline(always)]
    pub fn bus_enable(&self) -> bool {
        ((self.0 >> 31) & 1) != 0
    }
    /// Host Controller Resume:
    ///
    /// 0 - Controller is running
    ///
    /// 1 - Controller is suspended
    ///
    /// Write 1 to resume Controller operations.
    #[inline(always)]
    pub fn resume(&self) -> bool {
        ((self.0 >> 30) & 1) != 0
    }
    /// Host Controller Abort when set to 1
    #[inline(always)]
    pub fn abort(&self) -> bool {
        ((self.0 >> 29) & 1) != 0
    }
    /// Halt on Command Sequence Timeout when set to 1
    #[inline(always)]
    pub fn halt_on_cmd_seq_timeout(&self) -> bool {
        ((self.0 >> 12) & 1) != 0
    }
    /// Hot-Join ACK/NACK Control:
    ///
    /// 0 - ACK Hot-Join request
    ///
    /// 1 - NACK Hot-Join request and send Broadcast CCC to disable Hot-Join
    #[inline(always)]
    pub fn hot_join_ctrl(&self) -> bool {
        ((self.0 >> 8) & 1) != 0
    }
    /// I2C Device Present on Bus:
    ///
    /// 0 - pure I3C bus
    ///
    /// 1 - legacy I2C devices on the bus
    #[inline(always)]
    pub fn i2_c_dev_present(&self) -> bool {
        ((self.0 >> 7) & 1) != 0
    }
    /// DMA/PIO Mode Selector:
    ///
    /// 0 - DMA
    ///
    /// 1 - PIO
    #[inline(always)]
    pub fn mode_selector(&self) -> bool {
        ((self.0 >> 6) & 1) != 0
    }
    /// Data Byte Ordering Mode:
    ///
    /// 0 - Little Endian
    ///
    /// 1 - Big Endian
    #[inline(always)]
    pub fn data_byte_order_mode(&self) -> bool {
        ((self.0 >> 4) & 1) != 0
    }
    /// Auto-Command Data Report:
    ///
    /// 0 - coalesced reporting
    ///
    /// 1 - separated reporting
    #[inline(always)]
    pub fn autocmd_data_rpt(&self) -> bool {
        ((self.0 >> 3) & 1) != 0
    }
    /// Include I3C Broadcast Address:
    ///
    /// 0 - skips I3C Broadcast Address for private transfers
    ///
    /// 1 - includes I3C Broadcast Address for private transfers
    #[inline(always)]
    pub fn iba_include(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> HcControlWriteVal {
        HcControlWriteVal(self.0)
    }
}
impl From<u32> for HcControlReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<HcControlReadVal> for u32 {
    #[inline(always)]
    fn from(val: HcControlReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct HcControlWriteVal(u32);
impl HcControlWriteVal {
    /// Host Controller Bus Enable
    #[inline(always)]
    pub fn bus_enable(self, val: bool) -> Self {
        Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
    }
    /// Host Controller Resume:
    ///
    /// 0 - Controller is running
    ///
    /// 1 - Controller is suspended
    ///
    /// Write 1 to resume Controller operations.
    #[inline(always)]
    pub fn resume(self, val: bool) -> Self {
        Self((self.0 & !(1 << 30)) | (u32::from(val) << 30))
    }
    /// Host Controller Abort when set to 1
    #[inline(always)]
    pub fn abort(self, val: bool) -> Self {
        Self((self.0 & !(1 << 29)) | (u32::from(val) << 29))
    }
    /// Halt on Command Sequence Timeout when set to 1
    #[inline(always)]
    pub fn halt_on_cmd_seq_timeout(self, val: bool) -> Self {
        Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
    }
    /// Hot-Join ACK/NACK Control:
    ///
    /// 0 - ACK Hot-Join request
    ///
    /// 1 - NACK Hot-Join request and send Broadcast CCC to disable Hot-Join
    #[inline(always)]
    pub fn hot_join_ctrl(self, val: bool) -> Self {
        Self((self.0 & !(1 << 8)) | (u32::from(val) << 8))
    }
    /// I2C Device Present on Bus:
    ///
    /// 0 - pure I3C bus
    ///
    /// 1 - legacy I2C devices on the bus
    #[inline(always)]
    pub fn i2_c_dev_present(self, val: bool) -> Self {
        Self((self.0 & !(1 << 7)) | (u32::from(val) << 7))
    }
    /// DMA/PIO Mode Selector:
    ///
    /// 0 - DMA
    ///
    /// 1 - PIO
    #[inline(always)]
    pub fn mode_selector(self, val: bool) -> Self {
        Self((self.0 & !(1 << 6)) | (u32::from(val) << 6))
    }
    /// Data Byte Ordering Mode:
    ///
    /// 0 - Little Endian
    ///
    /// 1 - Big Endian
    #[inline(always)]
    pub fn data_byte_order_mode(self, val: bool) -> Self {
        Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
    }
    /// Auto-Command Data Report:
    ///
    /// 0 - coalesced reporting
    ///
    /// 1 - separated reporting
    #[inline(always)]
    pub fn autocmd_data_rpt(self, val: bool) -> Self {
        Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
    }
    /// Include I3C Broadcast Address:
    ///
    /// 0 - skips I3C Broadcast Address for private transfers
    ///
    /// 1 - includes I3C Broadcast Address for private transfers
    #[inline(always)]
    pub fn iba_include(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for HcControlWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<HcControlWriteVal> for u32 {
    #[inline(always)]
    fn from(val: HcControlWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ControllerDeviceAddrReadVal(u32);
impl ControllerDeviceAddrReadVal {
    /// Dynamic Address is Valid:
    ///
    /// 0 - dynamic address is invalid
    ///
    /// 1 - dynamic address is valid
    #[inline(always)]
    pub fn dynamic_addr_valid(&self) -> bool {
        ((self.0 >> 31) & 1) != 0
    }
    /// Device Dynamic Address
    #[inline(always)]
    pub fn dynamic_addr(&self) -> u32 {
        (self.0 >> 16) & 0x7f
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> ControllerDeviceAddrWriteVal {
        ControllerDeviceAddrWriteVal(self.0)
    }
}
impl From<u32> for ControllerDeviceAddrReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ControllerDeviceAddrReadVal> for u32 {
    #[inline(always)]
    fn from(val: ControllerDeviceAddrReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ControllerDeviceAddrWriteVal(u32);
impl ControllerDeviceAddrWriteVal {
    /// Dynamic Address is Valid:
    ///
    /// 0 - dynamic address is invalid
    ///
    /// 1 - dynamic address is valid
    #[inline(always)]
    pub fn dynamic_addr_valid(self, val: bool) -> Self {
        Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
    }
    /// Device Dynamic Address
    #[inline(always)]
    pub fn dynamic_addr(self, val: u32) -> Self {
        Self((self.0 & !(0x7f << 16)) | ((val & 0x7f) << 16))
    }
}
impl From<u32> for ControllerDeviceAddrWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ControllerDeviceAddrWriteVal> for u32 {
    #[inline(always)]
    fn from(val: ControllerDeviceAddrWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct HcCapabilitiesReadVal(u32);
impl HcCapabilitiesReadVal {
    /// Device context memory:
    ///
    /// 0 - must be physically continuous
    ///
    /// 1 - controller supports scatter-gather
    #[inline(always)]
    pub fn sg_capability_dc_en(&self) -> bool {
        ((self.0 >> 30) & 1) != 0
    }
    /// DMA only: IBI status and IBI Data rings memory:
    ///
    /// 0 - must be physically continuous
    ///
    /// 1 - controller supports scatter-gather
    #[inline(always)]
    pub fn sg_capability_ibi_en(&self) -> bool {
        ((self.0 >> 29) & 1) != 0
    }
    /// DMA only: Command and Response rings memory:
    ///
    /// 0 - must be physically continuous
    ///
    /// 1 - controller supports scatter-gather
    #[inline(always)]
    pub fn sg_capability_cr_en(&self) -> bool {
        ((self.0 >> 28) & 1) != 0
    }
    /// Size and structure of the Command Descriptor:
    ///
    /// 2'b0: 2 DWORDs,
    ///
    /// all other reserved.
    #[inline(always)]
    pub fn cmd_size(&self) -> u32 {
        (self.0 >> 20) & 3
    }
    /// Controller command scheduling:
    ///
    /// 0 - not supported
    ///
    /// 1 - supported
    #[inline(always)]
    pub fn scheduled_commands_en(&self) -> bool {
        ((self.0 >> 13) & 1) != 0
    }
    /// Controller IBI credit count:
    ///
    /// 0 - not supported
    ///
    /// 1 - supported
    #[inline(always)]
    pub fn ibi_credit_count_en(&self) -> bool {
        ((self.0 >> 12) & 1) != 0
    }
    /// Controller IBI data abort:
    ///
    /// 0 - not supported
    ///
    /// 1 - supported
    #[inline(always)]
    pub fn ibi_data_abort_en(&self) -> bool {
        ((self.0 >> 11) & 1) != 0
    }
    /// CCC with defining byte:
    ///
    /// 0 - not supported
    ///
    /// 1 - supported
    #[inline(always)]
    pub fn cmd_ccc_defbyte(&self) -> bool {
        ((self.0 >> 10) & 1) != 0
    }
    /// HDR-Ternary transfers:
    ///
    /// 0 - not supported
    ///
    /// 1 - supported
    #[inline(always)]
    pub fn hdr_ts_en(&self) -> bool {
        ((self.0 >> 7) & 1) != 0
    }
    /// HDR-DDR transfers:
    ///
    /// 0 - not supported
    ///
    /// 1 - supported
    #[inline(always)]
    pub fn hdr_ddr_en(&self) -> bool {
        ((self.0 >> 6) & 1) != 0
    }
    /// Switching from active to standby mode:
    ///
    /// 0 - not supported, this controller is always active on I3C
    ///
    /// 1- supported, this controller can hand off I3C to secondary controller
    #[inline(always)]
    pub fn standby_cr_cap(&self) -> bool {
        ((self.0 >> 5) & 1) != 0
    }
    /// Automatic read command on IBI:
    ///
    /// 0 - not supported
    ///
    /// 1 - supported
    #[inline(always)]
    pub fn auto_command(&self) -> bool {
        ((self.0 >> 3) & 1) != 0
    }
    /// Controller combined command:
    ///
    /// 0 - not supported
    ///
    /// 1 - supported
    #[inline(always)]
    pub fn combo_command(&self) -> bool {
        ((self.0 >> 2) & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> HcCapabilitiesWriteVal {
        HcCapabilitiesWriteVal(self.0)
    }
}
impl From<u32> for HcCapabilitiesReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<HcCapabilitiesReadVal> for u32 {
    #[inline(always)]
    fn from(val: HcCapabilitiesReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct HcCapabilitiesWriteVal(u32);
impl HcCapabilitiesWriteVal {
    /// Device context memory:
    ///
    /// 0 - must be physically continuous
    ///
    /// 1 - controller supports scatter-gather
    #[inline(always)]
    pub fn sg_capability_dc_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 30)) | (u32::from(val) << 30))
    }
    /// DMA only: IBI status and IBI Data rings memory:
    ///
    /// 0 - must be physically continuous
    ///
    /// 1 - controller supports scatter-gather
    #[inline(always)]
    pub fn sg_capability_ibi_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 29)) | (u32::from(val) << 29))
    }
    /// DMA only: Command and Response rings memory:
    ///
    /// 0 - must be physically continuous
    ///
    /// 1 - controller supports scatter-gather
    #[inline(always)]
    pub fn sg_capability_cr_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 28)) | (u32::from(val) << 28))
    }
    /// Size and structure of the Command Descriptor:
    ///
    /// 2'b0: 2 DWORDs,
    ///
    /// all other reserved.
    #[inline(always)]
    pub fn cmd_size(self, val: u32) -> Self {
        Self((self.0 & !(3 << 20)) | ((val & 3) << 20))
    }
    /// Controller command scheduling:
    ///
    /// 0 - not supported
    ///
    /// 1 - supported
    #[inline(always)]
    pub fn scheduled_commands_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
    }
    /// Controller IBI credit count:
    ///
    /// 0 - not supported
    ///
    /// 1 - supported
    #[inline(always)]
    pub fn ibi_credit_count_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
    }
    /// Controller IBI data abort:
    ///
    /// 0 - not supported
    ///
    /// 1 - supported
    #[inline(always)]
    pub fn ibi_data_abort_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
    }
    /// CCC with defining byte:
    ///
    /// 0 - not supported
    ///
    /// 1 - supported
    #[inline(always)]
    pub fn cmd_ccc_defbyte(self, val: bool) -> Self {
        Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
    }
    /// HDR-Ternary transfers:
    ///
    /// 0 - not supported
    ///
    /// 1 - supported
    #[inline(always)]
    pub fn hdr_ts_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 7)) | (u32::from(val) << 7))
    }
    /// HDR-DDR transfers:
    ///
    /// 0 - not supported
    ///
    /// 1 - supported
    #[inline(always)]
    pub fn hdr_ddr_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 6)) | (u32::from(val) << 6))
    }
    /// Switching from active to standby mode:
    ///
    /// 0 - not supported, this controller is always active on I3C
    ///
    /// 1- supported, this controller can hand off I3C to secondary controller
    #[inline(always)]
    pub fn standby_cr_cap(self, val: bool) -> Self {
        Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
    }
    /// Automatic read command on IBI:
    ///
    /// 0 - not supported
    ///
    /// 1 - supported
    #[inline(always)]
    pub fn auto_command(self, val: bool) -> Self {
        Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
    }
    /// Controller combined command:
    ///
    /// 0 - not supported
    ///
    /// 1 - supported
    #[inline(always)]
    pub fn combo_command(self, val: bool) -> Self {
        Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
    }
}
impl From<u32> for HcCapabilitiesWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<HcCapabilitiesWriteVal> for u32 {
    #[inline(always)]
    fn from(val: HcCapabilitiesWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ResetControlReadVal(u32);
impl ResetControlReadVal {
    /// Clear IBI queue from software. Valid only in PIO mode.
    #[inline(always)]
    pub fn ibi_queue_rst(&self) -> bool {
        ((self.0 >> 5) & 1) != 0
    }
    /// Clear RX FIFO from software. Valid only in PIO mode.
    #[inline(always)]
    pub fn rx_fifo_rst(&self) -> bool {
        ((self.0 >> 4) & 1) != 0
    }
    /// Clear TX FIFO from software. Valid only in PIO mode.
    #[inline(always)]
    pub fn tx_fifo_rst(&self) -> bool {
        ((self.0 >> 3) & 1) != 0
    }
    /// Clear response queue from software. Valid only in PIO mode.
    #[inline(always)]
    pub fn resp_queue_rst(&self) -> bool {
        ((self.0 >> 2) & 1) != 0
    }
    /// Clear command queue from software. Valid only in PIO mode.
    #[inline(always)]
    pub fn cmd_queue_rst(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    /// Reset controller from software.
    #[inline(always)]
    pub fn soft_rst(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> ResetControlWriteVal {
        ResetControlWriteVal(self.0)
    }
}
impl From<u32> for ResetControlReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ResetControlReadVal> for u32 {
    #[inline(always)]
    fn from(val: ResetControlReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ResetControlWriteVal(u32);
impl ResetControlWriteVal {
    /// Clear IBI queue from software. Valid only in PIO mode.
    #[inline(always)]
    pub fn ibi_queue_rst(self, val: bool) -> Self {
        Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
    }
    /// Clear RX FIFO from software. Valid only in PIO mode.
    #[inline(always)]
    pub fn rx_fifo_rst(self, val: bool) -> Self {
        Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
    }
    /// Clear TX FIFO from software. Valid only in PIO mode.
    #[inline(always)]
    pub fn tx_fifo_rst(self, val: bool) -> Self {
        Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
    }
    /// Clear response queue from software. Valid only in PIO mode.
    #[inline(always)]
    pub fn resp_queue_rst(self, val: bool) -> Self {
        Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
    }
    /// Clear command queue from software. Valid only in PIO mode.
    #[inline(always)]
    pub fn cmd_queue_rst(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
    /// Reset controller from software.
    #[inline(always)]
    pub fn soft_rst(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for ResetControlWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ResetControlWriteVal> for u32 {
    #[inline(always)]
    fn from(val: ResetControlWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct PresentStateReadVal(u32);
impl PresentStateReadVal {
    /// Controller I3C state:
    ///
    /// 0 - not bus owner
    ///
    /// 1 - bus owner
    #[inline(always)]
    pub fn ac_current_own(&self) -> bool {
        ((self.0 >> 2) & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> PresentStateWriteVal {
        PresentStateWriteVal(self.0)
    }
}
impl From<u32> for PresentStateReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<PresentStateReadVal> for u32 {
    #[inline(always)]
    fn from(val: PresentStateReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct PresentStateWriteVal(u32);
impl PresentStateWriteVal {
    /// Controller I3C state:
    ///
    /// 0 - not bus owner
    ///
    /// 1 - bus owner
    #[inline(always)]
    pub fn ac_current_own(self, val: bool) -> Self {
        Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
    }
}
impl From<u32> for PresentStateWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<PresentStateWriteVal> for u32 {
    #[inline(always)]
    fn from(val: PresentStateWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IntrStatusReadVal(u32);
impl IntrStatusReadVal {
    /// Scheduled commands could be executed due to controller being busy.
    #[inline(always)]
    pub fn sched_cmd_missed_tick_stat(&self) -> bool {
        ((self.0 >> 14) & 1) != 0
    }
    /// Command timeout after prolonged stall.
    #[inline(always)]
    pub fn hc_err_cmd_seq_timeout_stat(&self) -> bool {
        ((self.0 >> 13) & 1) != 0
    }
    /// Clock stalled due to lack of commands.
    #[inline(always)]
    pub fn hc_warn_cmd_seq_stall_stat(&self) -> bool {
        ((self.0 >> 12) & 1) != 0
    }
    /// Controller had to cancel command sequence.
    #[inline(always)]
    pub fn hc_seq_cancel_stat(&self) -> bool {
        ((self.0 >> 11) & 1) != 0
    }
    /// Controller internal unrecoverable error.
    #[inline(always)]
    pub fn hc_internal_err_stat(&self) -> bool {
        ((self.0 >> 10) & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> IntrStatusWriteVal {
        IntrStatusWriteVal(self.0)
    }
}
impl From<u32> for IntrStatusReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IntrStatusReadVal> for u32 {
    #[inline(always)]
    fn from(val: IntrStatusReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IntrStatusWriteVal(u32);
impl IntrStatusWriteVal {
    /// Scheduled commands could be executed due to controller being busy.
    #[inline(always)]
    pub fn sched_cmd_missed_tick_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
    }
    /// Command timeout after prolonged stall.
    #[inline(always)]
    pub fn hc_err_cmd_seq_timeout_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
    }
    /// Clock stalled due to lack of commands.
    #[inline(always)]
    pub fn hc_warn_cmd_seq_stall_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
    }
    /// Controller had to cancel command sequence.
    #[inline(always)]
    pub fn hc_seq_cancel_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
    }
    /// Controller internal unrecoverable error.
    #[inline(always)]
    pub fn hc_internal_err_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
    }
}
impl From<u32> for IntrStatusWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IntrStatusWriteVal> for u32 {
    #[inline(always)]
    fn from(val: IntrStatusWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IntrStatusEnableReadVal(u32);
impl IntrStatusEnableReadVal {
    /// Enable SCHED_CMD_MISSED_TICK_STAT monitoring.
    #[inline(always)]
    pub fn sched_cmd_missed_tick_stat_en(&self) -> bool {
        ((self.0 >> 14) & 1) != 0
    }
    /// Enable HC_ERR_CMD_SEQ_TIMEOUT_STAT monitoring.
    #[inline(always)]
    pub fn hc_err_cmd_seq_timeout_stat_en(&self) -> bool {
        ((self.0 >> 13) & 1) != 0
    }
    /// Enable HC_WARN_CMD_SEQ_STALL_STAT monitoring.
    #[inline(always)]
    pub fn hc_warn_cmd_seq_stall_stat_en(&self) -> bool {
        ((self.0 >> 12) & 1) != 0
    }
    /// Enable HC_SEQ_CANCEL_STAT monitoring.
    #[inline(always)]
    pub fn hc_seq_cancel_stat_en(&self) -> bool {
        ((self.0 >> 11) & 1) != 0
    }
    /// Enable HC_INTERNAL_ERR_STAT monitoring.
    #[inline(always)]
    pub fn hc_internal_err_stat_en(&self) -> bool {
        ((self.0 >> 10) & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> IntrStatusEnableWriteVal {
        IntrStatusEnableWriteVal(self.0)
    }
}
impl From<u32> for IntrStatusEnableReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IntrStatusEnableReadVal> for u32 {
    #[inline(always)]
    fn from(val: IntrStatusEnableReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IntrStatusEnableWriteVal(u32);
impl IntrStatusEnableWriteVal {
    /// Enable SCHED_CMD_MISSED_TICK_STAT monitoring.
    #[inline(always)]
    pub fn sched_cmd_missed_tick_stat_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
    }
    /// Enable HC_ERR_CMD_SEQ_TIMEOUT_STAT monitoring.
    #[inline(always)]
    pub fn hc_err_cmd_seq_timeout_stat_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
    }
    /// Enable HC_WARN_CMD_SEQ_STALL_STAT monitoring.
    #[inline(always)]
    pub fn hc_warn_cmd_seq_stall_stat_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
    }
    /// Enable HC_SEQ_CANCEL_STAT monitoring.
    #[inline(always)]
    pub fn hc_seq_cancel_stat_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
    }
    /// Enable HC_INTERNAL_ERR_STAT monitoring.
    #[inline(always)]
    pub fn hc_internal_err_stat_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
    }
}
impl From<u32> for IntrStatusEnableWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IntrStatusEnableWriteVal> for u32 {
    #[inline(always)]
    fn from(val: IntrStatusEnableWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IntrSignalEnableReadVal(u32);
impl IntrSignalEnableReadVal {
    /// Enable SCHED_CMD_MISSED_TICK_STAT interrupt.
    #[inline(always)]
    pub fn sched_cmd_missed_tick_signal_en(&self) -> bool {
        ((self.0 >> 14) & 1) != 0
    }
    /// Enable HC_ERR_CMD_SEQ_TIMEOUT_STAT interrupt.
    #[inline(always)]
    pub fn hc_err_cmd_seq_timeout_signal_en(&self) -> bool {
        ((self.0 >> 13) & 1) != 0
    }
    /// Enable HC_WARN_CMD_SEQ_STALL_STAT interrupt.
    #[inline(always)]
    pub fn hc_warn_cmd_seq_stall_signal_en(&self) -> bool {
        ((self.0 >> 12) & 1) != 0
    }
    /// Enable HC_SEQ_CANCEL_STAT interrupt.
    #[inline(always)]
    pub fn hc_seq_cancel_signal_en(&self) -> bool {
        ((self.0 >> 11) & 1) != 0
    }
    /// Enable HC_INTERNAL_ERR_STAT interrupt.
    #[inline(always)]
    pub fn hc_internal_err_signal_en(&self) -> bool {
        ((self.0 >> 10) & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> IntrSignalEnableWriteVal {
        IntrSignalEnableWriteVal(self.0)
    }
}
impl From<u32> for IntrSignalEnableReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IntrSignalEnableReadVal> for u32 {
    #[inline(always)]
    fn from(val: IntrSignalEnableReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IntrSignalEnableWriteVal(u32);
impl IntrSignalEnableWriteVal {
    /// Enable SCHED_CMD_MISSED_TICK_STAT interrupt.
    #[inline(always)]
    pub fn sched_cmd_missed_tick_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
    }
    /// Enable HC_ERR_CMD_SEQ_TIMEOUT_STAT interrupt.
    #[inline(always)]
    pub fn hc_err_cmd_seq_timeout_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
    }
    /// Enable HC_WARN_CMD_SEQ_STALL_STAT interrupt.
    #[inline(always)]
    pub fn hc_warn_cmd_seq_stall_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
    }
    /// Enable HC_SEQ_CANCEL_STAT interrupt.
    #[inline(always)]
    pub fn hc_seq_cancel_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
    }
    /// Enable HC_INTERNAL_ERR_STAT interrupt.
    #[inline(always)]
    pub fn hc_internal_err_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
    }
}
impl From<u32> for IntrSignalEnableWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IntrSignalEnableWriteVal> for u32 {
    #[inline(always)]
    fn from(val: IntrSignalEnableWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IntrForceReadVal(u32);
impl IntrForceReadVal {
    /// Force SCHED_CMD_MISSED_TICK_STAT interrupt.
    #[inline(always)]
    pub fn sched_cmd_missed_tick_force(&self) -> bool {
        ((self.0 >> 14) & 1) != 0
    }
    /// Force HC_ERR_CMD_SEQ_TIMEOUT_STAT interrupt.
    #[inline(always)]
    pub fn hc_err_cmd_seq_timeout_force(&self) -> bool {
        ((self.0 >> 13) & 1) != 0
    }
    /// Force HC_WARN_CMD_SEQ_STALL_STAT interrupt.
    #[inline(always)]
    pub fn hc_warn_cmd_seq_stall_force(&self) -> bool {
        ((self.0 >> 12) & 1) != 0
    }
    /// Force HC_SEQ_CANCEL_STAT interrupt.
    #[inline(always)]
    pub fn hc_seq_cancel_force(&self) -> bool {
        ((self.0 >> 11) & 1) != 0
    }
    /// Force HC_INTERNAL_ERR_STAT interrupt.
    #[inline(always)]
    pub fn hc_internal_err_force(&self) -> bool {
        ((self.0 >> 10) & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> IntrForceWriteVal {
        IntrForceWriteVal(self.0)
    }
}
impl From<u32> for IntrForceReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IntrForceReadVal> for u32 {
    #[inline(always)]
    fn from(val: IntrForceReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IntrForceWriteVal(u32);
impl IntrForceWriteVal {
    /// Force SCHED_CMD_MISSED_TICK_STAT interrupt.
    #[inline(always)]
    pub fn sched_cmd_missed_tick_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
    }
    /// Force HC_ERR_CMD_SEQ_TIMEOUT_STAT interrupt.
    #[inline(always)]
    pub fn hc_err_cmd_seq_timeout_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
    }
    /// Force HC_WARN_CMD_SEQ_STALL_STAT interrupt.
    #[inline(always)]
    pub fn hc_warn_cmd_seq_stall_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
    }
    /// Force HC_SEQ_CANCEL_STAT interrupt.
    #[inline(always)]
    pub fn hc_seq_cancel_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
    }
    /// Force HC_INTERNAL_ERR_STAT interrupt.
    #[inline(always)]
    pub fn hc_internal_err_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
    }
}
impl From<u32> for IntrForceWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IntrForceWriteVal> for u32 {
    #[inline(always)]
    fn from(val: IntrForceWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DatSectionOffsetReadVal(u32);
impl DatSectionOffsetReadVal {
    /// Individual DAT entry size.
    /// 0 - 2 DWRODs,
    /// 1:15 - reserved.
    #[inline(always)]
    pub fn entry_size(&self) -> u32 {
        (self.0 >> 28) & 0xf
    }
    /// Max number of DAT entries.
    #[inline(always)]
    pub fn table_size(&self) -> u32 {
        (self.0 >> 12) & 0x7f
    }
    /// DAT entry offset in respect to BASE address.
    #[inline(always)]
    pub fn table_offset(&self) -> u32 {
        self.0 & 0xfff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> DatSectionOffsetWriteVal {
        DatSectionOffsetWriteVal(self.0)
    }
}
impl From<u32> for DatSectionOffsetReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DatSectionOffsetReadVal> for u32 {
    #[inline(always)]
    fn from(val: DatSectionOffsetReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DatSectionOffsetWriteVal(u32);
impl DatSectionOffsetWriteVal {
    /// Individual DAT entry size.
    /// 0 - 2 DWRODs,
    /// 1:15 - reserved.
    #[inline(always)]
    pub fn entry_size(self, val: u32) -> Self {
        Self((self.0 & !(0xf << 28)) | ((val & 0xf) << 28))
    }
    /// Max number of DAT entries.
    #[inline(always)]
    pub fn table_size(self, val: u32) -> Self {
        Self((self.0 & !(0x7f << 12)) | ((val & 0x7f) << 12))
    }
    /// DAT entry offset in respect to BASE address.
    #[inline(always)]
    pub fn table_offset(self, val: u32) -> Self {
        Self((self.0 & !(0xfff)) | (val & 0xfff))
    }
}
impl From<u32> for DatSectionOffsetWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DatSectionOffsetWriteVal> for u32 {
    #[inline(always)]
    fn from(val: DatSectionOffsetWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DctSectionOffsetReadVal(u32);
impl DctSectionOffsetReadVal {
    /// Individual DCT entry size.
    ///
    /// 0 - 4 DWORDs,
    ///
    /// 1:15 - Reserved.
    #[inline(always)]
    pub fn entry_size(&self) -> u32 {
        (self.0 >> 28) & 0xf
    }
    /// Index to DCT used during ENTDAA.
    #[inline(always)]
    pub fn table_index(&self) -> u32 {
        (self.0 >> 19) & 0x1f
    }
    /// Max number of DCT entries.
    #[inline(always)]
    pub fn table_size(&self) -> u32 {
        (self.0 >> 12) & 0x7f
    }
    /// DCT entry offset in respect to BASE address.
    #[inline(always)]
    pub fn table_offset(&self) -> u32 {
        self.0 & 0xfff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> DctSectionOffsetWriteVal {
        DctSectionOffsetWriteVal(self.0)
    }
}
impl From<u32> for DctSectionOffsetReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DctSectionOffsetReadVal> for u32 {
    #[inline(always)]
    fn from(val: DctSectionOffsetReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DctSectionOffsetWriteVal(u32);
impl DctSectionOffsetWriteVal {
    /// Individual DCT entry size.
    ///
    /// 0 - 4 DWORDs,
    ///
    /// 1:15 - Reserved.
    #[inline(always)]
    pub fn entry_size(self, val: u32) -> Self {
        Self((self.0 & !(0xf << 28)) | ((val & 0xf) << 28))
    }
    /// Index to DCT used during ENTDAA.
    #[inline(always)]
    pub fn table_index(self, val: u32) -> Self {
        Self((self.0 & !(0x1f << 19)) | ((val & 0x1f) << 19))
    }
    /// Max number of DCT entries.
    #[inline(always)]
    pub fn table_size(self, val: u32) -> Self {
        Self((self.0 & !(0x7f << 12)) | ((val & 0x7f) << 12))
    }
    /// DCT entry offset in respect to BASE address.
    #[inline(always)]
    pub fn table_offset(self, val: u32) -> Self {
        Self((self.0 & !(0xfff)) | (val & 0xfff))
    }
}
impl From<u32> for DctSectionOffsetWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DctSectionOffsetWriteVal> for u32 {
    #[inline(always)]
    fn from(val: DctSectionOffsetWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct RingHeadersSectionOffsetReadVal(u32);
impl RingHeadersSectionOffsetReadVal {
    /// DMA ring headers section offset. Invalid if 0.
    #[inline(always)]
    pub fn section_offset(&self) -> u32 {
        self.0 & 0xffff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> RingHeadersSectionOffsetWriteVal {
        RingHeadersSectionOffsetWriteVal(self.0)
    }
}
impl From<u32> for RingHeadersSectionOffsetReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<RingHeadersSectionOffsetReadVal> for u32 {
    #[inline(always)]
    fn from(val: RingHeadersSectionOffsetReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct RingHeadersSectionOffsetWriteVal(u32);
impl RingHeadersSectionOffsetWriteVal {
    /// DMA ring headers section offset. Invalid if 0.
    #[inline(always)]
    pub fn section_offset(self, val: u32) -> Self {
        Self((self.0 & !(0xffff)) | (val & 0xffff))
    }
}
impl From<u32> for RingHeadersSectionOffsetWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<RingHeadersSectionOffsetWriteVal> for u32 {
    #[inline(always)]
    fn from(val: RingHeadersSectionOffsetWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct PioSectionOffsetReadVal(u32);
impl PioSectionOffsetReadVal {
    /// PIO section offset. Invalid if 0.
    #[inline(always)]
    pub fn section_offset(&self) -> u32 {
        self.0 & 0xffff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> PioSectionOffsetWriteVal {
        PioSectionOffsetWriteVal(self.0)
    }
}
impl From<u32> for PioSectionOffsetReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<PioSectionOffsetReadVal> for u32 {
    #[inline(always)]
    fn from(val: PioSectionOffsetReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct PioSectionOffsetWriteVal(u32);
impl PioSectionOffsetWriteVal {
    /// PIO section offset. Invalid if 0.
    #[inline(always)]
    pub fn section_offset(self, val: u32) -> Self {
        Self((self.0 & !(0xffff)) | (val & 0xffff))
    }
}
impl From<u32> for PioSectionOffsetWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<PioSectionOffsetWriteVal> for u32 {
    #[inline(always)]
    fn from(val: PioSectionOffsetWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ExtCapsSectionOffsetReadVal(u32);
impl ExtCapsSectionOffsetReadVal {
    /// Extended Capabilities section offset. Invalid if 0.
    #[inline(always)]
    pub fn section_offset(&self) -> u32 {
        self.0 & 0xffff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> ExtCapsSectionOffsetWriteVal {
        ExtCapsSectionOffsetWriteVal(self.0)
    }
}
impl From<u32> for ExtCapsSectionOffsetReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ExtCapsSectionOffsetReadVal> for u32 {
    #[inline(always)]
    fn from(val: ExtCapsSectionOffsetReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ExtCapsSectionOffsetWriteVal(u32);
impl ExtCapsSectionOffsetWriteVal {
    /// Extended Capabilities section offset. Invalid if 0.
    #[inline(always)]
    pub fn section_offset(self, val: u32) -> Self {
        Self((self.0 & !(0xffff)) | (val & 0xffff))
    }
}
impl From<u32> for ExtCapsSectionOffsetWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ExtCapsSectionOffsetWriteVal> for u32 {
    #[inline(always)]
    fn from(val: ExtCapsSectionOffsetWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IntCtrlCmdsEnReadVal(u32);
impl IntCtrlCmdsEnReadVal {
    /// Bitmask of supported MIPI commands.
    #[inline(always)]
    pub fn mipi_cmds_supported(&self) -> u32 {
        (self.0 >> 1) & 0x7fff
    }
    /// Internal Control Commands:
    ///
    /// 1 - some or all internals commands sub-commands are supported,
    ///
    /// 0 - illegal.
    #[inline(always)]
    pub fn icc_support(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> IntCtrlCmdsEnWriteVal {
        IntCtrlCmdsEnWriteVal(self.0)
    }
}
impl From<u32> for IntCtrlCmdsEnReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IntCtrlCmdsEnReadVal> for u32 {
    #[inline(always)]
    fn from(val: IntCtrlCmdsEnReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IntCtrlCmdsEnWriteVal(u32);
impl IntCtrlCmdsEnWriteVal {
    /// Bitmask of supported MIPI commands.
    #[inline(always)]
    pub fn mipi_cmds_supported(self, val: u32) -> Self {
        Self((self.0 & !(0x7fff << 1)) | ((val & 0x7fff) << 1))
    }
    /// Internal Control Commands:
    ///
    /// 1 - some or all internals commands sub-commands are supported,
    ///
    /// 0 - illegal.
    #[inline(always)]
    pub fn icc_support(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for IntCtrlCmdsEnWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IntCtrlCmdsEnWriteVal> for u32 {
    #[inline(always)]
    fn from(val: IntCtrlCmdsEnWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IbiNotifyCtrlReadVal(u32);
impl IbiNotifyCtrlReadVal {
    /// Notify about rejected IBI:
    ///
    /// 0 - do not enqueue rejected IBI,
    ///
    /// 1 = enqueue rejected IBI on IBI queue/ring.
    #[inline(always)]
    pub fn notify_ibi_rejected(&self) -> bool {
        ((self.0 >> 3) & 1) != 0
    }
    /// Notify about rejected controller role request:
    ///
    /// 0 - do not enqueue rejected CRR,
    ///
    /// 1 = enqueue rejected CRR on IBI queue/ring.
    #[inline(always)]
    pub fn notify_crr_rejected(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    /// Notify about rejected hot-join:
    ///
    /// 0 - do not enqueue rejected HJ,
    ///
    /// 1 = enqueue rejected HJ on IBI queue/ring.
    #[inline(always)]
    pub fn notify_hj_rejected(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> IbiNotifyCtrlWriteVal {
        IbiNotifyCtrlWriteVal(self.0)
    }
}
impl From<u32> for IbiNotifyCtrlReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IbiNotifyCtrlReadVal> for u32 {
    #[inline(always)]
    fn from(val: IbiNotifyCtrlReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IbiNotifyCtrlWriteVal(u32);
impl IbiNotifyCtrlWriteVal {
    /// Notify about rejected IBI:
    ///
    /// 0 - do not enqueue rejected IBI,
    ///
    /// 1 = enqueue rejected IBI on IBI queue/ring.
    #[inline(always)]
    pub fn notify_ibi_rejected(self, val: bool) -> Self {
        Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
    }
    /// Notify about rejected controller role request:
    ///
    /// 0 - do not enqueue rejected CRR,
    ///
    /// 1 = enqueue rejected CRR on IBI queue/ring.
    #[inline(always)]
    pub fn notify_crr_rejected(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
    /// Notify about rejected hot-join:
    ///
    /// 0 - do not enqueue rejected HJ,
    ///
    /// 1 = enqueue rejected HJ on IBI queue/ring.
    #[inline(always)]
    pub fn notify_hj_rejected(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for IbiNotifyCtrlWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IbiNotifyCtrlWriteVal> for u32 {
    #[inline(always)]
    fn from(val: IbiNotifyCtrlWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IbiDataAbortCtrlReadVal(u32);
impl IbiDataAbortCtrlReadVal {
    /// Enable/disable IBI monitoring logic.
    #[inline(always)]
    pub fn ibi_data_abort_mon(&self) -> bool {
        ((self.0 >> 31) & 1) != 0
    }
    /// Define which IBI should be aborted:
    ///
    /// 3'b000 - Regular IBI,
    ///
    /// 3'b100 - Autocmd IBI,
    ///
    /// other values - not supported.
    #[inline(always)]
    pub fn match_status_type(&self) -> u32 {
        (self.0 >> 18) & 7
    }
    /// Number of data chunks to be allowed before forced termination:
    ///
    /// 0 - immediate,
    ///
    /// 1:3 - delay by 1-3 data chunks.
    #[inline(always)]
    pub fn after_n_chunks(&self) -> u32 {
        (self.0 >> 16) & 3
    }
    /// IBI target address:
    ///
    /// [15:9] - device address,
    ///
    /// [8] - must always be set to 1'b1
    #[inline(always)]
    pub fn match_ibi_id(&self) -> u32 {
        (self.0 >> 8) & 0xff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> IbiDataAbortCtrlWriteVal {
        IbiDataAbortCtrlWriteVal(self.0)
    }
}
impl From<u32> for IbiDataAbortCtrlReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IbiDataAbortCtrlReadVal> for u32 {
    #[inline(always)]
    fn from(val: IbiDataAbortCtrlReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IbiDataAbortCtrlWriteVal(u32);
impl IbiDataAbortCtrlWriteVal {
    /// Enable/disable IBI monitoring logic.
    #[inline(always)]
    pub fn ibi_data_abort_mon(self, val: bool) -> Self {
        Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
    }
    /// Define which IBI should be aborted:
    ///
    /// 3'b000 - Regular IBI,
    ///
    /// 3'b100 - Autocmd IBI,
    ///
    /// other values - not supported.
    #[inline(always)]
    pub fn match_status_type(self, val: u32) -> Self {
        Self((self.0 & !(7 << 18)) | ((val & 7) << 18))
    }
    /// Number of data chunks to be allowed before forced termination:
    ///
    /// 0 - immediate,
    ///
    /// 1:3 - delay by 1-3 data chunks.
    #[inline(always)]
    pub fn after_n_chunks(self, val: u32) -> Self {
        Self((self.0 & !(3 << 16)) | ((val & 3) << 16))
    }
    /// IBI target address:
    ///
    /// [15:9] - device address,
    ///
    /// [8] - must always be set to 1'b1
    #[inline(always)]
    pub fn match_ibi_id(self, val: u32) -> Self {
        Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
    }
}
impl From<u32> for IbiDataAbortCtrlWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IbiDataAbortCtrlWriteVal> for u32 {
    #[inline(always)]
    fn from(val: IbiDataAbortCtrlWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DevCtxBaseLoReadVal(u32);
impl DevCtxBaseLoReadVal {
    #[inline(always)]
    pub fn base_lo(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> DevCtxBaseLoWriteVal {
        DevCtxBaseLoWriteVal(self.0)
    }
}
impl From<u32> for DevCtxBaseLoReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DevCtxBaseLoReadVal> for u32 {
    #[inline(always)]
    fn from(val: DevCtxBaseLoReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DevCtxBaseLoWriteVal(u32);
impl DevCtxBaseLoWriteVal {
    #[inline(always)]
    pub fn base_lo(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for DevCtxBaseLoWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DevCtxBaseLoWriteVal> for u32 {
    #[inline(always)]
    fn from(val: DevCtxBaseLoWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DevCtxBaseHiReadVal(u32);
impl DevCtxBaseHiReadVal {
    #[inline(always)]
    pub fn base_hi(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> DevCtxBaseHiWriteVal {
        DevCtxBaseHiWriteVal(self.0)
    }
}
impl From<u32> for DevCtxBaseHiReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DevCtxBaseHiReadVal> for u32 {
    #[inline(always)]
    fn from(val: DevCtxBaseHiReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DevCtxBaseHiWriteVal(u32);
impl DevCtxBaseHiWriteVal {
    #[inline(always)]
    pub fn base_hi(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for DevCtxBaseHiWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DevCtxBaseHiWriteVal> for u32 {
    #[inline(always)]
    fn from(val: DevCtxBaseHiWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DevCtxSgReadVal(u32);
impl DevCtxSgReadVal {
    /// Buffer vs list pointer in device context:
    ///
    /// 0 - continuous physical memory region,
    ///
    /// 1 - pointer to SG descriptor list.
    #[inline(always)]
    pub fn blp(&self) -> bool {
        ((self.0 >> 31) & 1) != 0
    }
    /// Number of SG entries.
    #[inline(always)]
    pub fn list_size(&self) -> u32 {
        self.0 & 0xffff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> DevCtxSgWriteVal {
        DevCtxSgWriteVal(self.0)
    }
}
impl From<u32> for DevCtxSgReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DevCtxSgReadVal> for u32 {
    #[inline(always)]
    fn from(val: DevCtxSgReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DevCtxSgWriteVal(u32);
impl DevCtxSgWriteVal {
    /// Buffer vs list pointer in device context:
    ///
    /// 0 - continuous physical memory region,
    ///
    /// 1 - pointer to SG descriptor list.
    #[inline(always)]
    pub fn blp(self, val: bool) -> Self {
        Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
    }
    /// Number of SG entries.
    #[inline(always)]
    pub fn list_size(self, val: u32) -> Self {
        Self((self.0 & !(0xffff)) | (val & 0xffff))
    }
}
impl From<u32> for DevCtxSgWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DevCtxSgWriteVal> for u32 {
    #[inline(always)]
    fn from(val: DevCtxSgWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IbiPortReadVal(u32);
impl IbiPortReadVal {
    #[inline(always)]
    pub fn ibi_data(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> IbiPortWriteVal {
        IbiPortWriteVal(self.0)
    }
}
impl From<u32> for IbiPortReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IbiPortReadVal> for u32 {
    #[inline(always)]
    fn from(val: IbiPortReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IbiPortWriteVal(u32);
impl IbiPortWriteVal {
    #[inline(always)]
    pub fn ibi_data(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for IbiPortWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IbiPortWriteVal> for u32 {
    #[inline(always)]
    fn from(val: IbiPortWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct QueueThldCtrlReadVal(u32);
impl QueueThldCtrlReadVal {
    /// Triggers IBI_STATUS_THLD_STAT interrupt when IBI queue has N or more entries. Accepted values are 1:255
    #[inline(always)]
    pub fn ibi_status_thld(&self) -> u32 {
        (self.0 >> 24) & 0xff
    }
    /// IBI Queue data segment size. Valida values are 1:63
    #[inline(always)]
    pub fn ibi_data_segment_size(&self) -> u32 {
        (self.0 >> 16) & 0xff
    }
    /// Triggers RESP_READY_STAT interrupt when RESP queue has N or more entries. Accepted values are 1:255
    #[inline(always)]
    pub fn resp_buf_thld(&self) -> u32 {
        (self.0 >> 8) & 0xff
    }
    /// Triggers CMD_QUEUE_READY_STAT interrupt when CMD queue has N or more free entries. Accepted values are 1:255
    #[inline(always)]
    pub fn cmd_empty_buf_thld(&self) -> u32 {
        self.0 & 0xff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> QueueThldCtrlWriteVal {
        QueueThldCtrlWriteVal(self.0)
    }
}
impl From<u32> for QueueThldCtrlReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<QueueThldCtrlReadVal> for u32 {
    #[inline(always)]
    fn from(val: QueueThldCtrlReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct QueueThldCtrlWriteVal(u32);
impl QueueThldCtrlWriteVal {
    /// Triggers IBI_STATUS_THLD_STAT interrupt when IBI queue has N or more entries. Accepted values are 1:255
    #[inline(always)]
    pub fn ibi_status_thld(self, val: u32) -> Self {
        Self((self.0 & !(0xff << 24)) | ((val & 0xff) << 24))
    }
    /// IBI Queue data segment size. Valida values are 1:63
    #[inline(always)]
    pub fn ibi_data_segment_size(self, val: u32) -> Self {
        Self((self.0 & !(0xff << 16)) | ((val & 0xff) << 16))
    }
    /// Triggers RESP_READY_STAT interrupt when RESP queue has N or more entries. Accepted values are 1:255
    #[inline(always)]
    pub fn resp_buf_thld(self, val: u32) -> Self {
        Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
    }
    /// Triggers CMD_QUEUE_READY_STAT interrupt when CMD queue has N or more free entries. Accepted values are 1:255
    #[inline(always)]
    pub fn cmd_empty_buf_thld(self, val: u32) -> Self {
        Self((self.0 & !(0xff)) | (val & 0xff))
    }
}
impl From<u32> for QueueThldCtrlWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<QueueThldCtrlWriteVal> for u32 {
    #[inline(always)]
    fn from(val: QueueThldCtrlWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DataBufferThldCtrlReadVal(u32);
impl DataBufferThldCtrlReadVal {
    /// Postpone read command until RX queue has 2^(N+1) free entries
    #[inline(always)]
    pub fn rx_start_thld(&self) -> u32 {
        (self.0 >> 24) & 7
    }
    /// Postpone write command until TX queue has 2^(N+1) entries
    #[inline(always)]
    pub fn tx_start_thld(&self) -> u32 {
        (self.0 >> 16) & 7
    }
    /// Trigger RX_THLD_STAT interrupt when RX queue has 2^(N+1) or more entries
    #[inline(always)]
    pub fn rx_buf_thld(&self) -> u32 {
        (self.0 >> 8) & 7
    }
    /// Trigger TX_THLD_STAT interrupt when TX queue has 2^(N+1) or more free entries
    #[inline(always)]
    pub fn tx_buf_thld(&self) -> u32 {
        self.0 & 7
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> DataBufferThldCtrlWriteVal {
        DataBufferThldCtrlWriteVal(self.0)
    }
}
impl From<u32> for DataBufferThldCtrlReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DataBufferThldCtrlReadVal> for u32 {
    #[inline(always)]
    fn from(val: DataBufferThldCtrlReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DataBufferThldCtrlWriteVal(u32);
impl DataBufferThldCtrlWriteVal {
    /// Postpone read command until RX queue has 2^(N+1) free entries
    #[inline(always)]
    pub fn rx_start_thld(self, val: u32) -> Self {
        Self((self.0 & !(7 << 24)) | ((val & 7) << 24))
    }
    /// Postpone write command until TX queue has 2^(N+1) entries
    #[inline(always)]
    pub fn tx_start_thld(self, val: u32) -> Self {
        Self((self.0 & !(7 << 16)) | ((val & 7) << 16))
    }
    /// Trigger RX_THLD_STAT interrupt when RX queue has 2^(N+1) or more entries
    #[inline(always)]
    pub fn rx_buf_thld(self, val: u32) -> Self {
        Self((self.0 & !(7 << 8)) | ((val & 7) << 8))
    }
    /// Trigger TX_THLD_STAT interrupt when TX queue has 2^(N+1) or more free entries
    #[inline(always)]
    pub fn tx_buf_thld(self, val: u32) -> Self {
        Self((self.0 & !(7)) | (val & 7))
    }
}
impl From<u32> for DataBufferThldCtrlWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DataBufferThldCtrlWriteVal> for u32 {
    #[inline(always)]
    fn from(val: DataBufferThldCtrlWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct QueueSizeReadVal(u32);
impl QueueSizeReadVal {
    /// TX queue size is equal to 2^(N+1), where N is this field value
    #[inline(always)]
    pub fn tx_data_buffer_size(&self) -> u32 {
        (self.0 >> 24) & 0xff
    }
    /// RX queue size is equal to 2^(N+1), where N is this field value
    #[inline(always)]
    pub fn rx_data_buffer_size(&self) -> u32 {
        (self.0 >> 16) & 0xff
    }
    /// IBI Queue size is equal to N
    #[inline(always)]
    pub fn ibi_status_size(&self) -> u32 {
        (self.0 >> 8) & 0xff
    }
    /// Command/Response queue size is equal to N
    #[inline(always)]
    pub fn cr_queue_size(&self) -> u32 {
        self.0 & 0xff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> QueueSizeWriteVal {
        QueueSizeWriteVal(self.0)
    }
}
impl From<u32> for QueueSizeReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<QueueSizeReadVal> for u32 {
    #[inline(always)]
    fn from(val: QueueSizeReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct QueueSizeWriteVal(u32);
impl QueueSizeWriteVal {
    /// TX queue size is equal to 2^(N+1), where N is this field value
    #[inline(always)]
    pub fn tx_data_buffer_size(self, val: u32) -> Self {
        Self((self.0 & !(0xff << 24)) | ((val & 0xff) << 24))
    }
    /// RX queue size is equal to 2^(N+1), where N is this field value
    #[inline(always)]
    pub fn rx_data_buffer_size(self, val: u32) -> Self {
        Self((self.0 & !(0xff << 16)) | ((val & 0xff) << 16))
    }
    /// IBI Queue size is equal to N
    #[inline(always)]
    pub fn ibi_status_size(self, val: u32) -> Self {
        Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
    }
    /// Command/Response queue size is equal to N
    #[inline(always)]
    pub fn cr_queue_size(self, val: u32) -> Self {
        Self((self.0 & !(0xff)) | (val & 0xff))
    }
}
impl From<u32> for QueueSizeWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<QueueSizeWriteVal> for u32 {
    #[inline(always)]
    fn from(val: QueueSizeWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct AltQueueSizeReadVal(u32);
impl AltQueueSizeReadVal {
    /// 1 indicates that IBI queue size is equal to 8*IBI_STATUS_SIZE
    #[inline(always)]
    pub fn ext_ibi_queue_en(&self) -> bool {
        ((self.0 >> 28) & 1) != 0
    }
    /// If set, response and command queues are not equal lengths, then
    /// ALT_RESP_QUEUE_SIZE contains response queue size
    #[inline(always)]
    pub fn alt_resp_queue_en(&self) -> bool {
        ((self.0 >> 24) & 1) != 0
    }
    /// Valid only if ALT_RESP_QUEUE_EN is set. Contains response queue size
    #[inline(always)]
    pub fn alt_resp_queue_size(&self) -> u32 {
        self.0 & 0xff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> AltQueueSizeWriteVal {
        AltQueueSizeWriteVal(self.0)
    }
}
impl From<u32> for AltQueueSizeReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<AltQueueSizeReadVal> for u32 {
    #[inline(always)]
    fn from(val: AltQueueSizeReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct AltQueueSizeWriteVal(u32);
impl AltQueueSizeWriteVal {
    /// 1 indicates that IBI queue size is equal to 8*IBI_STATUS_SIZE
    #[inline(always)]
    pub fn ext_ibi_queue_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 28)) | (u32::from(val) << 28))
    }
    /// If set, response and command queues are not equal lengths, then
    /// ALT_RESP_QUEUE_SIZE contains response queue size
    #[inline(always)]
    pub fn alt_resp_queue_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 24)) | (u32::from(val) << 24))
    }
    /// Valid only if ALT_RESP_QUEUE_EN is set. Contains response queue size
    #[inline(always)]
    pub fn alt_resp_queue_size(self, val: u32) -> Self {
        Self((self.0 & !(0xff)) | (val & 0xff))
    }
}
impl From<u32> for AltQueueSizeWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<AltQueueSizeWriteVal> for u32 {
    #[inline(always)]
    fn from(val: AltQueueSizeWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct PioIntrStatusReadVal(u32);
impl PioIntrStatusReadVal {
    /// Transfer error
    #[inline(always)]
    pub fn transfer_err_stat(&self) -> bool {
        ((self.0 >> 9) & 1) != 0
    }
    /// Transfer aborted
    #[inline(always)]
    pub fn transfer_abort_stat(&self) -> bool {
        ((self.0 >> 5) & 1) != 0
    }
    /// Response queue fulfils RESP_BUF_THLD
    #[inline(always)]
    pub fn resp_ready_stat(&self) -> bool {
        ((self.0 >> 4) & 1) != 0
    }
    /// Command queue fulfils CMD_EMPTY_BUF_THLD
    #[inline(always)]
    pub fn cmd_queue_ready_stat(&self) -> bool {
        ((self.0 >> 3) & 1) != 0
    }
    /// IBI queue fulfils IBI_STATUS_THLD
    #[inline(always)]
    pub fn ibi_status_thld_stat(&self) -> bool {
        ((self.0 >> 2) & 1) != 0
    }
    /// RX queue fulfils RX_BUF_THLD
    #[inline(always)]
    pub fn rx_thld_stat(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    /// TX queue fulfils TX_BUF_THLD
    #[inline(always)]
    pub fn tx_thld_stat(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> PioIntrStatusWriteVal {
        PioIntrStatusWriteVal(self.0)
    }
}
impl From<u32> for PioIntrStatusReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<PioIntrStatusReadVal> for u32 {
    #[inline(always)]
    fn from(val: PioIntrStatusReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct PioIntrStatusWriteVal(u32);
impl PioIntrStatusWriteVal {
    /// Transfer error
    #[inline(always)]
    pub fn transfer_err_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
    }
    /// Transfer aborted
    #[inline(always)]
    pub fn transfer_abort_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
    }
    /// Response queue fulfils RESP_BUF_THLD
    #[inline(always)]
    pub fn resp_ready_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
    }
    /// Command queue fulfils CMD_EMPTY_BUF_THLD
    #[inline(always)]
    pub fn cmd_queue_ready_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
    }
    /// IBI queue fulfils IBI_STATUS_THLD
    #[inline(always)]
    pub fn ibi_status_thld_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
    }
    /// RX queue fulfils RX_BUF_THLD
    #[inline(always)]
    pub fn rx_thld_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
    /// TX queue fulfils TX_BUF_THLD
    #[inline(always)]
    pub fn tx_thld_stat(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for PioIntrStatusWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<PioIntrStatusWriteVal> for u32 {
    #[inline(always)]
    fn from(val: PioIntrStatusWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct PioIntrStatusEnableReadVal(u32);
impl PioIntrStatusEnableReadVal {
    /// Enable transfer error monitoring
    #[inline(always)]
    pub fn transfer_err_stat_en(&self) -> bool {
        ((self.0 >> 9) & 1) != 0
    }
    /// Enable transfer abort monitoring
    #[inline(always)]
    pub fn transfer_abort_stat_en(&self) -> bool {
        ((self.0 >> 5) & 1) != 0
    }
    /// Enable response queue monitoring
    #[inline(always)]
    pub fn resp_ready_stat_en(&self) -> bool {
        ((self.0 >> 4) & 1) != 0
    }
    /// Enable command queue monitoring
    #[inline(always)]
    pub fn cmd_queue_ready_stat_en(&self) -> bool {
        ((self.0 >> 3) & 1) != 0
    }
    /// Enable IBI queue monitoring
    #[inline(always)]
    pub fn ibi_status_thld_stat_en(&self) -> bool {
        ((self.0 >> 2) & 1) != 0
    }
    /// Enable RX queue monitoring
    #[inline(always)]
    pub fn rx_thld_stat_en(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    /// Enable TX queue monitoring
    #[inline(always)]
    pub fn tx_thld_stat_en(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> PioIntrStatusEnableWriteVal {
        PioIntrStatusEnableWriteVal(self.0)
    }
}
impl From<u32> for PioIntrStatusEnableReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<PioIntrStatusEnableReadVal> for u32 {
    #[inline(always)]
    fn from(val: PioIntrStatusEnableReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct PioIntrStatusEnableWriteVal(u32);
impl PioIntrStatusEnableWriteVal {
    /// Enable transfer error monitoring
    #[inline(always)]
    pub fn transfer_err_stat_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
    }
    /// Enable transfer abort monitoring
    #[inline(always)]
    pub fn transfer_abort_stat_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
    }
    /// Enable response queue monitoring
    #[inline(always)]
    pub fn resp_ready_stat_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
    }
    /// Enable command queue monitoring
    #[inline(always)]
    pub fn cmd_queue_ready_stat_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
    }
    /// Enable IBI queue monitoring
    #[inline(always)]
    pub fn ibi_status_thld_stat_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
    }
    /// Enable RX queue monitoring
    #[inline(always)]
    pub fn rx_thld_stat_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
    /// Enable TX queue monitoring
    #[inline(always)]
    pub fn tx_thld_stat_en(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for PioIntrStatusEnableWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<PioIntrStatusEnableWriteVal> for u32 {
    #[inline(always)]
    fn from(val: PioIntrStatusEnableWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct PioIntrSignalEnableReadVal(u32);
impl PioIntrSignalEnableReadVal {
    /// Enable transfer error interrupt
    #[inline(always)]
    pub fn transfer_err_signal_en(&self) -> bool {
        ((self.0 >> 9) & 1) != 0
    }
    /// Enable transfer abort interrupt
    #[inline(always)]
    pub fn transfer_abort_signal_en(&self) -> bool {
        ((self.0 >> 5) & 1) != 0
    }
    /// Enable response ready interrupt
    #[inline(always)]
    pub fn resp_ready_signal_en(&self) -> bool {
        ((self.0 >> 4) & 1) != 0
    }
    /// Enable command queue interrupt
    #[inline(always)]
    pub fn cmd_queue_ready_signal_en(&self) -> bool {
        ((self.0 >> 3) & 1) != 0
    }
    /// Enable IBI queue interrupt
    #[inline(always)]
    pub fn ibi_status_thld_signal_en(&self) -> bool {
        ((self.0 >> 2) & 1) != 0
    }
    /// Enable RX queue interrupt
    #[inline(always)]
    pub fn rx_thld_signal_en(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    /// Enable TX queue interrupt
    #[inline(always)]
    pub fn tx_thld_signal_en(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> PioIntrSignalEnableWriteVal {
        PioIntrSignalEnableWriteVal(self.0)
    }
}
impl From<u32> for PioIntrSignalEnableReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<PioIntrSignalEnableReadVal> for u32 {
    #[inline(always)]
    fn from(val: PioIntrSignalEnableReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct PioIntrSignalEnableWriteVal(u32);
impl PioIntrSignalEnableWriteVal {
    /// Enable transfer error interrupt
    #[inline(always)]
    pub fn transfer_err_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
    }
    /// Enable transfer abort interrupt
    #[inline(always)]
    pub fn transfer_abort_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
    }
    /// Enable response ready interrupt
    #[inline(always)]
    pub fn resp_ready_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
    }
    /// Enable command queue interrupt
    #[inline(always)]
    pub fn cmd_queue_ready_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
    }
    /// Enable IBI queue interrupt
    #[inline(always)]
    pub fn ibi_status_thld_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
    }
    /// Enable RX queue interrupt
    #[inline(always)]
    pub fn rx_thld_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
    /// Enable TX queue interrupt
    #[inline(always)]
    pub fn tx_thld_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for PioIntrSignalEnableWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<PioIntrSignalEnableWriteVal> for u32 {
    #[inline(always)]
    fn from(val: PioIntrSignalEnableWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct PioIntrForceReadVal(u32);
impl PioIntrForceReadVal {
    /// Force transfer error
    #[inline(always)]
    pub fn transfer_err_force(&self) -> bool {
        ((self.0 >> 9) & 1) != 0
    }
    /// Force transfer aborted
    #[inline(always)]
    pub fn transfer_abort_force(&self) -> bool {
        ((self.0 >> 5) & 1) != 0
    }
    /// Force response queue interrupt
    #[inline(always)]
    pub fn resp_ready_force(&self) -> bool {
        ((self.0 >> 4) & 1) != 0
    }
    /// Force command queue interrupt
    #[inline(always)]
    pub fn cmd_queue_ready_force(&self) -> bool {
        ((self.0 >> 3) & 1) != 0
    }
    /// Force IBI queue interrupt
    #[inline(always)]
    pub fn ibi_thld_force(&self) -> bool {
        ((self.0 >> 2) & 1) != 0
    }
    /// Force RX queue interrupt
    #[inline(always)]
    pub fn rx_thld_force(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    /// Force TX queue interrupt
    #[inline(always)]
    pub fn tx_thld_force(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> PioIntrForceWriteVal {
        PioIntrForceWriteVal(self.0)
    }
}
impl From<u32> for PioIntrForceReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<PioIntrForceReadVal> for u32 {
    #[inline(always)]
    fn from(val: PioIntrForceReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct PioIntrForceWriteVal(u32);
impl PioIntrForceWriteVal {
    /// Force transfer error
    #[inline(always)]
    pub fn transfer_err_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
    }
    /// Force transfer aborted
    #[inline(always)]
    pub fn transfer_abort_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
    }
    /// Force response queue interrupt
    #[inline(always)]
    pub fn resp_ready_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
    }
    /// Force command queue interrupt
    #[inline(always)]
    pub fn cmd_queue_ready_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
    }
    /// Force IBI queue interrupt
    #[inline(always)]
    pub fn ibi_thld_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
    }
    /// Force RX queue interrupt
    #[inline(always)]
    pub fn rx_thld_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
    /// Force TX queue interrupt
    #[inline(always)]
    pub fn tx_thld_force(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for PioIntrForceWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<PioIntrForceWriteVal> for u32 {
    #[inline(always)]
    fn from(val: PioIntrForceWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct PioControlReadVal(u32);
impl PioControlReadVal {
    /// Stop current command descriptor execution forcefully and hold remaining commands.
    /// 1 - Request PIO Abort,
    /// 0 - Resume PIO execution
    #[inline(always)]
    pub fn abort(&self) -> bool {
        ((self.0 >> 2) & 1) != 0
    }
    /// Run/Stop execution of enqueued commands.
    /// When set to 0, it holds execution of enqueued commands and runs current command to completion.
    /// 1 - PIO Queue start request,
    /// 0 - PIO Queue stop request.
    #[inline(always)]
    pub fn rs(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    /// Enables PIO queues. When disabled, SW may not read from/write to PIO queues.
    /// 1 - PIO queue enable request,
    /// 0 - PIO queue disable request
    #[inline(always)]
    pub fn enable(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> PioControlWriteVal {
        PioControlWriteVal(self.0)
    }
}
impl From<u32> for PioControlReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<PioControlReadVal> for u32 {
    #[inline(always)]
    fn from(val: PioControlReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct PioControlWriteVal(u32);
impl PioControlWriteVal {
    /// Stop current command descriptor execution forcefully and hold remaining commands.
    /// 1 - Request PIO Abort,
    /// 0 - Resume PIO execution
    #[inline(always)]
    pub fn abort(self, val: bool) -> Self {
        Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
    }
    /// Run/Stop execution of enqueued commands.
    /// When set to 0, it holds execution of enqueued commands and runs current command to completion.
    /// 1 - PIO Queue start request,
    /// 0 - PIO Queue stop request.
    #[inline(always)]
    pub fn rs(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
    /// Enables PIO queues. When disabled, SW may not read from/write to PIO queues.
    /// 1 - PIO queue enable request,
    /// 0 - PIO queue disable request
    #[inline(always)]
    pub fn enable(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for PioControlWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<PioControlWriteVal> for u32 {
    #[inline(always)]
    fn from(val: PioControlWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ExtcapHeaderReadVal(u32);
impl ExtcapHeaderReadVal {
    /// Capability Structure Length in DWORDs
    #[inline(always)]
    pub fn cap_length(&self) -> u32 {
        (self.0 >> 8) & 0xffff
    }
    /// Extended Capability ID
    #[inline(always)]
    pub fn cap_id(&self) -> u32 {
        self.0 & 0xff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> ExtcapHeaderWriteVal {
        ExtcapHeaderWriteVal(self.0)
    }
}
impl From<u32> for ExtcapHeaderReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ExtcapHeaderReadVal> for u32 {
    #[inline(always)]
    fn from(val: ExtcapHeaderReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ExtcapHeaderWriteVal(u32);
impl ExtcapHeaderWriteVal {
    /// Capability Structure Length in DWORDs
    #[inline(always)]
    pub fn cap_length(self, val: u32) -> Self {
        Self((self.0 & !(0xffff << 8)) | ((val & 0xffff) << 8))
    }
    /// Extended Capability ID
    #[inline(always)]
    pub fn cap_id(self, val: u32) -> Self {
        Self((self.0 & !(0xff)) | (val & 0xff))
    }
}
impl From<u32> for ExtcapHeaderWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ExtcapHeaderWriteVal> for u32 {
    #[inline(always)]
    fn from(val: ExtcapHeaderWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrControlReadVal(u32);
impl StbyCrControlReadVal {
    /// Enables or disables the Secondary Controller:
    ///
    /// 2'b00 - DISABLED: Secondary Controller is disabled.
    ///
    /// 2'b01 - ACM_INIT: Secondary Controller is enabled,
    /// but Host Controller initializes in Active Controller mode.
    ///
    /// 2'b10 - SCM_RUNNING: Secondary Controller operation is enabled,
    /// Host Controller initializes in Standby Controller mode.
    ///
    /// 2'b11 - SCM_HOT_JOIN: Secondary Controller operation is enabled,
    /// Host Controller conditionally becomes a Hot-Joining Device
    /// to receive its Dynamic Address before operating in Standby Controller mode.
    #[inline(always)]
    pub fn stby_cr_enable_init(&self) -> u32 {
        (self.0 >> 30) & 3
    }
    /// Controls whether I3C Secondary Controller Logic supports RSTACT CCC with
    /// Defining Byte 0x02.
    ///
    /// 1'b0: NOT_SUPPORTED: Do not ACK Defining Byte 0x02
    ///
    /// 1'b1: HANDLE_INTR: Support Defining Byte 0x02
    #[inline(always)]
    pub fn rstact_defbyte_02(&self) -> bool {
        ((self.0 >> 20) & 1) != 0
    }
    /// Indicates ENTDAA method is enabled.
    ///
    /// 1'b0: DISABLED: will not respond
    ///
    /// 1'b1: ENABLED: will respond
    #[inline(always)]
    pub fn daa_entdaa_enable(&self) -> bool {
        ((self.0 >> 15) & 1) != 0
    }
    /// Indicates SETDASA method is enabled.
    ///
    /// 1'b0: DISABLED: will not respond
    ///
    /// 1'b1: ENABLED: will respond
    #[inline(always)]
    pub fn daa_setdasa_enable(&self) -> bool {
        ((self.0 >> 14) & 1) != 0
    }
    /// Indicates SETAASA method is enabled.
    ///
    /// 1'b0: DISABLED: will not respond
    ///
    /// 1'b1: ENABLED: will respond
    #[inline(always)]
    pub fn daa_setaasa_enable(&self) -> bool {
        ((self.0 >> 13) & 1) != 0
    }
    /// Indicates whether Read-Type/Write-Type transaction servicing is enabled, via
    /// an I3C Target Transaction Interface to software (Section 6.17.3).
    ///
    /// 1'b0: DISABLED: not available
    ///
    /// 1'b1: ENABLED: available for software
    #[inline(always)]
    pub fn target_xact_enable(&self) -> bool {
        ((self.0 >> 12) & 1) != 0
    }
    /// Indicates which Ring Bundle will be used to capture Broadcast CCC data sent by the Active Controller.
    /// The Ring Bundle must be configured and enabled, and its IBI Ring Pair must also be initialized and ready to receive data.
    #[inline(always)]
    pub fn bast_ccc_ibi_ring(&self) -> u32 {
        (self.0 >> 8) & 7
    }
    /// Write of 1'b1 to this field shall instruct the Secondary Controller Logic
    /// to attempt to send a Controller Role Request to the I3C Bus.
    #[inline(always)]
    pub fn cr_request_send(&self) -> bool {
        ((self.0 >> 5) & 1) != 0
    }
    /// If this field has a value of 1'b1, then the Secondary Controller Logic shall
    /// report a return from Deep Sleep state to the Active Controller.
    /// Writing 1'b1 to this bit is sticky. This field shall automatically clear to 1'b0
    /// after accepting the Controller Role and transitioning to Active Controller mode.
    #[inline(always)]
    pub fn handoff_deep_sleep(&self) -> bool {
        ((self.0 >> 4) & 1) != 0
    }
    #[inline(always)]
    pub fn prime_accept_getacccr(&self) -> bool {
        ((self.0 >> 3) & 1) != 0
    }
    #[inline(always)]
    pub fn acr_fsm_op_select(&self) -> bool {
        ((self.0 >> 2) & 1) != 0
    }
    #[inline(always)]
    pub fn handoff_delay_nack(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    #[inline(always)]
    pub fn pending_rx_nack(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> StbyCrControlWriteVal {
        StbyCrControlWriteVal(self.0)
    }
}
impl From<u32> for StbyCrControlReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrControlReadVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrControlReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrControlWriteVal(u32);
impl StbyCrControlWriteVal {
    /// Enables or disables the Secondary Controller:
    ///
    /// 2'b00 - DISABLED: Secondary Controller is disabled.
    ///
    /// 2'b01 - ACM_INIT: Secondary Controller is enabled,
    /// but Host Controller initializes in Active Controller mode.
    ///
    /// 2'b10 - SCM_RUNNING: Secondary Controller operation is enabled,
    /// Host Controller initializes in Standby Controller mode.
    ///
    /// 2'b11 - SCM_HOT_JOIN: Secondary Controller operation is enabled,
    /// Host Controller conditionally becomes a Hot-Joining Device
    /// to receive its Dynamic Address before operating in Standby Controller mode.
    #[inline(always)]
    pub fn stby_cr_enable_init(self, val: u32) -> Self {
        Self((self.0 & !(3 << 30)) | ((val & 3) << 30))
    }
    /// Controls whether I3C Secondary Controller Logic supports RSTACT CCC with
    /// Defining Byte 0x02.
    ///
    /// 1'b0: NOT_SUPPORTED: Do not ACK Defining Byte 0x02
    ///
    /// 1'b1: HANDLE_INTR: Support Defining Byte 0x02
    #[inline(always)]
    pub fn rstact_defbyte_02(self, val: bool) -> Self {
        Self((self.0 & !(1 << 20)) | (u32::from(val) << 20))
    }
    /// Indicates ENTDAA method is enabled.
    ///
    /// 1'b0: DISABLED: will not respond
    ///
    /// 1'b1: ENABLED: will respond
    #[inline(always)]
    pub fn daa_entdaa_enable(self, val: bool) -> Self {
        Self((self.0 & !(1 << 15)) | (u32::from(val) << 15))
    }
    /// Indicates SETDASA method is enabled.
    ///
    /// 1'b0: DISABLED: will not respond
    ///
    /// 1'b1: ENABLED: will respond
    #[inline(always)]
    pub fn daa_setdasa_enable(self, val: bool) -> Self {
        Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
    }
    /// Indicates SETAASA method is enabled.
    ///
    /// 1'b0: DISABLED: will not respond
    ///
    /// 1'b1: ENABLED: will respond
    #[inline(always)]
    pub fn daa_setaasa_enable(self, val: bool) -> Self {
        Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
    }
    /// Indicates whether Read-Type/Write-Type transaction servicing is enabled, via
    /// an I3C Target Transaction Interface to software (Section 6.17.3).
    ///
    /// 1'b0: DISABLED: not available
    ///
    /// 1'b1: ENABLED: available for software
    #[inline(always)]
    pub fn target_xact_enable(self, val: bool) -> Self {
        Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
    }
    /// Indicates which Ring Bundle will be used to capture Broadcast CCC data sent by the Active Controller.
    /// The Ring Bundle must be configured and enabled, and its IBI Ring Pair must also be initialized and ready to receive data.
    #[inline(always)]
    pub fn bast_ccc_ibi_ring(self, val: u32) -> Self {
        Self((self.0 & !(7 << 8)) | ((val & 7) << 8))
    }
    /// Write of 1'b1 to this field shall instruct the Secondary Controller Logic
    /// to attempt to send a Controller Role Request to the I3C Bus.
    #[inline(always)]
    pub fn cr_request_send(self, val: bool) -> Self {
        Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
    }
    /// If this field has a value of 1'b1, then the Secondary Controller Logic shall
    /// report a return from Deep Sleep state to the Active Controller.
    /// Writing 1'b1 to this bit is sticky. This field shall automatically clear to 1'b0
    /// after accepting the Controller Role and transitioning to Active Controller mode.
    #[inline(always)]
    pub fn handoff_deep_sleep(self, val: bool) -> Self {
        Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
    }
    #[inline(always)]
    pub fn prime_accept_getacccr(self, val: bool) -> Self {
        Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
    }
    #[inline(always)]
    pub fn acr_fsm_op_select(self, val: bool) -> Self {
        Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
    }
    #[inline(always)]
    pub fn handoff_delay_nack(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
    #[inline(always)]
    pub fn pending_rx_nack(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for StbyCrControlWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrControlWriteVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrControlWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrDeviceAddrReadVal(u32);
impl StbyCrDeviceAddrReadVal {
    /// Indicates whether or not the value in the DYNAMIC_ADDR field is valid.
    /// 1'b0: DYNAMIC_ADDR field is not valid
    /// 1'b1: DYNAMIC_ADDR field is valid
    #[inline(always)]
    pub fn dynamic_addr_valid(&self) -> bool {
        ((self.0 >> 31) & 1) != 0
    }
    /// Contains the Host Controller Devices Dynamic Address.
    #[inline(always)]
    pub fn dynamic_addr(&self) -> u32 {
        (self.0 >> 16) & 0x7f
    }
    /// Indicates whether or not the value in the STATIC_ADDR field is valid.
    ///
    /// 1'b0: The Static Address field is not valid
    ///
    /// 1'b1: The Static Address field is valid
    #[inline(always)]
    pub fn static_addr_valid(&self) -> bool {
        ((self.0 >> 15) & 1) != 0
    }
    /// This field contains the Host Controller Devices Static Address.
    #[inline(always)]
    pub fn static_addr(&self) -> u32 {
        self.0 & 0x7f
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> StbyCrDeviceAddrWriteVal {
        StbyCrDeviceAddrWriteVal(self.0)
    }
}
impl From<u32> for StbyCrDeviceAddrReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrDeviceAddrReadVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrDeviceAddrReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrDeviceAddrWriteVal(u32);
impl StbyCrDeviceAddrWriteVal {
    /// Indicates whether or not the value in the DYNAMIC_ADDR field is valid.
    /// 1'b0: DYNAMIC_ADDR field is not valid
    /// 1'b1: DYNAMIC_ADDR field is valid
    #[inline(always)]
    pub fn dynamic_addr_valid(self, val: bool) -> Self {
        Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
    }
    /// Contains the Host Controller Devices Dynamic Address.
    #[inline(always)]
    pub fn dynamic_addr(self, val: u32) -> Self {
        Self((self.0 & !(0x7f << 16)) | ((val & 0x7f) << 16))
    }
    /// Indicates whether or not the value in the STATIC_ADDR field is valid.
    ///
    /// 1'b0: The Static Address field is not valid
    ///
    /// 1'b1: The Static Address field is valid
    #[inline(always)]
    pub fn static_addr_valid(self, val: bool) -> Self {
        Self((self.0 & !(1 << 15)) | (u32::from(val) << 15))
    }
    /// This field contains the Host Controller Devices Static Address.
    #[inline(always)]
    pub fn static_addr(self, val: u32) -> Self {
        Self((self.0 & !(0x7f)) | (val & 0x7f))
    }
}
impl From<u32> for StbyCrDeviceAddrWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrDeviceAddrWriteVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrDeviceAddrWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrCapabilitiesReadVal(u32);
impl StbyCrCapabilitiesReadVal {
    /// Defines whether Dynamic Address Assignment with ENTDAA CCC is supported.
    ///
    /// 1'b0: DISABLED: Not supported
    ///
    /// 1'b1: ENABLED: Supported
    #[inline(always)]
    pub fn daa_entdaa_support(&self) -> bool {
        ((self.0 >> 15) & 1) != 0
    }
    /// Defines whether Dynamic Address Assignment with SETDASA CCC (using Static Address) is supported.
    ///
    /// 1'b0: DISABLED: Not supported
    ///
    /// 1'b1: ENABLED: Supported
    #[inline(always)]
    pub fn daa_setdasa_support(&self) -> bool {
        ((self.0 >> 14) & 1) != 0
    }
    /// Defines whether Dynamic Address Assignment with SETAASA CCC (using Static Address) is supported.
    ///
    /// 1'b0: DISABLED: Not supported
    ///
    /// 1'b1: ENABLED: Supported
    #[inline(always)]
    pub fn daa_setaasa_support(&self) -> bool {
        ((self.0 >> 13) & 1) != 0
    }
    /// Defines whether an I3C Target Transaction Interface is supported.
    ///
    /// 1'b0: DISABLED: Not supported
    ///
    /// 1'b1: ENABLED: Supported via vendor-defined Extended Capability structure
    #[inline(always)]
    pub fn target_xact_support(&self) -> bool {
        ((self.0 >> 12) & 1) != 0
    }
    #[inline(always)]
    pub fn simple_crr_support(&self) -> bool {
        ((self.0 >> 5) & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> StbyCrCapabilitiesWriteVal {
        StbyCrCapabilitiesWriteVal(self.0)
    }
}
impl From<u32> for StbyCrCapabilitiesReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrCapabilitiesReadVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrCapabilitiesReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrCapabilitiesWriteVal(u32);
impl StbyCrCapabilitiesWriteVal {
    /// Defines whether Dynamic Address Assignment with ENTDAA CCC is supported.
    ///
    /// 1'b0: DISABLED: Not supported
    ///
    /// 1'b1: ENABLED: Supported
    #[inline(always)]
    pub fn daa_entdaa_support(self, val: bool) -> Self {
        Self((self.0 & !(1 << 15)) | (u32::from(val) << 15))
    }
    /// Defines whether Dynamic Address Assignment with SETDASA CCC (using Static Address) is supported.
    ///
    /// 1'b0: DISABLED: Not supported
    ///
    /// 1'b1: ENABLED: Supported
    #[inline(always)]
    pub fn daa_setdasa_support(self, val: bool) -> Self {
        Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
    }
    /// Defines whether Dynamic Address Assignment with SETAASA CCC (using Static Address) is supported.
    ///
    /// 1'b0: DISABLED: Not supported
    ///
    /// 1'b1: ENABLED: Supported
    #[inline(always)]
    pub fn daa_setaasa_support(self, val: bool) -> Self {
        Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
    }
    /// Defines whether an I3C Target Transaction Interface is supported.
    ///
    /// 1'b0: DISABLED: Not supported
    ///
    /// 1'b1: ENABLED: Supported via vendor-defined Extended Capability structure
    #[inline(always)]
    pub fn target_xact_support(self, val: bool) -> Self {
        Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
    }
    #[inline(always)]
    pub fn simple_crr_support(self, val: bool) -> Self {
        Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
    }
}
impl From<u32> for StbyCrCapabilitiesWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrCapabilitiesWriteVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrCapabilitiesWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrStatusReadVal(u32);
impl StbyCrStatusReadVal {
    #[inline(always)]
    pub fn hj_req_status(&self) -> bool {
        ((self.0 >> 8) & 1) != 0
    }
    #[inline(always)]
    pub fn simple_crr_status(&self) -> u32 {
        (self.0 >> 5) & 7
    }
    #[inline(always)]
    pub fn ac_current_own(&self) -> bool {
        ((self.0 >> 2) & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> StbyCrStatusWriteVal {
        StbyCrStatusWriteVal(self.0)
    }
}
impl From<u32> for StbyCrStatusReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrStatusReadVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrStatusReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrStatusWriteVal(u32);
impl StbyCrStatusWriteVal {
    #[inline(always)]
    pub fn hj_req_status(self, val: bool) -> Self {
        Self((self.0 & !(1 << 8)) | (u32::from(val) << 8))
    }
    #[inline(always)]
    pub fn simple_crr_status(self, val: u32) -> Self {
        Self((self.0 & !(7 << 5)) | ((val & 7) << 5))
    }
    #[inline(always)]
    pub fn ac_current_own(self, val: bool) -> Self {
        Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
    }
}
impl From<u32> for StbyCrStatusWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrStatusWriteVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrStatusWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrDeviceCharReadVal(u32);
impl StbyCrDeviceCharReadVal {
    #[inline(always)]
    pub fn bcr_fixed(&self) -> u32 {
        (self.0 >> 29) & 7
    }
    #[inline(always)]
    pub fn bcr_var(&self) -> u32 {
        (self.0 >> 24) & 0x1f
    }
    #[inline(always)]
    pub fn dcr(&self) -> u32 {
        (self.0 >> 16) & 0xff
    }
    #[inline(always)]
    pub fn pid_hi(&self) -> u32 {
        (self.0 >> 1) & 0x7fff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> StbyCrDeviceCharWriteVal {
        StbyCrDeviceCharWriteVal(self.0)
    }
}
impl From<u32> for StbyCrDeviceCharReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrDeviceCharReadVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrDeviceCharReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrDeviceCharWriteVal(u32);
impl StbyCrDeviceCharWriteVal {
    #[inline(always)]
    pub fn bcr_fixed(self, val: u32) -> Self {
        Self((self.0 & !(7 << 29)) | ((val & 7) << 29))
    }
    #[inline(always)]
    pub fn bcr_var(self, val: u32) -> Self {
        Self((self.0 & !(0x1f << 24)) | ((val & 0x1f) << 24))
    }
    #[inline(always)]
    pub fn dcr(self, val: u32) -> Self {
        Self((self.0 & !(0xff << 16)) | ((val & 0xff) << 16))
    }
    #[inline(always)]
    pub fn pid_hi(self, val: u32) -> Self {
        Self((self.0 & !(0x7fff << 1)) | ((val & 0x7fff) << 1))
    }
}
impl From<u32> for StbyCrDeviceCharWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrDeviceCharWriteVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrDeviceCharWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrIntrStatusReadVal(u32);
impl StbyCrIntrStatusReadVal {
    #[inline(always)]
    pub fn ccc_fatal_rstdaa_err_stat(&self) -> bool {
        ((self.0 >> 19) & 1) != 0
    }
    #[inline(always)]
    pub fn ccc_unhandled_nack_stat(&self) -> bool {
        ((self.0 >> 18) & 1) != 0
    }
    #[inline(always)]
    pub fn ccc_param_modified_stat(&self) -> bool {
        ((self.0 >> 17) & 1) != 0
    }
    #[inline(always)]
    pub fn stby_cr_op_rstact_stat(&self) -> bool {
        ((self.0 >> 16) & 1) != 0
    }
    #[inline(always)]
    pub fn stby_cr_accept_err_stat(&self) -> bool {
        ((self.0 >> 14) & 1) != 0
    }
    #[inline(always)]
    pub fn stby_cr_accept_ok_stat(&self) -> bool {
        ((self.0 >> 13) & 1) != 0
    }
    #[inline(always)]
    pub fn stby_cr_accept_nacked_stat(&self) -> bool {
        ((self.0 >> 12) & 1) != 0
    }
    #[inline(always)]
    pub fn stby_cr_dyn_addr_stat(&self) -> bool {
        ((self.0 >> 11) & 1) != 0
    }
    #[inline(always)]
    pub fn crr_response_stat(&self) -> bool {
        ((self.0 >> 10) & 1) != 0
    }
    #[inline(always)]
    pub fn acr_handoff_err_m3_stat(&self) -> bool {
        ((self.0 >> 3) & 1) != 0
    }
    #[inline(always)]
    pub fn acr_handoff_err_fail_stat(&self) -> bool {
        ((self.0 >> 2) & 1) != 0
    }
    #[inline(always)]
    pub fn acr_handoff_ok_primed_stat(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    #[inline(always)]
    pub fn acr_handoff_ok_remain_stat(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> StbyCrIntrStatusWriteVal {
        StbyCrIntrStatusWriteVal(self.0)
    }
}
impl From<u32> for StbyCrIntrStatusReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrIntrStatusReadVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrIntrStatusReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrIntrStatusWriteVal(u32);
impl StbyCrIntrStatusWriteVal {
    #[inline(always)]
    pub fn ccc_fatal_rstdaa_err_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 19)) | (u32::from(val) << 19))
    }
    #[inline(always)]
    pub fn ccc_unhandled_nack_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 18)) | (u32::from(val) << 18))
    }
    #[inline(always)]
    pub fn ccc_param_modified_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 17)) | (u32::from(val) << 17))
    }
    #[inline(always)]
    pub fn stby_cr_op_rstact_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 16)) | (u32::from(val) << 16))
    }
    #[inline(always)]
    pub fn stby_cr_accept_err_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
    }
    #[inline(always)]
    pub fn stby_cr_accept_ok_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
    }
    #[inline(always)]
    pub fn stby_cr_accept_nacked_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
    }
    #[inline(always)]
    pub fn stby_cr_dyn_addr_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
    }
    #[inline(always)]
    pub fn crr_response_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
    }
    #[inline(always)]
    pub fn acr_handoff_err_m3_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
    }
    #[inline(always)]
    pub fn acr_handoff_err_fail_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
    }
    #[inline(always)]
    pub fn acr_handoff_ok_primed_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
    #[inline(always)]
    pub fn acr_handoff_ok_remain_stat(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for StbyCrIntrStatusWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrIntrStatusWriteVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrIntrStatusWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrIntrSignalEnableReadVal(u32);
impl StbyCrIntrSignalEnableReadVal {
    #[inline(always)]
    pub fn ccc_fatal_rstdaa_err_signal_en(&self) -> bool {
        ((self.0 >> 19) & 1) != 0
    }
    #[inline(always)]
    pub fn ccc_unhandled_nack_signal_en(&self) -> bool {
        ((self.0 >> 18) & 1) != 0
    }
    #[inline(always)]
    pub fn ccc_param_modified_signal_en(&self) -> bool {
        ((self.0 >> 17) & 1) != 0
    }
    #[inline(always)]
    pub fn stby_cr_op_rstact_signal_en(&self) -> bool {
        ((self.0 >> 16) & 1) != 0
    }
    #[inline(always)]
    pub fn stby_cr_accept_err_signal_en(&self) -> bool {
        ((self.0 >> 14) & 1) != 0
    }
    #[inline(always)]
    pub fn stby_cr_accept_ok_signal_en(&self) -> bool {
        ((self.0 >> 13) & 1) != 0
    }
    #[inline(always)]
    pub fn stby_cr_accept_nacked_signal_en(&self) -> bool {
        ((self.0 >> 12) & 1) != 0
    }
    #[inline(always)]
    pub fn stby_cr_dyn_addr_signal_en(&self) -> bool {
        ((self.0 >> 11) & 1) != 0
    }
    #[inline(always)]
    pub fn crr_response_signal_en(&self) -> bool {
        ((self.0 >> 10) & 1) != 0
    }
    #[inline(always)]
    pub fn acr_handoff_err_m3_signal_en(&self) -> bool {
        ((self.0 >> 3) & 1) != 0
    }
    #[inline(always)]
    pub fn acr_handoff_err_fail_signal_en(&self) -> bool {
        ((self.0 >> 2) & 1) != 0
    }
    #[inline(always)]
    pub fn acr_handoff_ok_primed_signal_en(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    #[inline(always)]
    pub fn acr_handoff_ok_remain_signal_en(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> StbyCrIntrSignalEnableWriteVal {
        StbyCrIntrSignalEnableWriteVal(self.0)
    }
}
impl From<u32> for StbyCrIntrSignalEnableReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrIntrSignalEnableReadVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrIntrSignalEnableReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrIntrSignalEnableWriteVal(u32);
impl StbyCrIntrSignalEnableWriteVal {
    #[inline(always)]
    pub fn ccc_fatal_rstdaa_err_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 19)) | (u32::from(val) << 19))
    }
    #[inline(always)]
    pub fn ccc_unhandled_nack_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 18)) | (u32::from(val) << 18))
    }
    #[inline(always)]
    pub fn ccc_param_modified_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 17)) | (u32::from(val) << 17))
    }
    #[inline(always)]
    pub fn stby_cr_op_rstact_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 16)) | (u32::from(val) << 16))
    }
    #[inline(always)]
    pub fn stby_cr_accept_err_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
    }
    #[inline(always)]
    pub fn stby_cr_accept_ok_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
    }
    #[inline(always)]
    pub fn stby_cr_accept_nacked_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
    }
    #[inline(always)]
    pub fn stby_cr_dyn_addr_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
    }
    #[inline(always)]
    pub fn crr_response_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
    }
    #[inline(always)]
    pub fn acr_handoff_err_m3_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
    }
    #[inline(always)]
    pub fn acr_handoff_err_fail_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
    }
    #[inline(always)]
    pub fn acr_handoff_ok_primed_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
    #[inline(always)]
    pub fn acr_handoff_ok_remain_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for StbyCrIntrSignalEnableWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrIntrSignalEnableWriteVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrIntrSignalEnableWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrIntrForceReadVal(u32);
impl StbyCrIntrForceReadVal {
    #[inline(always)]
    pub fn ccc_fatal_rstdaa_err_force(&self) -> bool {
        ((self.0 >> 19) & 1) != 0
    }
    #[inline(always)]
    pub fn ccc_unhandled_nack_force(&self) -> bool {
        ((self.0 >> 18) & 1) != 0
    }
    #[inline(always)]
    pub fn ccc_param_modified_force(&self) -> bool {
        ((self.0 >> 17) & 1) != 0
    }
    #[inline(always)]
    pub fn stby_cr_op_rstact_force(&self) -> bool {
        ((self.0 >> 16) & 1) != 0
    }
    #[inline(always)]
    pub fn stby_cr_accept_err_force(&self) -> bool {
        ((self.0 >> 14) & 1) != 0
    }
    #[inline(always)]
    pub fn stby_cr_accept_ok_force(&self) -> bool {
        ((self.0 >> 13) & 1) != 0
    }
    #[inline(always)]
    pub fn stby_cr_accept_nacked_force(&self) -> bool {
        ((self.0 >> 12) & 1) != 0
    }
    #[inline(always)]
    pub fn stby_cr_dyn_addr_force(&self) -> bool {
        ((self.0 >> 11) & 1) != 0
    }
    #[inline(always)]
    pub fn crr_response_force(&self) -> bool {
        ((self.0 >> 10) & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> StbyCrIntrForceWriteVal {
        StbyCrIntrForceWriteVal(self.0)
    }
}
impl From<u32> for StbyCrIntrForceReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrIntrForceReadVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrIntrForceReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrIntrForceWriteVal(u32);
impl StbyCrIntrForceWriteVal {
    #[inline(always)]
    pub fn ccc_fatal_rstdaa_err_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 19)) | (u32::from(val) << 19))
    }
    #[inline(always)]
    pub fn ccc_unhandled_nack_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 18)) | (u32::from(val) << 18))
    }
    #[inline(always)]
    pub fn ccc_param_modified_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 17)) | (u32::from(val) << 17))
    }
    #[inline(always)]
    pub fn stby_cr_op_rstact_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 16)) | (u32::from(val) << 16))
    }
    #[inline(always)]
    pub fn stby_cr_accept_err_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
    }
    #[inline(always)]
    pub fn stby_cr_accept_ok_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
    }
    #[inline(always)]
    pub fn stby_cr_accept_nacked_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
    }
    #[inline(always)]
    pub fn stby_cr_dyn_addr_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
    }
    #[inline(always)]
    pub fn crr_response_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
    }
}
impl From<u32> for StbyCrIntrForceWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrIntrForceWriteVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrIntrForceWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrCccConfigGetcapsReadVal(u32);
impl StbyCrCccConfigGetcapsReadVal {
    #[inline(always)]
    pub fn f2_crcap2_dev_interact(&self) -> u32 {
        (self.0 >> 8) & 0xf
    }
    #[inline(always)]
    pub fn f2_crcap1_bus_config(&self) -> u32 {
        self.0 & 7
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> StbyCrCccConfigGetcapsWriteVal {
        StbyCrCccConfigGetcapsWriteVal(self.0)
    }
}
impl From<u32> for StbyCrCccConfigGetcapsReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrCccConfigGetcapsReadVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrCccConfigGetcapsReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrCccConfigGetcapsWriteVal(u32);
impl StbyCrCccConfigGetcapsWriteVal {
    #[inline(always)]
    pub fn f2_crcap2_dev_interact(self, val: u32) -> Self {
        Self((self.0 & !(0xf << 8)) | ((val & 0xf) << 8))
    }
    #[inline(always)]
    pub fn f2_crcap1_bus_config(self, val: u32) -> Self {
        Self((self.0 & !(7)) | (val & 7))
    }
}
impl From<u32> for StbyCrCccConfigGetcapsWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrCccConfigGetcapsWriteVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrCccConfigGetcapsWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrCccConfigRstactParamsReadVal(u32);
impl StbyCrCccConfigRstactParamsReadVal {
    #[inline(always)]
    pub fn reset_dynamic_addr(&self) -> bool {
        ((self.0 >> 31) & 1) != 0
    }
    #[inline(always)]
    pub fn reset_time_target(&self) -> u32 {
        (self.0 >> 16) & 0xff
    }
    #[inline(always)]
    pub fn reset_time_peripheral(&self) -> u32 {
        (self.0 >> 8) & 0xff
    }
    #[inline(always)]
    pub fn rst_action(&self) -> u32 {
        self.0 & 0xff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> StbyCrCccConfigRstactParamsWriteVal {
        StbyCrCccConfigRstactParamsWriteVal(self.0)
    }
}
impl From<u32> for StbyCrCccConfigRstactParamsReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrCccConfigRstactParamsReadVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrCccConfigRstactParamsReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrCccConfigRstactParamsWriteVal(u32);
impl StbyCrCccConfigRstactParamsWriteVal {
    #[inline(always)]
    pub fn reset_dynamic_addr(self, val: bool) -> Self {
        Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
    }
    #[inline(always)]
    pub fn reset_time_target(self, val: u32) -> Self {
        Self((self.0 & !(0xff << 16)) | ((val & 0xff) << 16))
    }
    #[inline(always)]
    pub fn reset_time_peripheral(self, val: u32) -> Self {
        Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
    }
    #[inline(always)]
    pub fn rst_action(self, val: u32) -> Self {
        Self((self.0 & !(0xff)) | (val & 0xff))
    }
}
impl From<u32> for StbyCrCccConfigRstactParamsWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrCccConfigRstactParamsWriteVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrCccConfigRstactParamsWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct InterruptStatusReadVal(u32);
impl InterruptStatusReadVal {
    /// Bus error occurred
    #[inline(always)]
    pub fn transfer_err_stat(&self) -> bool {
        ((self.0 >> 31) & 1) != 0
    }
    /// Bus aborted transaction
    #[inline(always)]
    pub fn transfer_abort_stat(&self) -> bool {
        ((self.0 >> 25) & 1) != 0
    }
    /// TTI IBI Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI IBI Queue is >= the value defined in `TTI_IBI_THLD`
    #[inline(always)]
    pub fn ibi_thld_stat(&self) -> bool {
        ((self.0 >> 12) & 1) != 0
    }
    /// TTI RX Descriptor Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI RX Descriptor Queue is >= the value defined in `TTI_RX_DESC_THLD`
    #[inline(always)]
    pub fn rx_desc_thld_stat(&self) -> bool {
        ((self.0 >> 11) & 1) != 0
    }
    /// TTI TX Descriptor Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI TX Descriptor Queue is >= the value defined in `TTI_TX_DESC_THLD`
    #[inline(always)]
    pub fn tx_desc_thld_stat(&self) -> bool {
        ((self.0 >> 10) & 1) != 0
    }
    /// TTI RX Data Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of entries in the TTI RX Data Queue is >= the value defined in `TTI_RX_DATA_THLD`
    #[inline(always)]
    pub fn rx_data_thld_stat(&self) -> bool {
        ((self.0 >> 9) & 1) != 0
    }
    /// TTI TX Data Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI TX Data Queue is >= the value defined in `TTI_TX_DATA_THLD`
    #[inline(always)]
    pub fn tx_data_thld_stat(&self) -> bool {
        ((self.0 >> 8) & 1) != 0
    }
    /// Pending Write was NACKed, because the `TX_DESC_STAT` event was not handled in time
    #[inline(always)]
    pub fn tx_desc_timeout(&self) -> bool {
        ((self.0 >> 3) & 1) != 0
    }
    /// Pending Read was NACKed, because the `RX_DESC_STAT` event was not handled in time
    #[inline(always)]
    pub fn rx_desc_timeout(&self) -> bool {
        ((self.0 >> 2) & 1) != 0
    }
    /// There is a pending Write Transaction on the I3C Bus. Software should write data to the TX Descriptor Queue and the TX Data Queue
    #[inline(always)]
    pub fn tx_desc_stat(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    /// There is a pending Read Transaction. Software should read data from the RX Descriptor Queue and the RX Data Queue
    #[inline(always)]
    pub fn rx_desc_stat(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> InterruptStatusWriteVal {
        InterruptStatusWriteVal(self.0)
    }
}
impl From<u32> for InterruptStatusReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<InterruptStatusReadVal> for u32 {
    #[inline(always)]
    fn from(val: InterruptStatusReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct InterruptStatusWriteVal(u32);
impl InterruptStatusWriteVal {
    /// Bus error occurred
    #[inline(always)]
    pub fn transfer_err_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
    }
    /// Bus aborted transaction
    #[inline(always)]
    pub fn transfer_abort_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 25)) | (u32::from(val) << 25))
    }
    /// TTI IBI Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI IBI Queue is >= the value defined in `TTI_IBI_THLD`
    #[inline(always)]
    pub fn ibi_thld_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
    }
    /// TTI RX Descriptor Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI RX Descriptor Queue is >= the value defined in `TTI_RX_DESC_THLD`
    #[inline(always)]
    pub fn rx_desc_thld_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
    }
    /// TTI TX Descriptor Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI TX Descriptor Queue is >= the value defined in `TTI_TX_DESC_THLD`
    #[inline(always)]
    pub fn tx_desc_thld_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
    }
    /// TTI RX Data Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of entries in the TTI RX Data Queue is >= the value defined in `TTI_RX_DATA_THLD`
    #[inline(always)]
    pub fn rx_data_thld_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
    }
    /// TTI TX Data Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI TX Data Queue is >= the value defined in `TTI_TX_DATA_THLD`
    #[inline(always)]
    pub fn tx_data_thld_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 8)) | (u32::from(val) << 8))
    }
    /// Pending Write was NACKed, because the `TX_DESC_STAT` event was not handled in time
    #[inline(always)]
    pub fn tx_desc_timeout(self, val: bool) -> Self {
        Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
    }
    /// Pending Read was NACKed, because the `RX_DESC_STAT` event was not handled in time
    #[inline(always)]
    pub fn rx_desc_timeout(self, val: bool) -> Self {
        Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
    }
    /// There is a pending Write Transaction on the I3C Bus. Software should write data to the TX Descriptor Queue and the TX Data Queue
    #[inline(always)]
    pub fn tx_desc_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
    /// There is a pending Read Transaction. Software should read data from the RX Descriptor Queue and the RX Data Queue
    #[inline(always)]
    pub fn rx_desc_stat(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for InterruptStatusWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<InterruptStatusWriteVal> for u32 {
    #[inline(always)]
    fn from(val: InterruptStatusWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct InterruptEnableReadVal(u32);
impl InterruptEnableReadVal {
    /// Enables the corresponding interrupt bit `TTI_IBI_THLD_STAT`
    #[inline(always)]
    pub fn ibi_thld_stat_en(&self) -> bool {
        ((self.0 >> 4) & 1) != 0
    }
    /// Enables the corresponding interrupt bit `TTI_RX_DESC_THLD_STAT`
    #[inline(always)]
    pub fn rx_desc_thld_stat_en(&self) -> bool {
        ((self.0 >> 3) & 1) != 0
    }
    /// Enables the corresponding interrupt bit `TTI_TX_DESC_THLD_STAT`
    #[inline(always)]
    pub fn tx_desc_thld_stat_en(&self) -> bool {
        ((self.0 >> 2) & 1) != 0
    }
    /// Enables the corresponding interrupt bit `TTI_RX_DATA_THLD_STAT`
    #[inline(always)]
    pub fn rx_data_thld_stat_en(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    /// Enables the corresponding interrupt bit `TTI_TX_DATA_THLD_STAT`
    #[inline(always)]
    pub fn tx_data_thld_stat_en(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> InterruptEnableWriteVal {
        InterruptEnableWriteVal(self.0)
    }
}
impl From<u32> for InterruptEnableReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<InterruptEnableReadVal> for u32 {
    #[inline(always)]
    fn from(val: InterruptEnableReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct InterruptEnableWriteVal(u32);
impl InterruptEnableWriteVal {
    /// Enables the corresponding interrupt bit `TTI_IBI_THLD_STAT`
    #[inline(always)]
    pub fn ibi_thld_stat_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
    }
    /// Enables the corresponding interrupt bit `TTI_RX_DESC_THLD_STAT`
    #[inline(always)]
    pub fn rx_desc_thld_stat_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
    }
    /// Enables the corresponding interrupt bit `TTI_TX_DESC_THLD_STAT`
    #[inline(always)]
    pub fn tx_desc_thld_stat_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
    }
    /// Enables the corresponding interrupt bit `TTI_RX_DATA_THLD_STAT`
    #[inline(always)]
    pub fn rx_data_thld_stat_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
    /// Enables the corresponding interrupt bit `TTI_TX_DATA_THLD_STAT`
    #[inline(always)]
    pub fn tx_data_thld_stat_en(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for InterruptEnableWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<InterruptEnableWriteVal> for u32 {
    #[inline(always)]
    fn from(val: InterruptEnableWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct InterruptForceReadVal(u32);
impl InterruptForceReadVal {
    /// Forces the corresponding interrupt bit `TTI_IBI_THLD_STAT` to be set to 1
    #[inline(always)]
    pub fn ibi_thld_force(&self) -> bool {
        ((self.0 >> 4) & 1) != 0
    }
    /// Forces the corresponding interrupt bit `TTI_RX_DESC_THLD_STAT` to be set to `1`
    #[inline(always)]
    pub fn rx_desc_thld_force(&self) -> bool {
        ((self.0 >> 3) & 1) != 0
    }
    /// Forces the corresponding interrupt bit `TTI_TX_DESC_THLD_STAT` to be set to `1`
    #[inline(always)]
    pub fn tx_desc_thld_force(&self) -> bool {
        ((self.0 >> 2) & 1) != 0
    }
    /// Forces the corresponding interrupt bit `TTI_RX_DATA_THLD_STAT` to be set to `1`
    #[inline(always)]
    pub fn rx_data_thld_force(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    /// Forces the corresponding interrupt bit `TTI_TX_DATA_THLD_STAT` to be set to `1`
    #[inline(always)]
    pub fn tx_data_thld_force(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> InterruptForceWriteVal {
        InterruptForceWriteVal(self.0)
    }
}
impl From<u32> for InterruptForceReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<InterruptForceReadVal> for u32 {
    #[inline(always)]
    fn from(val: InterruptForceReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct InterruptForceWriteVal(u32);
impl InterruptForceWriteVal {
    /// Forces the corresponding interrupt bit `TTI_IBI_THLD_STAT` to be set to 1
    #[inline(always)]
    pub fn ibi_thld_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
    }
    /// Forces the corresponding interrupt bit `TTI_RX_DESC_THLD_STAT` to be set to `1`
    #[inline(always)]
    pub fn rx_desc_thld_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
    }
    /// Forces the corresponding interrupt bit `TTI_TX_DESC_THLD_STAT` to be set to `1`
    #[inline(always)]
    pub fn tx_desc_thld_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
    }
    /// Forces the corresponding interrupt bit `TTI_RX_DATA_THLD_STAT` to be set to `1`
    #[inline(always)]
    pub fn rx_data_thld_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
    /// Forces the corresponding interrupt bit `TTI_TX_DATA_THLD_STAT` to be set to `1`
    #[inline(always)]
    pub fn tx_data_thld_force(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for InterruptForceWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<InterruptForceWriteVal> for u32 {
    #[inline(always)]
    fn from(val: InterruptForceWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IbiQueueSizeReadVal(u32);
impl IbiQueueSizeReadVal {
    /// IBI Queue Size in DWORDs calculated as `2^(N+1)`
    #[inline(always)]
    pub fn ibi_queue_size(&self) -> u32 {
        self.0 & 0xff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> IbiQueueSizeWriteVal {
        IbiQueueSizeWriteVal(self.0)
    }
}
impl From<u32> for IbiQueueSizeReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IbiQueueSizeReadVal> for u32 {
    #[inline(always)]
    fn from(val: IbiQueueSizeReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IbiQueueSizeWriteVal(u32);
impl IbiQueueSizeWriteVal {
    /// IBI Queue Size in DWORDs calculated as `2^(N+1)`
    #[inline(always)]
    pub fn ibi_queue_size(self, val: u32) -> Self {
        Self((self.0 & !(0xff)) | (val & 0xff))
    }
}
impl From<u32> for IbiQueueSizeWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IbiQueueSizeWriteVal> for u32 {
    #[inline(always)]
    fn from(val: IbiQueueSizeWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct SocPadConfReadVal(u32);
impl SocPadConfReadVal {
    /// Select pad type
    ///
    /// 0 - Bidirectional
    ///
    /// 1 - Open-drain
    ///
    /// 2 - Input-only
    ///
    /// 3 - Analog input
    #[inline(always)]
    pub fn pad_type(&self) -> u32 {
        (self.0 >> 24) & 0xff
    }
    /// Enable virtual open drain:
    ///
    /// 0 - disabled
    ///
    /// 1 - enabled
    #[inline(always)]
    pub fn virtual_od_en(&self) -> bool {
        ((self.0 >> 7) & 1) != 0
    }
    /// Enable Open-Drain:
    ///
    /// 0 - disabled
    ///
    /// 1 - enabled
    #[inline(always)]
    pub fn od_en(&self) -> bool {
        ((self.0 >> 6) & 1) != 0
    }
    /// Invert I/O signal:
    ///
    /// 0 - signals pass-through
    ///
    /// 1 - signals are inverted
    #[inline(always)]
    pub fn io_inversion(&self) -> bool {
        ((self.0 >> 5) & 1) != 0
    }
    /// Enable Pull:
    ///
    /// 0 - disabled
    ///
    /// 1 - enabled
    #[inline(always)]
    pub fn pull_en(&self) -> bool {
        ((self.0 >> 4) & 1) != 0
    }
    /// Direction of the pull:
    ///
    /// 0 - Pull down
    ///
    /// 1 - Pull up
    #[inline(always)]
    pub fn pull_dir(&self) -> bool {
        ((self.0 >> 3) & 1) != 0
    }
    /// Enable the High-Keeper:
    ///
    /// 0 - disabled
    ///
    /// 1 - enabled
    #[inline(always)]
    pub fn keeper_en(&self) -> bool {
        ((self.0 >> 2) & 1) != 0
    }
    /// Enable the Schmitt Trigger:
    ///
    /// 0 - disabled
    ///
    /// 1 - enabled
    #[inline(always)]
    pub fn schmitt_en(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    /// Enable input:
    ///
    /// 0 - enabled
    ///
    /// 1 - disabled
    #[inline(always)]
    pub fn input_enable(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> SocPadConfWriteVal {
        SocPadConfWriteVal(self.0)
    }
}
impl From<u32> for SocPadConfReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<SocPadConfReadVal> for u32 {
    #[inline(always)]
    fn from(val: SocPadConfReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct SocPadConfWriteVal(u32);
impl SocPadConfWriteVal {
    /// Select pad type
    ///
    /// 0 - Bidirectional
    ///
    /// 1 - Open-drain
    ///
    /// 2 - Input-only
    ///
    /// 3 - Analog input
    #[inline(always)]
    pub fn pad_type(self, val: u32) -> Self {
        Self((self.0 & !(0xff << 24)) | ((val & 0xff) << 24))
    }
    /// Enable virtual open drain:
    ///
    /// 0 - disabled
    ///
    /// 1 - enabled
    #[inline(always)]
    pub fn virtual_od_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 7)) | (u32::from(val) << 7))
    }
    /// Enable Open-Drain:
    ///
    /// 0 - disabled
    ///
    /// 1 - enabled
    #[inline(always)]
    pub fn od_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 6)) | (u32::from(val) << 6))
    }
    /// Invert I/O signal:
    ///
    /// 0 - signals pass-through
    ///
    /// 1 - signals are inverted
    #[inline(always)]
    pub fn io_inversion(self, val: bool) -> Self {
        Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
    }
    /// Enable Pull:
    ///
    /// 0 - disabled
    ///
    /// 1 - enabled
    #[inline(always)]
    pub fn pull_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
    }
    /// Direction of the pull:
    ///
    /// 0 - Pull down
    ///
    /// 1 - Pull up
    #[inline(always)]
    pub fn pull_dir(self, val: bool) -> Self {
        Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
    }
    /// Enable the High-Keeper:
    ///
    /// 0 - disabled
    ///
    /// 1 - enabled
    #[inline(always)]
    pub fn keeper_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
    }
    /// Enable the Schmitt Trigger:
    ///
    /// 0 - disabled
    ///
    /// 1 - enabled
    #[inline(always)]
    pub fn schmitt_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
    /// Enable input:
    ///
    /// 0 - enabled
    ///
    /// 1 - disabled
    #[inline(always)]
    pub fn input_enable(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for SocPadConfWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<SocPadConfWriteVal> for u32 {
    #[inline(always)]
    fn from(val: SocPadConfWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct SocPadAttrReadVal(u32);
impl SocPadAttrReadVal {
    /// Select driver strength
    ///
    /// '0 - lowest
    ///
    /// '1 - highest
    #[inline(always)]
    pub fn drive_strength(&self) -> u32 {
        (self.0 >> 24) & 0xff
    }
    /// Select driver slew rate
    ///
    /// '0 - lowest
    ///
    /// '1 - highest
    #[inline(always)]
    pub fn drive_slew_rate(&self) -> u32 {
        (self.0 >> 8) & 0xff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> SocPadAttrWriteVal {
        SocPadAttrWriteVal(self.0)
    }
}
impl From<u32> for SocPadAttrReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<SocPadAttrReadVal> for u32 {
    #[inline(always)]
    fn from(val: SocPadAttrReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct SocPadAttrWriteVal(u32);
impl SocPadAttrWriteVal {
    /// Select driver strength
    ///
    /// '0 - lowest
    ///
    /// '1 - highest
    #[inline(always)]
    pub fn drive_strength(self, val: u32) -> Self {
        Self((self.0 & !(0xff << 24)) | ((val & 0xff) << 24))
    }
    /// Select driver slew rate
    ///
    /// '0 - lowest
    ///
    /// '1 - highest
    #[inline(always)]
    pub fn drive_slew_rate(self, val: u32) -> Self {
        Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
    }
}
impl From<u32> for SocPadAttrWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<SocPadAttrWriteVal> for u32 {
    #[inline(always)]
    fn from(val: SocPadAttrWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TRRegReadVal(u32);
impl TRRegReadVal {
    /// Rise time of both SDA and SCL in clock units
    #[inline(always)]
    pub fn t_r(&self) -> u32 {
        self.0 & 0xfffff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> TRRegWriteVal {
        TRRegWriteVal(self.0)
    }
}
impl From<u32> for TRRegReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TRRegReadVal> for u32 {
    #[inline(always)]
    fn from(val: TRRegReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TRRegWriteVal(u32);
impl TRRegWriteVal {
    /// Rise time of both SDA and SCL in clock units
    #[inline(always)]
    pub fn t_r(self, val: u32) -> Self {
        Self((self.0 & !(0xfffff)) | (val & 0xfffff))
    }
}
impl From<u32> for TRRegWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TRRegWriteVal> for u32 {
    #[inline(always)]
    fn from(val: TRRegWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TFRegReadVal(u32);
impl TFRegReadVal {
    /// Fall time of both SDA and SCL in clock units
    #[inline(always)]
    pub fn t_f(&self) -> u32 {
        self.0 & 0xfffff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> TFRegWriteVal {
        TFRegWriteVal(self.0)
    }
}
impl From<u32> for TFRegReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TFRegReadVal> for u32 {
    #[inline(always)]
    fn from(val: TFRegReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TFRegWriteVal(u32);
impl TFRegWriteVal {
    /// Fall time of both SDA and SCL in clock units
    #[inline(always)]
    pub fn t_f(self, val: u32) -> Self {
        Self((self.0 & !(0xfffff)) | (val & 0xfffff))
    }
}
impl From<u32> for TFRegWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TFRegWriteVal> for u32 {
    #[inline(always)]
    fn from(val: TFRegWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TSuDatRegReadVal(u32);
impl TSuDatRegReadVal {
    /// Data setup time in clock units
    #[inline(always)]
    pub fn t_su_dat(&self) -> u32 {
        self.0 & 0xfffff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> TSuDatRegWriteVal {
        TSuDatRegWriteVal(self.0)
    }
}
impl From<u32> for TSuDatRegReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TSuDatRegReadVal> for u32 {
    #[inline(always)]
    fn from(val: TSuDatRegReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TSuDatRegWriteVal(u32);
impl TSuDatRegWriteVal {
    /// Data setup time in clock units
    #[inline(always)]
    pub fn t_su_dat(self, val: u32) -> Self {
        Self((self.0 & !(0xfffff)) | (val & 0xfffff))
    }
}
impl From<u32> for TSuDatRegWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TSuDatRegWriteVal> for u32 {
    #[inline(always)]
    fn from(val: TSuDatRegWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct THdDatRegReadVal(u32);
impl THdDatRegReadVal {
    /// Data hold time in clock units
    #[inline(always)]
    pub fn t_hd_dat(&self) -> u32 {
        self.0 & 0xfffff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> THdDatRegWriteVal {
        THdDatRegWriteVal(self.0)
    }
}
impl From<u32> for THdDatRegReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<THdDatRegReadVal> for u32 {
    #[inline(always)]
    fn from(val: THdDatRegReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct THdDatRegWriteVal(u32);
impl THdDatRegWriteVal {
    /// Data hold time in clock units
    #[inline(always)]
    pub fn t_hd_dat(self, val: u32) -> Self {
        Self((self.0 & !(0xfffff)) | (val & 0xfffff))
    }
}
impl From<u32> for THdDatRegWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<THdDatRegWriteVal> for u32 {
    #[inline(always)]
    fn from(val: THdDatRegWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct THighRegReadVal(u32);
impl THighRegReadVal {
    #[inline(always)]
    pub fn t_high(&self) -> u32 {
        self.0 & 0xfffff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> THighRegWriteVal {
        THighRegWriteVal(self.0)
    }
}
impl From<u32> for THighRegReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<THighRegReadVal> for u32 {
    #[inline(always)]
    fn from(val: THighRegReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct THighRegWriteVal(u32);
impl THighRegWriteVal {
    #[inline(always)]
    pub fn t_high(self, val: u32) -> Self {
        Self((self.0 & !(0xfffff)) | (val & 0xfffff))
    }
}
impl From<u32> for THighRegWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<THighRegWriteVal> for u32 {
    #[inline(always)]
    fn from(val: THighRegWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TLowRegReadVal(u32);
impl TLowRegReadVal {
    /// Low period of the SCL in clock units
    #[inline(always)]
    pub fn t_low(&self) -> u32 {
        self.0 & 0xfffff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> TLowRegWriteVal {
        TLowRegWriteVal(self.0)
    }
}
impl From<u32> for TLowRegReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TLowRegReadVal> for u32 {
    #[inline(always)]
    fn from(val: TLowRegReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TLowRegWriteVal(u32);
impl TLowRegWriteVal {
    /// Low period of the SCL in clock units
    #[inline(always)]
    pub fn t_low(self, val: u32) -> Self {
        Self((self.0 & !(0xfffff)) | (val & 0xfffff))
    }
}
impl From<u32> for TLowRegWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TLowRegWriteVal> for u32 {
    #[inline(always)]
    fn from(val: TLowRegWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct THdStaRegReadVal(u32);
impl THdStaRegReadVal {
    /// Hold time for (repeated) START in clock units
    #[inline(always)]
    pub fn t_hd_sta(&self) -> u32 {
        self.0 & 0xfffff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> THdStaRegWriteVal {
        THdStaRegWriteVal(self.0)
    }
}
impl From<u32> for THdStaRegReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<THdStaRegReadVal> for u32 {
    #[inline(always)]
    fn from(val: THdStaRegReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct THdStaRegWriteVal(u32);
impl THdStaRegWriteVal {
    /// Hold time for (repeated) START in clock units
    #[inline(always)]
    pub fn t_hd_sta(self, val: u32) -> Self {
        Self((self.0 & !(0xfffff)) | (val & 0xfffff))
    }
}
impl From<u32> for THdStaRegWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<THdStaRegWriteVal> for u32 {
    #[inline(always)]
    fn from(val: THdStaRegWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TSuStaRegReadVal(u32);
impl TSuStaRegReadVal {
    /// Setup time for repeated START in clock units
    #[inline(always)]
    pub fn t_su_sta(&self) -> u32 {
        self.0 & 0xfffff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> TSuStaRegWriteVal {
        TSuStaRegWriteVal(self.0)
    }
}
impl From<u32> for TSuStaRegReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TSuStaRegReadVal> for u32 {
    #[inline(always)]
    fn from(val: TSuStaRegReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TSuStaRegWriteVal(u32);
impl TSuStaRegWriteVal {
    /// Setup time for repeated START in clock units
    #[inline(always)]
    pub fn t_su_sta(self, val: u32) -> Self {
        Self((self.0 & !(0xfffff)) | (val & 0xfffff))
    }
}
impl From<u32> for TSuStaRegWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TSuStaRegWriteVal> for u32 {
    #[inline(always)]
    fn from(val: TSuStaRegWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TSuStoRegReadVal(u32);
impl TSuStoRegReadVal {
    /// Setup time for STOP in clock units
    #[inline(always)]
    pub fn t_su_sto(&self) -> u32 {
        self.0 & 0xfffff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> TSuStoRegWriteVal {
        TSuStoRegWriteVal(self.0)
    }
}
impl From<u32> for TSuStoRegReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TSuStoRegReadVal> for u32 {
    #[inline(always)]
    fn from(val: TSuStoRegReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TSuStoRegWriteVal(u32);
impl TSuStoRegWriteVal {
    /// Setup time for STOP in clock units
    #[inline(always)]
    pub fn t_su_sto(self, val: u32) -> Self {
        Self((self.0 & !(0xfffff)) | (val & 0xfffff))
    }
}
impl From<u32> for TSuStoRegWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TSuStoRegWriteVal> for u32 {
    #[inline(always)]
    fn from(val: TSuStoRegWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ControllerConfigReadVal(u32);
impl ControllerConfigReadVal {
    #[inline(always)]
    pub fn operation_mode(&self) -> u32 {
        (self.0 >> 4) & 3
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> ControllerConfigWriteVal {
        ControllerConfigWriteVal(self.0)
    }
}
impl From<u32> for ControllerConfigReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ControllerConfigReadVal> for u32 {
    #[inline(always)]
    fn from(val: ControllerConfigReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ControllerConfigWriteVal(u32);
impl ControllerConfigWriteVal {
    #[inline(always)]
    pub fn operation_mode(self, val: u32) -> Self {
        Self((self.0 & !(3 << 4)) | ((val & 3) << 4))
    }
}
impl From<u32> for ControllerConfigWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ControllerConfigWriteVal> for u32 {
    #[inline(always)]
    fn from(val: ControllerConfigWriteVal) -> u32 {
        val.0
    }
}
pub mod enums {
    //! Enumerations used by some register fields.
    pub mod selector {}
}
pub trait I3cPeripheral {
    fn poll(&mut self) {}
    fn warm_reset(&mut self) {}
    fn update_reset(&mut self) {}
    fn read_i3c_base_hci_version(&mut self) -> u32 {
        0
    }
    fn write_i3c_base_hci_version(&mut self, _val: u32) {}
    fn read_i3c_base_hc_control(&mut self) -> HcControlWriteVal {
        HcControlWriteVal::default()
    }
    fn write_i3c_base_hc_control(&mut self, _val: HcControlReadVal) {}
    fn read_i3c_base_controller_device_addr(&mut self) -> ControllerDeviceAddrWriteVal {
        ControllerDeviceAddrWriteVal::default()
    }
    fn write_i3c_base_controller_device_addr(&mut self, _val: ControllerDeviceAddrReadVal) {}
    fn read_i3c_base_hc_capabilities(&mut self) -> HcCapabilitiesWriteVal {
        HcCapabilitiesWriteVal::default()
    }
    fn write_i3c_base_hc_capabilities(&mut self, _val: HcCapabilitiesReadVal) {}
    fn read_i3c_base_reset_control(&mut self) -> ResetControlWriteVal {
        ResetControlWriteVal::default()
    }
    fn write_i3c_base_reset_control(&mut self, _val: ResetControlReadVal) {}
    fn read_i3c_base_present_state(&mut self) -> PresentStateWriteVal {
        PresentStateWriteVal::default()
    }
    fn write_i3c_base_present_state(&mut self, _val: PresentStateReadVal) {}
    fn read_i3c_base_intr_status(&mut self) -> IntrStatusWriteVal {
        IntrStatusWriteVal::default()
    }
    fn write_i3c_base_intr_status(&mut self, _val: IntrStatusReadVal) {}
    fn read_i3c_base_intr_status_enable(&mut self) -> IntrStatusEnableWriteVal {
        IntrStatusEnableWriteVal::default()
    }
    fn write_i3c_base_intr_status_enable(&mut self, _val: IntrStatusEnableReadVal) {}
    fn read_i3c_base_intr_signal_enable(&mut self) -> IntrSignalEnableWriteVal {
        IntrSignalEnableWriteVal::default()
    }
    fn write_i3c_base_intr_signal_enable(&mut self, _val: IntrSignalEnableReadVal) {}
    fn read_i3c_base_intr_force(&mut self) -> IntrForceWriteVal {
        IntrForceWriteVal::default()
    }
    fn write_i3c_base_intr_force(&mut self, _val: IntrForceReadVal) {}
    fn read_i3c_base_dat_section_offset(&mut self) -> DatSectionOffsetWriteVal {
        DatSectionOffsetWriteVal::default()
    }
    fn write_i3c_base_dat_section_offset(&mut self, _val: DatSectionOffsetReadVal) {}
    fn read_i3c_base_dct_section_offset(&mut self) -> DctSectionOffsetWriteVal {
        DctSectionOffsetWriteVal::default()
    }
    fn write_i3c_base_dct_section_offset(&mut self, _val: DctSectionOffsetReadVal) {}
    fn read_i3c_base_ring_headers_section_offset(&mut self) -> RingHeadersSectionOffsetWriteVal {
        RingHeadersSectionOffsetWriteVal::default()
    }
    fn write_i3c_base_ring_headers_section_offset(
        &mut self,
        _val: RingHeadersSectionOffsetReadVal,
    ) {
    }
    fn read_i3c_base_pio_section_offset(&mut self) -> PioSectionOffsetWriteVal {
        PioSectionOffsetWriteVal::default()
    }
    fn write_i3c_base_pio_section_offset(&mut self, _val: PioSectionOffsetReadVal) {}
    fn read_i3c_base_ext_caps_section_offset(&mut self) -> ExtCapsSectionOffsetWriteVal {
        ExtCapsSectionOffsetWriteVal::default()
    }
    fn write_i3c_base_ext_caps_section_offset(&mut self, _val: ExtCapsSectionOffsetReadVal) {}
    fn read_i3c_base_int_ctrl_cmds_en(&mut self) -> IntCtrlCmdsEnWriteVal {
        IntCtrlCmdsEnWriteVal::default()
    }
    fn write_i3c_base_int_ctrl_cmds_en(&mut self, _val: IntCtrlCmdsEnReadVal) {}
    fn read_i3c_base_ibi_notify_ctrl(&mut self) -> IbiNotifyCtrlWriteVal {
        IbiNotifyCtrlWriteVal::default()
    }
    fn write_i3c_base_ibi_notify_ctrl(&mut self, _val: IbiNotifyCtrlReadVal) {}
    fn read_i3c_base_ibi_data_abort_ctrl(&mut self) -> IbiDataAbortCtrlWriteVal {
        IbiDataAbortCtrlWriteVal::default()
    }
    fn write_i3c_base_ibi_data_abort_ctrl(&mut self, _val: IbiDataAbortCtrlReadVal) {}
    fn read_i3c_base_dev_ctx_base_lo(&mut self) -> DevCtxBaseLoWriteVal {
        DevCtxBaseLoWriteVal::default()
    }
    fn write_i3c_base_dev_ctx_base_lo(&mut self, _val: DevCtxBaseLoReadVal) {}
    fn read_i3c_base_dev_ctx_base_hi(&mut self) -> DevCtxBaseHiWriteVal {
        DevCtxBaseHiWriteVal::default()
    }
    fn write_i3c_base_dev_ctx_base_hi(&mut self, _val: DevCtxBaseHiReadVal) {}
    fn read_i3c_base_dev_ctx_sg(&mut self) -> DevCtxSgWriteVal {
        DevCtxSgWriteVal::default()
    }
    fn write_i3c_base_dev_ctx_sg(&mut self, _val: DevCtxSgReadVal) {}
    fn read_piocontrol_command_port(&mut self) -> u32 {
        0
    }
    fn write_piocontrol_command_port(&mut self, _val: u32) {}
    fn read_piocontrol_response_port(&mut self) -> u32 {
        0
    }
    fn write_piocontrol_response_port(&mut self, _val: u32) {}
    fn read_piocontrol_tx_data_port(&mut self) -> u32 {
        0
    }
    fn write_piocontrol_tx_data_port(&mut self, _val: u32) {}
    fn read_piocontrol_rx_data_port(&mut self) -> u32 {
        0
    }
    fn write_piocontrol_rx_data_port(&mut self, _val: u32) {}
    fn read_piocontrol_ibi_port(&mut self) -> IbiPortWriteVal {
        IbiPortWriteVal::default()
    }
    fn write_piocontrol_ibi_port(&mut self, _val: IbiPortReadVal) {}
    fn read_piocontrol_queue_thld_ctrl(&mut self) -> QueueThldCtrlWriteVal {
        QueueThldCtrlWriteVal::default()
    }
    fn write_piocontrol_queue_thld_ctrl(&mut self, _val: QueueThldCtrlReadVal) {}
    fn read_piocontrol_data_buffer_thld_ctrl(&mut self) -> DataBufferThldCtrlWriteVal {
        DataBufferThldCtrlWriteVal::default()
    }
    fn write_piocontrol_data_buffer_thld_ctrl(&mut self, _val: DataBufferThldCtrlReadVal) {}
    fn read_piocontrol_queue_size(&mut self) -> QueueSizeWriteVal {
        QueueSizeWriteVal::default()
    }
    fn write_piocontrol_queue_size(&mut self, _val: QueueSizeReadVal) {}
    fn read_piocontrol_alt_queue_size(&mut self) -> AltQueueSizeWriteVal {
        AltQueueSizeWriteVal::default()
    }
    fn write_piocontrol_alt_queue_size(&mut self, _val: AltQueueSizeReadVal) {}
    fn read_piocontrol_pio_intr_status(&mut self) -> PioIntrStatusWriteVal {
        PioIntrStatusWriteVal::default()
    }
    fn write_piocontrol_pio_intr_status(&mut self, _val: PioIntrStatusReadVal) {}
    fn read_piocontrol_pio_intr_status_enable(&mut self) -> PioIntrStatusEnableWriteVal {
        PioIntrStatusEnableWriteVal::default()
    }
    fn write_piocontrol_pio_intr_status_enable(&mut self, _val: PioIntrStatusEnableReadVal) {}
    fn read_piocontrol_pio_intr_signal_enable(&mut self) -> PioIntrSignalEnableWriteVal {
        PioIntrSignalEnableWriteVal::default()
    }
    fn write_piocontrol_pio_intr_signal_enable(&mut self, _val: PioIntrSignalEnableReadVal) {}
    fn read_piocontrol_pio_intr_force(&mut self) -> PioIntrForceWriteVal {
        PioIntrForceWriteVal::default()
    }
    fn write_piocontrol_pio_intr_force(&mut self, _val: PioIntrForceReadVal) {}
    fn read_piocontrol_pio_control(&mut self) -> PioControlWriteVal {
        PioControlWriteVal::default()
    }
    fn write_piocontrol_pio_control(&mut self, _val: PioControlReadVal) {}
    fn read_i3c_ec_sec_fw_recovery_if_extcap_header(&mut self) -> ExtcapHeaderO0WriteVal {
        ExtcapHeaderO0WriteVal::default()
    }
    fn write_i3c_ec_sec_fw_recovery_if_extcap_header(&mut self, _val: ExtcapHeaderO0ReadVal) {}
    fn read_i3c_ec_sec_fw_recovery_if_prot_cap_0(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_sec_fw_recovery_if_prot_cap_0(&mut self, _val: u32) {}
    fn read_i3c_ec_sec_fw_recovery_if_prot_cap_1(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_sec_fw_recovery_if_prot_cap_1(&mut self, _val: u32) {}
    fn read_i3c_ec_sec_fw_recovery_if_prot_cap_2(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_sec_fw_recovery_if_prot_cap_2(&mut self, _val: u32) {}
    fn read_i3c_ec_sec_fw_recovery_if_prot_cap_3(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_sec_fw_recovery_if_prot_cap_3(&mut self, _val: u32) {}
    fn read_i3c_ec_sec_fw_recovery_if_device_id_0(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_sec_fw_recovery_if_device_id_0(&mut self, _val: u32) {}
    fn read_i3c_ec_sec_fw_recovery_if_device_id_1(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_sec_fw_recovery_if_device_id_1(&mut self, _val: u32) {}
    fn read_i3c_ec_sec_fw_recovery_if_device_id_2(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_sec_fw_recovery_if_device_id_2(&mut self, _val: u32) {}
    fn read_i3c_ec_sec_fw_recovery_if_device_id_3(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_sec_fw_recovery_if_device_id_3(&mut self, _val: u32) {}
    fn read_i3c_ec_sec_fw_recovery_if_device_id_4(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_sec_fw_recovery_if_device_id_4(&mut self, _val: u32) {}
    fn read_i3c_ec_sec_fw_recovery_if_device_id_5(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_sec_fw_recovery_if_device_id_5(&mut self, _val: u32) {}
    fn read_i3c_ec_sec_fw_recovery_if_device_id_6(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_sec_fw_recovery_if_device_id_6(&mut self, _val: u32) {}
    fn read_i3c_ec_sec_fw_recovery_if_device_status_0(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_sec_fw_recovery_if_device_status_0(&mut self, _val: u32) {}
    fn read_i3c_ec_sec_fw_recovery_if_device_status_1(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_sec_fw_recovery_if_device_status_1(&mut self, _val: u32) {}
    fn read_i3c_ec_sec_fw_recovery_if_device_reset(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_sec_fw_recovery_if_device_reset(&mut self, _val: u32) {}
    fn read_i3c_ec_sec_fw_recovery_if_recovery_ctrl(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_sec_fw_recovery_if_recovery_ctrl(&mut self, _val: u32) {}
    fn read_i3c_ec_sec_fw_recovery_if_recovery_status(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_sec_fw_recovery_if_recovery_status(&mut self, _val: u32) {}
    fn read_i3c_ec_sec_fw_recovery_if_hw_status(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_sec_fw_recovery_if_hw_status(&mut self, _val: u32) {}
    fn read_i3c_ec_sec_fw_recovery_if_indirect_fifo_ctrl_0(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_sec_fw_recovery_if_indirect_fifo_ctrl_0(&mut self, _val: u32) {}
    fn read_i3c_ec_sec_fw_recovery_if_indirect_fifo_ctrl_1(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_sec_fw_recovery_if_indirect_fifo_ctrl_1(&mut self, _val: u32) {}
    fn read_i3c_ec_sec_fw_recovery_if_indirect_fifo_status_0(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_sec_fw_recovery_if_indirect_fifo_status_0(&mut self, _val: u32) {}
    fn read_i3c_ec_sec_fw_recovery_if_indirect_fifo_status_1(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_sec_fw_recovery_if_indirect_fifo_status_1(&mut self, _val: u32) {}
    fn read_i3c_ec_sec_fw_recovery_if_indirect_fifo_status_2(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_sec_fw_recovery_if_indirect_fifo_status_2(&mut self, _val: u32) {}
    fn read_i3c_ec_sec_fw_recovery_if_indirect_fifo_status_3(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_sec_fw_recovery_if_indirect_fifo_status_3(&mut self, _val: u32) {}
    fn read_i3c_ec_sec_fw_recovery_if_indirect_fifo_status_4(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_sec_fw_recovery_if_indirect_fifo_status_4(&mut self, _val: u32) {}
    fn read_i3c_ec_sec_fw_recovery_if_indirect_fifo_status_5(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_sec_fw_recovery_if_indirect_fifo_status_5(&mut self, _val: u32) {}
    fn read_i3c_ec_sec_fw_recovery_if_indirect_fifo_data(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_sec_fw_recovery_if_indirect_fifo_data(&mut self, _val: u32) {}
    fn read_i3c_ec_stdby_ctrl_mode_extcap_header(&mut self) -> ExtcapHeaderO0WriteVal {
        ExtcapHeaderO0WriteVal::default()
    }
    fn write_i3c_ec_stdby_ctrl_mode_extcap_header(&mut self, _val: ExtcapHeaderO0ReadVal) {}
    fn read_i3c_ec_stdby_ctrl_mode_stby_cr_control(&mut self) -> StbyCrControlO8WriteVal {
        StbyCrControlO8WriteVal::default()
    }
    fn write_i3c_ec_stdby_ctrl_mode_stby_cr_control(&mut self, _val: StbyCrControlO8ReadVal) {}
    fn read_i3c_ec_stdby_ctrl_mode_stby_cr_device_addr(&mut self) -> StbyCrDeviceAddrO16WriteVal {
        StbyCrDeviceAddrO16WriteVal::default()
    }
    fn write_i3c_ec_stdby_ctrl_mode_stby_cr_device_addr(
        &mut self,
        _val: StbyCrDeviceAddrO16ReadVal,
    ) {
    }
    fn read_i3c_ec_stdby_ctrl_mode_stby_cr_capabilities(
        &mut self,
    ) -> StbyCrCapabilitiesO24WriteVal {
        StbyCrCapabilitiesO24WriteVal::default()
    }
    fn write_i3c_ec_stdby_ctrl_mode_stby_cr_capabilities(
        &mut self,
        _val: StbyCrCapabilitiesO24ReadVal,
    ) {
    }
    fn read_i3c_ec_stdby_ctrl_mode_rsvd_0(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_stdby_ctrl_mode_rsvd_0(&mut self, _val: u32) {}
    fn read_i3c_ec_stdby_ctrl_mode_stby_cr_status(&mut self) -> StbyCrStatusO40WriteVal {
        StbyCrStatusO40WriteVal::default()
    }
    fn write_i3c_ec_stdby_ctrl_mode_stby_cr_status(&mut self, _val: StbyCrStatusO40ReadVal) {}
    fn read_i3c_ec_stdby_ctrl_mode_stby_cr_device_char(&mut self) -> StbyCrDeviceCharO48WriteVal {
        StbyCrDeviceCharO48WriteVal::default()
    }
    fn write_i3c_ec_stdby_ctrl_mode_stby_cr_device_char(
        &mut self,
        _val: StbyCrDeviceCharO48ReadVal,
    ) {
    }
    fn read_i3c_ec_stdby_ctrl_mode_stby_cr_device_pid_lo(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_stdby_ctrl_mode_stby_cr_device_pid_lo(&mut self, _val: u32) {}
    fn read_i3c_ec_stdby_ctrl_mode_stby_cr_intr_status(&mut self) -> StbyCrIntrStatusO64WriteVal {
        StbyCrIntrStatusO64WriteVal::default()
    }
    fn write_i3c_ec_stdby_ctrl_mode_stby_cr_intr_status(
        &mut self,
        _val: StbyCrIntrStatusO64ReadVal,
    ) {
    }
    fn read_i3c_ec_stdby_ctrl_mode_rsvd_1(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_stdby_ctrl_mode_rsvd_1(&mut self, _val: u32) {}
    fn read_i3c_ec_stdby_ctrl_mode_stby_cr_intr_signal_enable(
        &mut self,
    ) -> StbyCrIntrSignalEnableO80WriteVal {
        StbyCrIntrSignalEnableO80WriteVal::default()
    }
    fn write_i3c_ec_stdby_ctrl_mode_stby_cr_intr_signal_enable(
        &mut self,
        _val: StbyCrIntrSignalEnableO80ReadVal,
    ) {
    }
    fn read_i3c_ec_stdby_ctrl_mode_stby_cr_intr_force(&mut self) -> StbyCrIntrForceO88WriteVal {
        StbyCrIntrForceO88WriteVal::default()
    }
    fn write_i3c_ec_stdby_ctrl_mode_stby_cr_intr_force(&mut self, _val: StbyCrIntrForceO88ReadVal) {
    }
    fn read_i3c_ec_stdby_ctrl_mode_stby_cr_ccc_config_getcaps(
        &mut self,
    ) -> StbyCrCccConfigGetcapsO96WriteVal {
        StbyCrCccConfigGetcapsO96WriteVal::default()
    }
    fn write_i3c_ec_stdby_ctrl_mode_stby_cr_ccc_config_getcaps(
        &mut self,
        _val: StbyCrCccConfigGetcapsO96ReadVal,
    ) {
    }
    fn read_i3c_ec_stdby_ctrl_mode_stby_cr_ccc_config_rstact_params(
        &mut self,
    ) -> StbyCrCccConfigRstactParamsO104WriteVal {
        StbyCrCccConfigRstactParamsO104WriteVal::default()
    }
    fn write_i3c_ec_stdby_ctrl_mode_stby_cr_ccc_config_rstact_params(
        &mut self,
        _val: StbyCrCccConfigRstactParamsO104ReadVal,
    ) {
    }
    fn read_i3c_ec_stdby_ctrl_mode_rsvd_2(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_stdby_ctrl_mode_rsvd_2(&mut self, _val: u32) {}
    fn read_i3c_ec_stdby_ctrl_mode_rsvd_3(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_stdby_ctrl_mode_rsvd_3(&mut self, _val: u32) {}
    fn read_i3c_ec_tti_extcap_header(&mut self) -> ExtcapHeaderO0WriteVal {
        ExtcapHeaderO0WriteVal::default()
    }
    fn write_i3c_ec_tti_extcap_header(&mut self, _val: ExtcapHeaderO0ReadVal) {}
    fn read_i3c_ec_tti_control(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_tti_control(&mut self, _val: u32) {}
    fn read_i3c_ec_tti_status(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_tti_status(&mut self, _val: u32) {}
    fn read_i3c_ec_tti_reset_control(&mut self) -> ResetControlO24WriteVal {
        ResetControlO24WriteVal::default()
    }
    fn write_i3c_ec_tti_reset_control(&mut self, _val: ResetControlO24ReadVal) {}
    fn read_i3c_ec_tti_interrupt_status(&mut self) -> InterruptStatusO32WriteVal {
        InterruptStatusO32WriteVal::default()
    }
    fn write_i3c_ec_tti_interrupt_status(&mut self, _val: InterruptStatusO32ReadVal) {}
    fn read_i3c_ec_tti_interrupt_enable(&mut self) -> InterruptEnableO40WriteVal {
        InterruptEnableO40WriteVal::default()
    }
    fn write_i3c_ec_tti_interrupt_enable(&mut self, _val: InterruptEnableO40ReadVal) {}
    fn read_i3c_ec_tti_interrupt_force(&mut self) -> InterruptForceO48WriteVal {
        InterruptForceO48WriteVal::default()
    }
    fn write_i3c_ec_tti_interrupt_force(&mut self, _val: InterruptForceO48ReadVal) {}
    fn read_i3c_ec_tti_rx_desc_queue_port(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_tti_rx_desc_queue_port(&mut self, _val: u32) {}
    fn read_i3c_ec_tti_rx_data_port(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_tti_rx_data_port(&mut self, _val: u32) {}
    fn read_i3c_ec_tti_tx_desc_queue_port(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_tti_tx_desc_queue_port(&mut self, _val: u32) {}
    fn read_i3c_ec_tti_tx_data_port(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_tti_tx_data_port(&mut self, _val: u32) {}
    fn read_i3c_ec_tti_ibi_port(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_tti_ibi_port(&mut self, _val: u32) {}
    fn read_i3c_ec_tti_queue_size(&mut self) -> QueueSizeO96WriteVal {
        QueueSizeO96WriteVal::default()
    }
    fn write_i3c_ec_tti_queue_size(&mut self, _val: QueueSizeO96ReadVal) {}
    fn read_i3c_ec_tti_ibi_queue_size(&mut self) -> IbiQueueSizeO104WriteVal {
        IbiQueueSizeO104WriteVal::default()
    }
    fn write_i3c_ec_tti_ibi_queue_size(&mut self, _val: IbiQueueSizeO104ReadVal) {}
    fn read_i3c_ec_tti_queue_thld_ctrl(&mut self) -> QueueThldCtrlO112WriteVal {
        QueueThldCtrlO112WriteVal::default()
    }
    fn write_i3c_ec_tti_queue_thld_ctrl(&mut self, _val: QueueThldCtrlO112ReadVal) {}
    fn read_i3c_ec_tti_data_buffer_thld_ctrl(&mut self) -> DataBufferThldCtrlO120WriteVal {
        DataBufferThldCtrlO120WriteVal::default()
    }
    fn write_i3c_ec_tti_data_buffer_thld_ctrl(&mut self, _val: DataBufferThldCtrlO120ReadVal) {}
    fn read_i3c_ec_so_cmgmt_if_extcap_header(&mut self) -> ExtcapHeaderO0WriteVal {
        ExtcapHeaderO0WriteVal::default()
    }
    fn write_i3c_ec_so_cmgmt_if_extcap_header(&mut self, _val: ExtcapHeaderO0ReadVal) {}
    fn read_i3c_ec_so_cmgmt_if_soc_mgmt_control(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_so_cmgmt_if_soc_mgmt_control(&mut self, _val: u32) {}
    fn read_i3c_ec_so_cmgmt_if_soc_mgmt_status(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_so_cmgmt_if_soc_mgmt_status(&mut self, _val: u32) {}
    fn read_i3c_ec_so_cmgmt_if_soc_mgmt_rsvd_0(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_so_cmgmt_if_soc_mgmt_rsvd_0(&mut self, _val: u32) {}
    fn read_i3c_ec_so_cmgmt_if_soc_mgmt_rsvd_1(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_so_cmgmt_if_soc_mgmt_rsvd_1(&mut self, _val: u32) {}
    fn read_i3c_ec_so_cmgmt_if_soc_mgmt_rsvd_2(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_so_cmgmt_if_soc_mgmt_rsvd_2(&mut self, _val: u32) {}
    fn read_i3c_ec_so_cmgmt_if_soc_mgmt_rsvd_3(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_so_cmgmt_if_soc_mgmt_rsvd_3(&mut self, _val: u32) {}
    fn read_i3c_ec_so_cmgmt_if_soc_pad_conf(&mut self) -> SocPadConfO56WriteVal {
        SocPadConfO56WriteVal::default()
    }
    fn write_i3c_ec_so_cmgmt_if_soc_pad_conf(&mut self, _val: SocPadConfO56ReadVal) {}
    fn read_i3c_ec_so_cmgmt_if_soc_pad_attr(&mut self) -> SocPadAttrO64WriteVal {
        SocPadAttrO64WriteVal::default()
    }
    fn write_i3c_ec_so_cmgmt_if_soc_pad_attr(&mut self, _val: SocPadAttrO64ReadVal) {}
    fn read_i3c_ec_so_cmgmt_if_soc_mgmt_feature_2(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_so_cmgmt_if_soc_mgmt_feature_2(&mut self, _val: u32) {}
    fn read_i3c_ec_so_cmgmt_if_soc_mgmt_feature_3(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_so_cmgmt_if_soc_mgmt_feature_3(&mut self, _val: u32) {}
    fn read_i3c_ec_so_cmgmt_if_t_r_reg(&mut self) -> TRRegO88WriteVal {
        TRRegO88WriteVal::default()
    }
    fn write_i3c_ec_so_cmgmt_if_t_r_reg(&mut self, _val: TRRegO88ReadVal) {}
    fn read_i3c_ec_so_cmgmt_if_t_f_reg(&mut self) -> TFRegO96WriteVal {
        TFRegO96WriteVal::default()
    }
    fn write_i3c_ec_so_cmgmt_if_t_f_reg(&mut self, _val: TFRegO96ReadVal) {}
    fn read_i3c_ec_so_cmgmt_if_t_su_dat_reg(&mut self) -> TSuDatRegO104WriteVal {
        TSuDatRegO104WriteVal::default()
    }
    fn write_i3c_ec_so_cmgmt_if_t_su_dat_reg(&mut self, _val: TSuDatRegO104ReadVal) {}
    fn read_i3c_ec_so_cmgmt_if_t_hd_dat_reg(&mut self) -> THdDatRegO112WriteVal {
        THdDatRegO112WriteVal::default()
    }
    fn write_i3c_ec_so_cmgmt_if_t_hd_dat_reg(&mut self, _val: THdDatRegO112ReadVal) {}
    fn read_i3c_ec_so_cmgmt_if_t_high_reg(&mut self) -> THighRegO120WriteVal {
        THighRegO120WriteVal::default()
    }
    fn write_i3c_ec_so_cmgmt_if_t_high_reg(&mut self, _val: THighRegO120ReadVal) {}
    fn read_i3c_ec_so_cmgmt_if_t_low_reg(&mut self) -> TLowRegO128WriteVal {
        TLowRegO128WriteVal::default()
    }
    fn write_i3c_ec_so_cmgmt_if_t_low_reg(&mut self, _val: TLowRegO128ReadVal) {}
    fn read_i3c_ec_so_cmgmt_if_t_hd_sta_reg(&mut self) -> THdStaRegO136WriteVal {
        THdStaRegO136WriteVal::default()
    }
    fn write_i3c_ec_so_cmgmt_if_t_hd_sta_reg(&mut self, _val: THdStaRegO136ReadVal) {}
    fn read_i3c_ec_so_cmgmt_if_t_su_sta_reg(&mut self) -> TSuStaRegO144WriteVal {
        TSuStaRegO144WriteVal::default()
    }
    fn write_i3c_ec_so_cmgmt_if_t_su_sta_reg(&mut self, _val: TSuStaRegO144ReadVal) {}
    fn read_i3c_ec_so_cmgmt_if_t_su_sto_reg(&mut self) -> TSuStoRegO152WriteVal {
        TSuStoRegO152WriteVal::default()
    }
    fn write_i3c_ec_so_cmgmt_if_t_su_sto_reg(&mut self, _val: TSuStoRegO152ReadVal) {}
    fn read_i3c_ec_so_cmgmt_if_t_free_reg(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_so_cmgmt_if_t_free_reg(&mut self, _val: u32) {}
    fn read_i3c_ec_so_cmgmt_if_t_aval_reg(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_so_cmgmt_if_t_aval_reg(&mut self, _val: u32) {}
    fn read_i3c_ec_so_cmgmt_if_t_idle_reg(&mut self) -> u32 {
        0
    }
    fn write_i3c_ec_so_cmgmt_if_t_idle_reg(&mut self, _val: u32) {}
    fn read_i3c_ec_ctrl_cfg_extcap_header(&mut self) -> ExtcapHeaderO0WriteVal {
        ExtcapHeaderO0WriteVal::default()
    }
    fn write_i3c_ec_ctrl_cfg_extcap_header(&mut self, _val: ExtcapHeaderO0ReadVal) {}
    fn read_i3c_ec_ctrl_cfg_controller_config(&mut self) -> ControllerConfigO8WriteVal {
        ControllerConfigO8WriteVal::default()
    }
    fn write_i3c_ec_ctrl_cfg_controller_config(&mut self, _val: ControllerConfigO8ReadVal) {}
}
#[derive(Clone, Copy, Default)]
pub struct ExtcapHeaderO0ReadVal(u32);
impl ExtcapHeaderO0ReadVal {
    /// Capability Structure Length in DWORDs
    #[inline(always)]
    pub fn cap_length(&self) -> u32 {
        (self.0 >> 8) & 0xffff
    }
    /// Extended Capability ID
    #[inline(always)]
    pub fn cap_id(&self) -> u32 {
        self.0 & 0xff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> ExtcapHeaderO0WriteVal {
        ExtcapHeaderO0WriteVal(self.0)
    }
}
impl From<u32> for ExtcapHeaderO0ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ExtcapHeaderO0ReadVal> for u32 {
    #[inline(always)]
    fn from(val: ExtcapHeaderO0ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ExtcapHeaderO0WriteVal(u32);
impl ExtcapHeaderO0WriteVal {
    /// Capability Structure Length in DWORDs
    #[inline(always)]
    pub fn cap_length(self, val: u32) -> Self {
        Self((self.0 & !(0xffff << 8)) | ((val & 0xffff) << 8))
    }
    /// Extended Capability ID
    #[inline(always)]
    pub fn cap_id(self, val: u32) -> Self {
        Self((self.0 & !(0xff)) | (val & 0xff))
    }
}
impl From<u32> for ExtcapHeaderO0WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ExtcapHeaderO0WriteVal> for u32 {
    #[inline(always)]
    fn from(val: ExtcapHeaderO0WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ProtCap0O8ReadVal(u32);
impl ProtCap0O8ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> ProtCap0O8WriteVal {
        ProtCap0O8WriteVal(self.0)
    }
}
impl From<u32> for ProtCap0O8ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ProtCap0O8ReadVal> for u32 {
    #[inline(always)]
    fn from(val: ProtCap0O8ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ProtCap0O8WriteVal(u32);
impl ProtCap0O8WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for ProtCap0O8WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ProtCap0O8WriteVal> for u32 {
    #[inline(always)]
    fn from(val: ProtCap0O8WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ProtCap1O16ReadVal(u32);
impl ProtCap1O16ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> ProtCap1O16WriteVal {
        ProtCap1O16WriteVal(self.0)
    }
}
impl From<u32> for ProtCap1O16ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ProtCap1O16ReadVal> for u32 {
    #[inline(always)]
    fn from(val: ProtCap1O16ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ProtCap1O16WriteVal(u32);
impl ProtCap1O16WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for ProtCap1O16WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ProtCap1O16WriteVal> for u32 {
    #[inline(always)]
    fn from(val: ProtCap1O16WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ProtCap2O24ReadVal(u32);
impl ProtCap2O24ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> ProtCap2O24WriteVal {
        ProtCap2O24WriteVal(self.0)
    }
}
impl From<u32> for ProtCap2O24ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ProtCap2O24ReadVal> for u32 {
    #[inline(always)]
    fn from(val: ProtCap2O24ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ProtCap2O24WriteVal(u32);
impl ProtCap2O24WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for ProtCap2O24WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ProtCap2O24WriteVal> for u32 {
    #[inline(always)]
    fn from(val: ProtCap2O24WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ProtCap3O32ReadVal(u32);
impl ProtCap3O32ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> ProtCap3O32WriteVal {
        ProtCap3O32WriteVal(self.0)
    }
}
impl From<u32> for ProtCap3O32ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ProtCap3O32ReadVal> for u32 {
    #[inline(always)]
    fn from(val: ProtCap3O32ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ProtCap3O32WriteVal(u32);
impl ProtCap3O32WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for ProtCap3O32WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ProtCap3O32WriteVal> for u32 {
    #[inline(always)]
    fn from(val: ProtCap3O32WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DeviceId0O40ReadVal(u32);
impl DeviceId0O40ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> DeviceId0O40WriteVal {
        DeviceId0O40WriteVal(self.0)
    }
}
impl From<u32> for DeviceId0O40ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DeviceId0O40ReadVal> for u32 {
    #[inline(always)]
    fn from(val: DeviceId0O40ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DeviceId0O40WriteVal(u32);
impl DeviceId0O40WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for DeviceId0O40WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DeviceId0O40WriteVal> for u32 {
    #[inline(always)]
    fn from(val: DeviceId0O40WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DeviceId1O48ReadVal(u32);
impl DeviceId1O48ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> DeviceId1O48WriteVal {
        DeviceId1O48WriteVal(self.0)
    }
}
impl From<u32> for DeviceId1O48ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DeviceId1O48ReadVal> for u32 {
    #[inline(always)]
    fn from(val: DeviceId1O48ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DeviceId1O48WriteVal(u32);
impl DeviceId1O48WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for DeviceId1O48WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DeviceId1O48WriteVal> for u32 {
    #[inline(always)]
    fn from(val: DeviceId1O48WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DeviceId2O56ReadVal(u32);
impl DeviceId2O56ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> DeviceId2O56WriteVal {
        DeviceId2O56WriteVal(self.0)
    }
}
impl From<u32> for DeviceId2O56ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DeviceId2O56ReadVal> for u32 {
    #[inline(always)]
    fn from(val: DeviceId2O56ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DeviceId2O56WriteVal(u32);
impl DeviceId2O56WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for DeviceId2O56WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DeviceId2O56WriteVal> for u32 {
    #[inline(always)]
    fn from(val: DeviceId2O56WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DeviceId3O64ReadVal(u32);
impl DeviceId3O64ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> DeviceId3O64WriteVal {
        DeviceId3O64WriteVal(self.0)
    }
}
impl From<u32> for DeviceId3O64ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DeviceId3O64ReadVal> for u32 {
    #[inline(always)]
    fn from(val: DeviceId3O64ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DeviceId3O64WriteVal(u32);
impl DeviceId3O64WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for DeviceId3O64WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DeviceId3O64WriteVal> for u32 {
    #[inline(always)]
    fn from(val: DeviceId3O64WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DeviceId4O72ReadVal(u32);
impl DeviceId4O72ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> DeviceId4O72WriteVal {
        DeviceId4O72WriteVal(self.0)
    }
}
impl From<u32> for DeviceId4O72ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DeviceId4O72ReadVal> for u32 {
    #[inline(always)]
    fn from(val: DeviceId4O72ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DeviceId4O72WriteVal(u32);
impl DeviceId4O72WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for DeviceId4O72WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DeviceId4O72WriteVal> for u32 {
    #[inline(always)]
    fn from(val: DeviceId4O72WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DeviceId5O80ReadVal(u32);
impl DeviceId5O80ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> DeviceId5O80WriteVal {
        DeviceId5O80WriteVal(self.0)
    }
}
impl From<u32> for DeviceId5O80ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DeviceId5O80ReadVal> for u32 {
    #[inline(always)]
    fn from(val: DeviceId5O80ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DeviceId5O80WriteVal(u32);
impl DeviceId5O80WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for DeviceId5O80WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DeviceId5O80WriteVal> for u32 {
    #[inline(always)]
    fn from(val: DeviceId5O80WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DeviceId6O88ReadVal(u32);
impl DeviceId6O88ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> DeviceId6O88WriteVal {
        DeviceId6O88WriteVal(self.0)
    }
}
impl From<u32> for DeviceId6O88ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DeviceId6O88ReadVal> for u32 {
    #[inline(always)]
    fn from(val: DeviceId6O88ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DeviceId6O88WriteVal(u32);
impl DeviceId6O88WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for DeviceId6O88WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DeviceId6O88WriteVal> for u32 {
    #[inline(always)]
    fn from(val: DeviceId6O88WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DeviceStatus0O96ReadVal(u32);
impl DeviceStatus0O96ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> DeviceStatus0O96WriteVal {
        DeviceStatus0O96WriteVal(self.0)
    }
}
impl From<u32> for DeviceStatus0O96ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DeviceStatus0O96ReadVal> for u32 {
    #[inline(always)]
    fn from(val: DeviceStatus0O96ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DeviceStatus0O96WriteVal(u32);
impl DeviceStatus0O96WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for DeviceStatus0O96WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DeviceStatus0O96WriteVal> for u32 {
    #[inline(always)]
    fn from(val: DeviceStatus0O96WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DeviceStatus1O104ReadVal(u32);
impl DeviceStatus1O104ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> DeviceStatus1O104WriteVal {
        DeviceStatus1O104WriteVal(self.0)
    }
}
impl From<u32> for DeviceStatus1O104ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DeviceStatus1O104ReadVal> for u32 {
    #[inline(always)]
    fn from(val: DeviceStatus1O104ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DeviceStatus1O104WriteVal(u32);
impl DeviceStatus1O104WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for DeviceStatus1O104WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DeviceStatus1O104WriteVal> for u32 {
    #[inline(always)]
    fn from(val: DeviceStatus1O104WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DeviceResetO112ReadVal(u32);
impl DeviceResetO112ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> DeviceResetO112WriteVal {
        DeviceResetO112WriteVal(self.0)
    }
}
impl From<u32> for DeviceResetO112ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DeviceResetO112ReadVal> for u32 {
    #[inline(always)]
    fn from(val: DeviceResetO112ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DeviceResetO112WriteVal(u32);
impl DeviceResetO112WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for DeviceResetO112WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DeviceResetO112WriteVal> for u32 {
    #[inline(always)]
    fn from(val: DeviceResetO112WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct RecoveryCtrlO120ReadVal(u32);
impl RecoveryCtrlO120ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> RecoveryCtrlO120WriteVal {
        RecoveryCtrlO120WriteVal(self.0)
    }
}
impl From<u32> for RecoveryCtrlO120ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<RecoveryCtrlO120ReadVal> for u32 {
    #[inline(always)]
    fn from(val: RecoveryCtrlO120ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct RecoveryCtrlO120WriteVal(u32);
impl RecoveryCtrlO120WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for RecoveryCtrlO120WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<RecoveryCtrlO120WriteVal> for u32 {
    #[inline(always)]
    fn from(val: RecoveryCtrlO120WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct RecoveryStatusO128ReadVal(u32);
impl RecoveryStatusO128ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> RecoveryStatusO128WriteVal {
        RecoveryStatusO128WriteVal(self.0)
    }
}
impl From<u32> for RecoveryStatusO128ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<RecoveryStatusO128ReadVal> for u32 {
    #[inline(always)]
    fn from(val: RecoveryStatusO128ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct RecoveryStatusO128WriteVal(u32);
impl RecoveryStatusO128WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for RecoveryStatusO128WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<RecoveryStatusO128WriteVal> for u32 {
    #[inline(always)]
    fn from(val: RecoveryStatusO128WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct HwStatusO136ReadVal(u32);
impl HwStatusO136ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> HwStatusO136WriteVal {
        HwStatusO136WriteVal(self.0)
    }
}
impl From<u32> for HwStatusO136ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<HwStatusO136ReadVal> for u32 {
    #[inline(always)]
    fn from(val: HwStatusO136ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct HwStatusO136WriteVal(u32);
impl HwStatusO136WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for HwStatusO136WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<HwStatusO136WriteVal> for u32 {
    #[inline(always)]
    fn from(val: HwStatusO136WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IndirectFifoCtrl0O144ReadVal(u32);
impl IndirectFifoCtrl0O144ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> IndirectFifoCtrl0O144WriteVal {
        IndirectFifoCtrl0O144WriteVal(self.0)
    }
}
impl From<u32> for IndirectFifoCtrl0O144ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IndirectFifoCtrl0O144ReadVal> for u32 {
    #[inline(always)]
    fn from(val: IndirectFifoCtrl0O144ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IndirectFifoCtrl0O144WriteVal(u32);
impl IndirectFifoCtrl0O144WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for IndirectFifoCtrl0O144WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IndirectFifoCtrl0O144WriteVal> for u32 {
    #[inline(always)]
    fn from(val: IndirectFifoCtrl0O144WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IndirectFifoCtrl1O152ReadVal(u32);
impl IndirectFifoCtrl1O152ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> IndirectFifoCtrl1O152WriteVal {
        IndirectFifoCtrl1O152WriteVal(self.0)
    }
}
impl From<u32> for IndirectFifoCtrl1O152ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IndirectFifoCtrl1O152ReadVal> for u32 {
    #[inline(always)]
    fn from(val: IndirectFifoCtrl1O152ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IndirectFifoCtrl1O152WriteVal(u32);
impl IndirectFifoCtrl1O152WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for IndirectFifoCtrl1O152WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IndirectFifoCtrl1O152WriteVal> for u32 {
    #[inline(always)]
    fn from(val: IndirectFifoCtrl1O152WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IndirectFifoStatus0O160ReadVal(u32);
impl IndirectFifoStatus0O160ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> IndirectFifoStatus0O160WriteVal {
        IndirectFifoStatus0O160WriteVal(self.0)
    }
}
impl From<u32> for IndirectFifoStatus0O160ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IndirectFifoStatus0O160ReadVal> for u32 {
    #[inline(always)]
    fn from(val: IndirectFifoStatus0O160ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IndirectFifoStatus0O160WriteVal(u32);
impl IndirectFifoStatus0O160WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for IndirectFifoStatus0O160WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IndirectFifoStatus0O160WriteVal> for u32 {
    #[inline(always)]
    fn from(val: IndirectFifoStatus0O160WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IndirectFifoStatus1O168ReadVal(u32);
impl IndirectFifoStatus1O168ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> IndirectFifoStatus1O168WriteVal {
        IndirectFifoStatus1O168WriteVal(self.0)
    }
}
impl From<u32> for IndirectFifoStatus1O168ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IndirectFifoStatus1O168ReadVal> for u32 {
    #[inline(always)]
    fn from(val: IndirectFifoStatus1O168ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IndirectFifoStatus1O168WriteVal(u32);
impl IndirectFifoStatus1O168WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for IndirectFifoStatus1O168WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IndirectFifoStatus1O168WriteVal> for u32 {
    #[inline(always)]
    fn from(val: IndirectFifoStatus1O168WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IndirectFifoStatus2O176ReadVal(u32);
impl IndirectFifoStatus2O176ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> IndirectFifoStatus2O176WriteVal {
        IndirectFifoStatus2O176WriteVal(self.0)
    }
}
impl From<u32> for IndirectFifoStatus2O176ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IndirectFifoStatus2O176ReadVal> for u32 {
    #[inline(always)]
    fn from(val: IndirectFifoStatus2O176ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IndirectFifoStatus2O176WriteVal(u32);
impl IndirectFifoStatus2O176WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for IndirectFifoStatus2O176WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IndirectFifoStatus2O176WriteVal> for u32 {
    #[inline(always)]
    fn from(val: IndirectFifoStatus2O176WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IndirectFifoStatus3O184ReadVal(u32);
impl IndirectFifoStatus3O184ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> IndirectFifoStatus3O184WriteVal {
        IndirectFifoStatus3O184WriteVal(self.0)
    }
}
impl From<u32> for IndirectFifoStatus3O184ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IndirectFifoStatus3O184ReadVal> for u32 {
    #[inline(always)]
    fn from(val: IndirectFifoStatus3O184ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IndirectFifoStatus3O184WriteVal(u32);
impl IndirectFifoStatus3O184WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for IndirectFifoStatus3O184WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IndirectFifoStatus3O184WriteVal> for u32 {
    #[inline(always)]
    fn from(val: IndirectFifoStatus3O184WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IndirectFifoStatus4O192ReadVal(u32);
impl IndirectFifoStatus4O192ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> IndirectFifoStatus4O192WriteVal {
        IndirectFifoStatus4O192WriteVal(self.0)
    }
}
impl From<u32> for IndirectFifoStatus4O192ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IndirectFifoStatus4O192ReadVal> for u32 {
    #[inline(always)]
    fn from(val: IndirectFifoStatus4O192ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IndirectFifoStatus4O192WriteVal(u32);
impl IndirectFifoStatus4O192WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for IndirectFifoStatus4O192WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IndirectFifoStatus4O192WriteVal> for u32 {
    #[inline(always)]
    fn from(val: IndirectFifoStatus4O192WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IndirectFifoStatus5O200ReadVal(u32);
impl IndirectFifoStatus5O200ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> IndirectFifoStatus5O200WriteVal {
        IndirectFifoStatus5O200WriteVal(self.0)
    }
}
impl From<u32> for IndirectFifoStatus5O200ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IndirectFifoStatus5O200ReadVal> for u32 {
    #[inline(always)]
    fn from(val: IndirectFifoStatus5O200ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IndirectFifoStatus5O200WriteVal(u32);
impl IndirectFifoStatus5O200WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for IndirectFifoStatus5O200WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IndirectFifoStatus5O200WriteVal> for u32 {
    #[inline(always)]
    fn from(val: IndirectFifoStatus5O200WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IndirectFifoDataO208ReadVal(u32);
impl IndirectFifoDataO208ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> IndirectFifoDataO208WriteVal {
        IndirectFifoDataO208WriteVal(self.0)
    }
}
impl From<u32> for IndirectFifoDataO208ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IndirectFifoDataO208ReadVal> for u32 {
    #[inline(always)]
    fn from(val: IndirectFifoDataO208ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IndirectFifoDataO208WriteVal(u32);
impl IndirectFifoDataO208WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for IndirectFifoDataO208WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IndirectFifoDataO208WriteVal> for u32 {
    #[inline(always)]
    fn from(val: IndirectFifoDataO208WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrControlO8ReadVal(u32);
impl StbyCrControlO8ReadVal {
    /// Enables or disables the Secondary Controller:
    ///
    /// 2'b00 - DISABLED: Secondary Controller is disabled.
    ///
    /// 2'b01 - ACM_INIT: Secondary Controller is enabled,
    /// but Host Controller initializes in Active Controller mode.
    ///
    /// 2'b10 - SCM_RUNNING: Secondary Controller operation is enabled,
    /// Host Controller initializes in Standby Controller mode.
    ///
    /// 2'b11 - SCM_HOT_JOIN: Secondary Controller operation is enabled,
    /// Host Controller conditionally becomes a Hot-Joining Device
    /// to receive its Dynamic Address before operating in Standby Controller mode.
    #[inline(always)]
    pub fn stby_cr_enable_init(&self) -> u32 {
        (self.0 >> 30) & 3
    }
    /// Controls whether I3C Secondary Controller Logic supports RSTACT CCC with
    /// Defining Byte 0x02.
    ///
    /// 1'b0: NOT_SUPPORTED: Do not ACK Defining Byte 0x02
    ///
    /// 1'b1: HANDLE_INTR: Support Defining Byte 0x02
    #[inline(always)]
    pub fn rstact_defbyte_02(&self) -> bool {
        ((self.0 >> 20) & 1) != 0
    }
    /// Indicates ENTDAA method is enabled.
    ///
    /// 1'b0: DISABLED: will not respond
    ///
    /// 1'b1: ENABLED: will respond
    #[inline(always)]
    pub fn daa_entdaa_enable(&self) -> bool {
        ((self.0 >> 15) & 1) != 0
    }
    /// Indicates SETDASA method is enabled.
    ///
    /// 1'b0: DISABLED: will not respond
    ///
    /// 1'b1: ENABLED: will respond
    #[inline(always)]
    pub fn daa_setdasa_enable(&self) -> bool {
        ((self.0 >> 14) & 1) != 0
    }
    /// Indicates SETAASA method is enabled.
    ///
    /// 1'b0: DISABLED: will not respond
    ///
    /// 1'b1: ENABLED: will respond
    #[inline(always)]
    pub fn daa_setaasa_enable(&self) -> bool {
        ((self.0 >> 13) & 1) != 0
    }
    /// Indicates whether Read-Type/Write-Type transaction servicing is enabled, via
    /// an I3C Target Transaction Interface to software (Section 6.17.3).
    ///
    /// 1'b0: DISABLED: not available
    ///
    /// 1'b1: ENABLED: available for software
    #[inline(always)]
    pub fn target_xact_enable(&self) -> bool {
        ((self.0 >> 12) & 1) != 0
    }
    /// Indicates which Ring Bundle will be used to capture Broadcast CCC data sent by the Active Controller.
    /// The Ring Bundle must be configured and enabled, and its IBI Ring Pair must also be initialized and ready to receive data.
    #[inline(always)]
    pub fn bast_ccc_ibi_ring(&self) -> u32 {
        (self.0 >> 8) & 7
    }
    /// Write of 1'b1 to this field shall instruct the Secondary Controller Logic
    /// to attempt to send a Controller Role Request to the I3C Bus.
    #[inline(always)]
    pub fn cr_request_send(&self) -> bool {
        ((self.0 >> 5) & 1) != 0
    }
    /// If this field has a value of 1'b1, then the Secondary Controller Logic shall
    /// report a return from Deep Sleep state to the Active Controller.
    /// Writing 1'b1 to this bit is sticky. This field shall automatically clear to 1'b0
    /// after accepting the Controller Role and transitioning to Active Controller mode.
    #[inline(always)]
    pub fn handoff_deep_sleep(&self) -> bool {
        ((self.0 >> 4) & 1) != 0
    }
    #[inline(always)]
    pub fn prime_accept_getacccr(&self) -> bool {
        ((self.0 >> 3) & 1) != 0
    }
    #[inline(always)]
    pub fn acr_fsm_op_select(&self) -> bool {
        ((self.0 >> 2) & 1) != 0
    }
    #[inline(always)]
    pub fn handoff_delay_nack(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    #[inline(always)]
    pub fn pending_rx_nack(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> StbyCrControlO8WriteVal {
        StbyCrControlO8WriteVal(self.0)
    }
}
impl From<u32> for StbyCrControlO8ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrControlO8ReadVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrControlO8ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrControlO8WriteVal(u32);
impl StbyCrControlO8WriteVal {
    /// Enables or disables the Secondary Controller:
    ///
    /// 2'b00 - DISABLED: Secondary Controller is disabled.
    ///
    /// 2'b01 - ACM_INIT: Secondary Controller is enabled,
    /// but Host Controller initializes in Active Controller mode.
    ///
    /// 2'b10 - SCM_RUNNING: Secondary Controller operation is enabled,
    /// Host Controller initializes in Standby Controller mode.
    ///
    /// 2'b11 - SCM_HOT_JOIN: Secondary Controller operation is enabled,
    /// Host Controller conditionally becomes a Hot-Joining Device
    /// to receive its Dynamic Address before operating in Standby Controller mode.
    #[inline(always)]
    pub fn stby_cr_enable_init(self, val: u32) -> Self {
        Self((self.0 & !(3 << 30)) | ((val & 3) << 30))
    }
    /// Controls whether I3C Secondary Controller Logic supports RSTACT CCC with
    /// Defining Byte 0x02.
    ///
    /// 1'b0: NOT_SUPPORTED: Do not ACK Defining Byte 0x02
    ///
    /// 1'b1: HANDLE_INTR: Support Defining Byte 0x02
    #[inline(always)]
    pub fn rstact_defbyte_02(self, val: bool) -> Self {
        Self((self.0 & !(1 << 20)) | (u32::from(val) << 20))
    }
    /// Indicates ENTDAA method is enabled.
    ///
    /// 1'b0: DISABLED: will not respond
    ///
    /// 1'b1: ENABLED: will respond
    #[inline(always)]
    pub fn daa_entdaa_enable(self, val: bool) -> Self {
        Self((self.0 & !(1 << 15)) | (u32::from(val) << 15))
    }
    /// Indicates SETDASA method is enabled.
    ///
    /// 1'b0: DISABLED: will not respond
    ///
    /// 1'b1: ENABLED: will respond
    #[inline(always)]
    pub fn daa_setdasa_enable(self, val: bool) -> Self {
        Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
    }
    /// Indicates SETAASA method is enabled.
    ///
    /// 1'b0: DISABLED: will not respond
    ///
    /// 1'b1: ENABLED: will respond
    #[inline(always)]
    pub fn daa_setaasa_enable(self, val: bool) -> Self {
        Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
    }
    /// Indicates whether Read-Type/Write-Type transaction servicing is enabled, via
    /// an I3C Target Transaction Interface to software (Section 6.17.3).
    ///
    /// 1'b0: DISABLED: not available
    ///
    /// 1'b1: ENABLED: available for software
    #[inline(always)]
    pub fn target_xact_enable(self, val: bool) -> Self {
        Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
    }
    /// Indicates which Ring Bundle will be used to capture Broadcast CCC data sent by the Active Controller.
    /// The Ring Bundle must be configured and enabled, and its IBI Ring Pair must also be initialized and ready to receive data.
    #[inline(always)]
    pub fn bast_ccc_ibi_ring(self, val: u32) -> Self {
        Self((self.0 & !(7 << 8)) | ((val & 7) << 8))
    }
    /// Write of 1'b1 to this field shall instruct the Secondary Controller Logic
    /// to attempt to send a Controller Role Request to the I3C Bus.
    #[inline(always)]
    pub fn cr_request_send(self, val: bool) -> Self {
        Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
    }
    /// If this field has a value of 1'b1, then the Secondary Controller Logic shall
    /// report a return from Deep Sleep state to the Active Controller.
    /// Writing 1'b1 to this bit is sticky. This field shall automatically clear to 1'b0
    /// after accepting the Controller Role and transitioning to Active Controller mode.
    #[inline(always)]
    pub fn handoff_deep_sleep(self, val: bool) -> Self {
        Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
    }
    #[inline(always)]
    pub fn prime_accept_getacccr(self, val: bool) -> Self {
        Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
    }
    #[inline(always)]
    pub fn acr_fsm_op_select(self, val: bool) -> Self {
        Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
    }
    #[inline(always)]
    pub fn handoff_delay_nack(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
    #[inline(always)]
    pub fn pending_rx_nack(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for StbyCrControlO8WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrControlO8WriteVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrControlO8WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrDeviceAddrO16ReadVal(u32);
impl StbyCrDeviceAddrO16ReadVal {
    /// Indicates whether or not the value in the DYNAMIC_ADDR field is valid.
    /// 1'b0: DYNAMIC_ADDR field is not valid
    /// 1'b1: DYNAMIC_ADDR field is valid
    #[inline(always)]
    pub fn dynamic_addr_valid(&self) -> bool {
        ((self.0 >> 31) & 1) != 0
    }
    /// Contains the Host Controller Devices Dynamic Address.
    #[inline(always)]
    pub fn dynamic_addr(&self) -> u32 {
        (self.0 >> 16) & 0x7f
    }
    /// Indicates whether or not the value in the STATIC_ADDR field is valid.
    ///
    /// 1'b0: The Static Address field is not valid
    ///
    /// 1'b1: The Static Address field is valid
    #[inline(always)]
    pub fn static_addr_valid(&self) -> bool {
        ((self.0 >> 15) & 1) != 0
    }
    /// This field contains the Host Controller Devices Static Address.
    #[inline(always)]
    pub fn static_addr(&self) -> u32 {
        self.0 & 0x7f
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> StbyCrDeviceAddrO16WriteVal {
        StbyCrDeviceAddrO16WriteVal(self.0)
    }
}
impl From<u32> for StbyCrDeviceAddrO16ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrDeviceAddrO16ReadVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrDeviceAddrO16ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrDeviceAddrO16WriteVal(u32);
impl StbyCrDeviceAddrO16WriteVal {
    /// Indicates whether or not the value in the DYNAMIC_ADDR field is valid.
    /// 1'b0: DYNAMIC_ADDR field is not valid
    /// 1'b1: DYNAMIC_ADDR field is valid
    #[inline(always)]
    pub fn dynamic_addr_valid(self, val: bool) -> Self {
        Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
    }
    /// Contains the Host Controller Devices Dynamic Address.
    #[inline(always)]
    pub fn dynamic_addr(self, val: u32) -> Self {
        Self((self.0 & !(0x7f << 16)) | ((val & 0x7f) << 16))
    }
    /// Indicates whether or not the value in the STATIC_ADDR field is valid.
    ///
    /// 1'b0: The Static Address field is not valid
    ///
    /// 1'b1: The Static Address field is valid
    #[inline(always)]
    pub fn static_addr_valid(self, val: bool) -> Self {
        Self((self.0 & !(1 << 15)) | (u32::from(val) << 15))
    }
    /// This field contains the Host Controller Devices Static Address.
    #[inline(always)]
    pub fn static_addr(self, val: u32) -> Self {
        Self((self.0 & !(0x7f)) | (val & 0x7f))
    }
}
impl From<u32> for StbyCrDeviceAddrO16WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrDeviceAddrO16WriteVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrDeviceAddrO16WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrCapabilitiesO24ReadVal(u32);
impl StbyCrCapabilitiesO24ReadVal {
    /// Defines whether Dynamic Address Assignment with ENTDAA CCC is supported.
    ///
    /// 1'b0: DISABLED: Not supported
    ///
    /// 1'b1: ENABLED: Supported
    #[inline(always)]
    pub fn daa_entdaa_support(&self) -> bool {
        ((self.0 >> 15) & 1) != 0
    }
    /// Defines whether Dynamic Address Assignment with SETDASA CCC (using Static Address) is supported.
    ///
    /// 1'b0: DISABLED: Not supported
    ///
    /// 1'b1: ENABLED: Supported
    #[inline(always)]
    pub fn daa_setdasa_support(&self) -> bool {
        ((self.0 >> 14) & 1) != 0
    }
    /// Defines whether Dynamic Address Assignment with SETAASA CCC (using Static Address) is supported.
    ///
    /// 1'b0: DISABLED: Not supported
    ///
    /// 1'b1: ENABLED: Supported
    #[inline(always)]
    pub fn daa_setaasa_support(&self) -> bool {
        ((self.0 >> 13) & 1) != 0
    }
    /// Defines whether an I3C Target Transaction Interface is supported.
    ///
    /// 1'b0: DISABLED: Not supported
    ///
    /// 1'b1: ENABLED: Supported via vendor-defined Extended Capability structure
    #[inline(always)]
    pub fn target_xact_support(&self) -> bool {
        ((self.0 >> 12) & 1) != 0
    }
    #[inline(always)]
    pub fn simple_crr_support(&self) -> bool {
        ((self.0 >> 5) & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> StbyCrCapabilitiesO24WriteVal {
        StbyCrCapabilitiesO24WriteVal(self.0)
    }
}
impl From<u32> for StbyCrCapabilitiesO24ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrCapabilitiesO24ReadVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrCapabilitiesO24ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrCapabilitiesO24WriteVal(u32);
impl StbyCrCapabilitiesO24WriteVal {
    /// Defines whether Dynamic Address Assignment with ENTDAA CCC is supported.
    ///
    /// 1'b0: DISABLED: Not supported
    ///
    /// 1'b1: ENABLED: Supported
    #[inline(always)]
    pub fn daa_entdaa_support(self, val: bool) -> Self {
        Self((self.0 & !(1 << 15)) | (u32::from(val) << 15))
    }
    /// Defines whether Dynamic Address Assignment with SETDASA CCC (using Static Address) is supported.
    ///
    /// 1'b0: DISABLED: Not supported
    ///
    /// 1'b1: ENABLED: Supported
    #[inline(always)]
    pub fn daa_setdasa_support(self, val: bool) -> Self {
        Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
    }
    /// Defines whether Dynamic Address Assignment with SETAASA CCC (using Static Address) is supported.
    ///
    /// 1'b0: DISABLED: Not supported
    ///
    /// 1'b1: ENABLED: Supported
    #[inline(always)]
    pub fn daa_setaasa_support(self, val: bool) -> Self {
        Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
    }
    /// Defines whether an I3C Target Transaction Interface is supported.
    ///
    /// 1'b0: DISABLED: Not supported
    ///
    /// 1'b1: ENABLED: Supported via vendor-defined Extended Capability structure
    #[inline(always)]
    pub fn target_xact_support(self, val: bool) -> Self {
        Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
    }
    #[inline(always)]
    pub fn simple_crr_support(self, val: bool) -> Self {
        Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
    }
}
impl From<u32> for StbyCrCapabilitiesO24WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrCapabilitiesO24WriteVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrCapabilitiesO24WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct Rsvd0O32ReadVal(u32);
impl Rsvd0O32ReadVal {
    #[inline(always)]
    pub fn _rsvd(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> Rsvd0O32WriteVal {
        Rsvd0O32WriteVal(self.0)
    }
}
impl From<u32> for Rsvd0O32ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<Rsvd0O32ReadVal> for u32 {
    #[inline(always)]
    fn from(val: Rsvd0O32ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct Rsvd0O32WriteVal(u32);
impl Rsvd0O32WriteVal {
    #[inline(always)]
    pub fn _rsvd(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for Rsvd0O32WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<Rsvd0O32WriteVal> for u32 {
    #[inline(always)]
    fn from(val: Rsvd0O32WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrStatusO40ReadVal(u32);
impl StbyCrStatusO40ReadVal {
    #[inline(always)]
    pub fn hj_req_status(&self) -> bool {
        ((self.0 >> 8) & 1) != 0
    }
    #[inline(always)]
    pub fn simple_crr_status(&self) -> u32 {
        (self.0 >> 5) & 7
    }
    #[inline(always)]
    pub fn ac_current_own(&self) -> bool {
        ((self.0 >> 2) & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> StbyCrStatusO40WriteVal {
        StbyCrStatusO40WriteVal(self.0)
    }
}
impl From<u32> for StbyCrStatusO40ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrStatusO40ReadVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrStatusO40ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrStatusO40WriteVal(u32);
impl StbyCrStatusO40WriteVal {
    #[inline(always)]
    pub fn hj_req_status(self, val: bool) -> Self {
        Self((self.0 & !(1 << 8)) | (u32::from(val) << 8))
    }
    #[inline(always)]
    pub fn simple_crr_status(self, val: u32) -> Self {
        Self((self.0 & !(7 << 5)) | ((val & 7) << 5))
    }
    #[inline(always)]
    pub fn ac_current_own(self, val: bool) -> Self {
        Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
    }
}
impl From<u32> for StbyCrStatusO40WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrStatusO40WriteVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrStatusO40WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrDeviceCharO48ReadVal(u32);
impl StbyCrDeviceCharO48ReadVal {
    #[inline(always)]
    pub fn bcr_fixed(&self) -> u32 {
        (self.0 >> 29) & 7
    }
    #[inline(always)]
    pub fn bcr_var(&self) -> u32 {
        (self.0 >> 24) & 0x1f
    }
    #[inline(always)]
    pub fn dcr(&self) -> u32 {
        (self.0 >> 16) & 0xff
    }
    #[inline(always)]
    pub fn pid_hi(&self) -> u32 {
        (self.0 >> 1) & 0x7fff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> StbyCrDeviceCharO48WriteVal {
        StbyCrDeviceCharO48WriteVal(self.0)
    }
}
impl From<u32> for StbyCrDeviceCharO48ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrDeviceCharO48ReadVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrDeviceCharO48ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrDeviceCharO48WriteVal(u32);
impl StbyCrDeviceCharO48WriteVal {
    #[inline(always)]
    pub fn bcr_fixed(self, val: u32) -> Self {
        Self((self.0 & !(7 << 29)) | ((val & 7) << 29))
    }
    #[inline(always)]
    pub fn bcr_var(self, val: u32) -> Self {
        Self((self.0 & !(0x1f << 24)) | ((val & 0x1f) << 24))
    }
    #[inline(always)]
    pub fn dcr(self, val: u32) -> Self {
        Self((self.0 & !(0xff << 16)) | ((val & 0xff) << 16))
    }
    #[inline(always)]
    pub fn pid_hi(self, val: u32) -> Self {
        Self((self.0 & !(0x7fff << 1)) | ((val & 0x7fff) << 1))
    }
}
impl From<u32> for StbyCrDeviceCharO48WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrDeviceCharO48WriteVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrDeviceCharO48WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrDevicePidLoO56ReadVal(u32);
impl StbyCrDevicePidLoO56ReadVal {
    #[inline(always)]
    pub fn pid_lo(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> StbyCrDevicePidLoO56WriteVal {
        StbyCrDevicePidLoO56WriteVal(self.0)
    }
}
impl From<u32> for StbyCrDevicePidLoO56ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrDevicePidLoO56ReadVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrDevicePidLoO56ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrDevicePidLoO56WriteVal(u32);
impl StbyCrDevicePidLoO56WriteVal {
    #[inline(always)]
    pub fn pid_lo(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for StbyCrDevicePidLoO56WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrDevicePidLoO56WriteVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrDevicePidLoO56WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrIntrStatusO64ReadVal(u32);
impl StbyCrIntrStatusO64ReadVal {
    #[inline(always)]
    pub fn ccc_fatal_rstdaa_err_stat(&self) -> bool {
        ((self.0 >> 19) & 1) != 0
    }
    #[inline(always)]
    pub fn ccc_unhandled_nack_stat(&self) -> bool {
        ((self.0 >> 18) & 1) != 0
    }
    #[inline(always)]
    pub fn ccc_param_modified_stat(&self) -> bool {
        ((self.0 >> 17) & 1) != 0
    }
    #[inline(always)]
    pub fn stby_cr_op_rstact_stat(&self) -> bool {
        ((self.0 >> 16) & 1) != 0
    }
    #[inline(always)]
    pub fn stby_cr_accept_err_stat(&self) -> bool {
        ((self.0 >> 14) & 1) != 0
    }
    #[inline(always)]
    pub fn stby_cr_accept_ok_stat(&self) -> bool {
        ((self.0 >> 13) & 1) != 0
    }
    #[inline(always)]
    pub fn stby_cr_accept_nacked_stat(&self) -> bool {
        ((self.0 >> 12) & 1) != 0
    }
    #[inline(always)]
    pub fn stby_cr_dyn_addr_stat(&self) -> bool {
        ((self.0 >> 11) & 1) != 0
    }
    #[inline(always)]
    pub fn crr_response_stat(&self) -> bool {
        ((self.0 >> 10) & 1) != 0
    }
    #[inline(always)]
    pub fn acr_handoff_err_m3_stat(&self) -> bool {
        ((self.0 >> 3) & 1) != 0
    }
    #[inline(always)]
    pub fn acr_handoff_err_fail_stat(&self) -> bool {
        ((self.0 >> 2) & 1) != 0
    }
    #[inline(always)]
    pub fn acr_handoff_ok_primed_stat(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    #[inline(always)]
    pub fn acr_handoff_ok_remain_stat(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> StbyCrIntrStatusO64WriteVal {
        StbyCrIntrStatusO64WriteVal(self.0)
    }
}
impl From<u32> for StbyCrIntrStatusO64ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrIntrStatusO64ReadVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrIntrStatusO64ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrIntrStatusO64WriteVal(u32);
impl StbyCrIntrStatusO64WriteVal {
    #[inline(always)]
    pub fn ccc_fatal_rstdaa_err_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 19)) | (u32::from(val) << 19))
    }
    #[inline(always)]
    pub fn ccc_unhandled_nack_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 18)) | (u32::from(val) << 18))
    }
    #[inline(always)]
    pub fn ccc_param_modified_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 17)) | (u32::from(val) << 17))
    }
    #[inline(always)]
    pub fn stby_cr_op_rstact_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 16)) | (u32::from(val) << 16))
    }
    #[inline(always)]
    pub fn stby_cr_accept_err_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
    }
    #[inline(always)]
    pub fn stby_cr_accept_ok_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
    }
    #[inline(always)]
    pub fn stby_cr_accept_nacked_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
    }
    #[inline(always)]
    pub fn stby_cr_dyn_addr_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
    }
    #[inline(always)]
    pub fn crr_response_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
    }
    #[inline(always)]
    pub fn acr_handoff_err_m3_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
    }
    #[inline(always)]
    pub fn acr_handoff_err_fail_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
    }
    #[inline(always)]
    pub fn acr_handoff_ok_primed_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
    #[inline(always)]
    pub fn acr_handoff_ok_remain_stat(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for StbyCrIntrStatusO64WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrIntrStatusO64WriteVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrIntrStatusO64WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct Rsvd1O72ReadVal(u32);
impl Rsvd1O72ReadVal {
    #[inline(always)]
    pub fn _rsvd(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> Rsvd1O72WriteVal {
        Rsvd1O72WriteVal(self.0)
    }
}
impl From<u32> for Rsvd1O72ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<Rsvd1O72ReadVal> for u32 {
    #[inline(always)]
    fn from(val: Rsvd1O72ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct Rsvd1O72WriteVal(u32);
impl Rsvd1O72WriteVal {
    #[inline(always)]
    pub fn _rsvd(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for Rsvd1O72WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<Rsvd1O72WriteVal> for u32 {
    #[inline(always)]
    fn from(val: Rsvd1O72WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrIntrSignalEnableO80ReadVal(u32);
impl StbyCrIntrSignalEnableO80ReadVal {
    #[inline(always)]
    pub fn ccc_fatal_rstdaa_err_signal_en(&self) -> bool {
        ((self.0 >> 19) & 1) != 0
    }
    #[inline(always)]
    pub fn ccc_unhandled_nack_signal_en(&self) -> bool {
        ((self.0 >> 18) & 1) != 0
    }
    #[inline(always)]
    pub fn ccc_param_modified_signal_en(&self) -> bool {
        ((self.0 >> 17) & 1) != 0
    }
    #[inline(always)]
    pub fn stby_cr_op_rstact_signal_en(&self) -> bool {
        ((self.0 >> 16) & 1) != 0
    }
    #[inline(always)]
    pub fn stby_cr_accept_err_signal_en(&self) -> bool {
        ((self.0 >> 14) & 1) != 0
    }
    #[inline(always)]
    pub fn stby_cr_accept_ok_signal_en(&self) -> bool {
        ((self.0 >> 13) & 1) != 0
    }
    #[inline(always)]
    pub fn stby_cr_accept_nacked_signal_en(&self) -> bool {
        ((self.0 >> 12) & 1) != 0
    }
    #[inline(always)]
    pub fn stby_cr_dyn_addr_signal_en(&self) -> bool {
        ((self.0 >> 11) & 1) != 0
    }
    #[inline(always)]
    pub fn crr_response_signal_en(&self) -> bool {
        ((self.0 >> 10) & 1) != 0
    }
    #[inline(always)]
    pub fn acr_handoff_err_m3_signal_en(&self) -> bool {
        ((self.0 >> 3) & 1) != 0
    }
    #[inline(always)]
    pub fn acr_handoff_err_fail_signal_en(&self) -> bool {
        ((self.0 >> 2) & 1) != 0
    }
    #[inline(always)]
    pub fn acr_handoff_ok_primed_signal_en(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    #[inline(always)]
    pub fn acr_handoff_ok_remain_signal_en(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> StbyCrIntrSignalEnableO80WriteVal {
        StbyCrIntrSignalEnableO80WriteVal(self.0)
    }
}
impl From<u32> for StbyCrIntrSignalEnableO80ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrIntrSignalEnableO80ReadVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrIntrSignalEnableO80ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrIntrSignalEnableO80WriteVal(u32);
impl StbyCrIntrSignalEnableO80WriteVal {
    #[inline(always)]
    pub fn ccc_fatal_rstdaa_err_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 19)) | (u32::from(val) << 19))
    }
    #[inline(always)]
    pub fn ccc_unhandled_nack_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 18)) | (u32::from(val) << 18))
    }
    #[inline(always)]
    pub fn ccc_param_modified_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 17)) | (u32::from(val) << 17))
    }
    #[inline(always)]
    pub fn stby_cr_op_rstact_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 16)) | (u32::from(val) << 16))
    }
    #[inline(always)]
    pub fn stby_cr_accept_err_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
    }
    #[inline(always)]
    pub fn stby_cr_accept_ok_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
    }
    #[inline(always)]
    pub fn stby_cr_accept_nacked_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
    }
    #[inline(always)]
    pub fn stby_cr_dyn_addr_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
    }
    #[inline(always)]
    pub fn crr_response_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
    }
    #[inline(always)]
    pub fn acr_handoff_err_m3_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
    }
    #[inline(always)]
    pub fn acr_handoff_err_fail_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
    }
    #[inline(always)]
    pub fn acr_handoff_ok_primed_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
    #[inline(always)]
    pub fn acr_handoff_ok_remain_signal_en(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for StbyCrIntrSignalEnableO80WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrIntrSignalEnableO80WriteVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrIntrSignalEnableO80WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrIntrForceO88ReadVal(u32);
impl StbyCrIntrForceO88ReadVal {
    #[inline(always)]
    pub fn ccc_fatal_rstdaa_err_force(&self) -> bool {
        ((self.0 >> 19) & 1) != 0
    }
    #[inline(always)]
    pub fn ccc_unhandled_nack_force(&self) -> bool {
        ((self.0 >> 18) & 1) != 0
    }
    #[inline(always)]
    pub fn ccc_param_modified_force(&self) -> bool {
        ((self.0 >> 17) & 1) != 0
    }
    #[inline(always)]
    pub fn stby_cr_op_rstact_force(&self) -> bool {
        ((self.0 >> 16) & 1) != 0
    }
    #[inline(always)]
    pub fn stby_cr_accept_err_force(&self) -> bool {
        ((self.0 >> 14) & 1) != 0
    }
    #[inline(always)]
    pub fn stby_cr_accept_ok_force(&self) -> bool {
        ((self.0 >> 13) & 1) != 0
    }
    #[inline(always)]
    pub fn stby_cr_accept_nacked_force(&self) -> bool {
        ((self.0 >> 12) & 1) != 0
    }
    #[inline(always)]
    pub fn stby_cr_dyn_addr_force(&self) -> bool {
        ((self.0 >> 11) & 1) != 0
    }
    #[inline(always)]
    pub fn crr_response_force(&self) -> bool {
        ((self.0 >> 10) & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> StbyCrIntrForceO88WriteVal {
        StbyCrIntrForceO88WriteVal(self.0)
    }
}
impl From<u32> for StbyCrIntrForceO88ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrIntrForceO88ReadVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrIntrForceO88ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrIntrForceO88WriteVal(u32);
impl StbyCrIntrForceO88WriteVal {
    #[inline(always)]
    pub fn ccc_fatal_rstdaa_err_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 19)) | (u32::from(val) << 19))
    }
    #[inline(always)]
    pub fn ccc_unhandled_nack_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 18)) | (u32::from(val) << 18))
    }
    #[inline(always)]
    pub fn ccc_param_modified_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 17)) | (u32::from(val) << 17))
    }
    #[inline(always)]
    pub fn stby_cr_op_rstact_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 16)) | (u32::from(val) << 16))
    }
    #[inline(always)]
    pub fn stby_cr_accept_err_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 14)) | (u32::from(val) << 14))
    }
    #[inline(always)]
    pub fn stby_cr_accept_ok_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 13)) | (u32::from(val) << 13))
    }
    #[inline(always)]
    pub fn stby_cr_accept_nacked_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
    }
    #[inline(always)]
    pub fn stby_cr_dyn_addr_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
    }
    #[inline(always)]
    pub fn crr_response_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
    }
}
impl From<u32> for StbyCrIntrForceO88WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrIntrForceO88WriteVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrIntrForceO88WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrCccConfigGetcapsO96ReadVal(u32);
impl StbyCrCccConfigGetcapsO96ReadVal {
    #[inline(always)]
    pub fn f2_crcap2_dev_interact(&self) -> u32 {
        (self.0 >> 8) & 0xf
    }
    #[inline(always)]
    pub fn f2_crcap1_bus_config(&self) -> u32 {
        self.0 & 7
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> StbyCrCccConfigGetcapsO96WriteVal {
        StbyCrCccConfigGetcapsO96WriteVal(self.0)
    }
}
impl From<u32> for StbyCrCccConfigGetcapsO96ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrCccConfigGetcapsO96ReadVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrCccConfigGetcapsO96ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrCccConfigGetcapsO96WriteVal(u32);
impl StbyCrCccConfigGetcapsO96WriteVal {
    #[inline(always)]
    pub fn f2_crcap2_dev_interact(self, val: u32) -> Self {
        Self((self.0 & !(0xf << 8)) | ((val & 0xf) << 8))
    }
    #[inline(always)]
    pub fn f2_crcap1_bus_config(self, val: u32) -> Self {
        Self((self.0 & !(7)) | (val & 7))
    }
}
impl From<u32> for StbyCrCccConfigGetcapsO96WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrCccConfigGetcapsO96WriteVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrCccConfigGetcapsO96WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrCccConfigRstactParamsO104ReadVal(u32);
impl StbyCrCccConfigRstactParamsO104ReadVal {
    #[inline(always)]
    pub fn reset_dynamic_addr(&self) -> bool {
        ((self.0 >> 31) & 1) != 0
    }
    #[inline(always)]
    pub fn reset_time_target(&self) -> u32 {
        (self.0 >> 16) & 0xff
    }
    #[inline(always)]
    pub fn reset_time_peripheral(&self) -> u32 {
        (self.0 >> 8) & 0xff
    }
    #[inline(always)]
    pub fn rst_action(&self) -> u32 {
        self.0 & 0xff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> StbyCrCccConfigRstactParamsO104WriteVal {
        StbyCrCccConfigRstactParamsO104WriteVal(self.0)
    }
}
impl From<u32> for StbyCrCccConfigRstactParamsO104ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrCccConfigRstactParamsO104ReadVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrCccConfigRstactParamsO104ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StbyCrCccConfigRstactParamsO104WriteVal(u32);
impl StbyCrCccConfigRstactParamsO104WriteVal {
    #[inline(always)]
    pub fn reset_dynamic_addr(self, val: bool) -> Self {
        Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
    }
    #[inline(always)]
    pub fn reset_time_target(self, val: u32) -> Self {
        Self((self.0 & !(0xff << 16)) | ((val & 0xff) << 16))
    }
    #[inline(always)]
    pub fn reset_time_peripheral(self, val: u32) -> Self {
        Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
    }
    #[inline(always)]
    pub fn rst_action(self, val: u32) -> Self {
        Self((self.0 & !(0xff)) | (val & 0xff))
    }
}
impl From<u32> for StbyCrCccConfigRstactParamsO104WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StbyCrCccConfigRstactParamsO104WriteVal> for u32 {
    #[inline(always)]
    fn from(val: StbyCrCccConfigRstactParamsO104WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct Rsvd2O112ReadVal(u32);
impl Rsvd2O112ReadVal {
    #[inline(always)]
    pub fn _rsvd(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> Rsvd2O112WriteVal {
        Rsvd2O112WriteVal(self.0)
    }
}
impl From<u32> for Rsvd2O112ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<Rsvd2O112ReadVal> for u32 {
    #[inline(always)]
    fn from(val: Rsvd2O112ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct Rsvd2O112WriteVal(u32);
impl Rsvd2O112WriteVal {
    #[inline(always)]
    pub fn _rsvd(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for Rsvd2O112WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<Rsvd2O112WriteVal> for u32 {
    #[inline(always)]
    fn from(val: Rsvd2O112WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct Rsvd3O120ReadVal(u32);
impl Rsvd3O120ReadVal {
    #[inline(always)]
    pub fn _rsvd(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> Rsvd3O120WriteVal {
        Rsvd3O120WriteVal(self.0)
    }
}
impl From<u32> for Rsvd3O120ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<Rsvd3O120ReadVal> for u32 {
    #[inline(always)]
    fn from(val: Rsvd3O120ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct Rsvd3O120WriteVal(u32);
impl Rsvd3O120WriteVal {
    #[inline(always)]
    pub fn _rsvd(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for Rsvd3O120WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<Rsvd3O120WriteVal> for u32 {
    #[inline(always)]
    fn from(val: Rsvd3O120WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ControlO8ReadVal(u32);
impl ControlO8ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> ControlO8WriteVal {
        ControlO8WriteVal(self.0)
    }
}
impl From<u32> for ControlO8ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ControlO8ReadVal> for u32 {
    #[inline(always)]
    fn from(val: ControlO8ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ControlO8WriteVal(u32);
impl ControlO8WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for ControlO8WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ControlO8WriteVal> for u32 {
    #[inline(always)]
    fn from(val: ControlO8WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StatusO16ReadVal(u32);
impl StatusO16ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> StatusO16WriteVal {
        StatusO16WriteVal(self.0)
    }
}
impl From<u32> for StatusO16ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StatusO16ReadVal> for u32 {
    #[inline(always)]
    fn from(val: StatusO16ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct StatusO16WriteVal(u32);
impl StatusO16WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for StatusO16WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<StatusO16WriteVal> for u32 {
    #[inline(always)]
    fn from(val: StatusO16WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ResetControlO24ReadVal(u32);
impl ResetControlO24ReadVal {
    /// TTI IBI Queue Buffer Software Reset
    #[inline(always)]
    pub fn ibi_queue_rst(&self) -> bool {
        ((self.0 >> 5) & 1) != 0
    }
    /// TTI RX Data Queue Buffer Software Reset
    #[inline(always)]
    pub fn rx_data_rst(&self) -> bool {
        ((self.0 >> 4) & 1) != 0
    }
    /// TTI TX Data Queue Buffer Software Reset
    #[inline(always)]
    pub fn tx_data_rst(&self) -> bool {
        ((self.0 >> 3) & 1) != 0
    }
    /// TTI RX Descriptor Queue Buffer Software Reset
    #[inline(always)]
    pub fn rx_desc_rst(&self) -> bool {
        ((self.0 >> 2) & 1) != 0
    }
    /// TTI TX Descriptor Queue Buffer Software Reset
    #[inline(always)]
    pub fn tx_desc_rst(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    /// Target Core Software Reset
    #[inline(always)]
    pub fn soft_rst(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> ResetControlO24WriteVal {
        ResetControlO24WriteVal(self.0)
    }
}
impl From<u32> for ResetControlO24ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ResetControlO24ReadVal> for u32 {
    #[inline(always)]
    fn from(val: ResetControlO24ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ResetControlO24WriteVal(u32);
impl ResetControlO24WriteVal {
    /// TTI IBI Queue Buffer Software Reset
    #[inline(always)]
    pub fn ibi_queue_rst(self, val: bool) -> Self {
        Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
    }
    /// TTI RX Data Queue Buffer Software Reset
    #[inline(always)]
    pub fn rx_data_rst(self, val: bool) -> Self {
        Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
    }
    /// TTI TX Data Queue Buffer Software Reset
    #[inline(always)]
    pub fn tx_data_rst(self, val: bool) -> Self {
        Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
    }
    /// TTI RX Descriptor Queue Buffer Software Reset
    #[inline(always)]
    pub fn rx_desc_rst(self, val: bool) -> Self {
        Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
    }
    /// TTI TX Descriptor Queue Buffer Software Reset
    #[inline(always)]
    pub fn tx_desc_rst(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
    /// Target Core Software Reset
    #[inline(always)]
    pub fn soft_rst(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for ResetControlO24WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ResetControlO24WriteVal> for u32 {
    #[inline(always)]
    fn from(val: ResetControlO24WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct InterruptStatusO32ReadVal(u32);
impl InterruptStatusO32ReadVal {
    /// Bus error occurred
    #[inline(always)]
    pub fn transfer_err_stat(&self) -> bool {
        ((self.0 >> 31) & 1) != 0
    }
    /// Bus aborted transaction
    #[inline(always)]
    pub fn transfer_abort_stat(&self) -> bool {
        ((self.0 >> 25) & 1) != 0
    }
    /// TTI IBI Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI IBI Queue is >= the value defined in `TTI_IBI_THLD`
    #[inline(always)]
    pub fn ibi_thld_stat(&self) -> bool {
        ((self.0 >> 12) & 1) != 0
    }
    /// TTI RX Descriptor Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI RX Descriptor Queue is >= the value defined in `TTI_RX_DESC_THLD`
    #[inline(always)]
    pub fn rx_desc_thld_stat(&self) -> bool {
        ((self.0 >> 11) & 1) != 0
    }
    /// TTI TX Descriptor Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI TX Descriptor Queue is >= the value defined in `TTI_TX_DESC_THLD`
    #[inline(always)]
    pub fn tx_desc_thld_stat(&self) -> bool {
        ((self.0 >> 10) & 1) != 0
    }
    /// TTI RX Data Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of entries in the TTI RX Data Queue is >= the value defined in `TTI_RX_DATA_THLD`
    #[inline(always)]
    pub fn rx_data_thld_stat(&self) -> bool {
        ((self.0 >> 9) & 1) != 0
    }
    /// TTI TX Data Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI TX Data Queue is >= the value defined in `TTI_TX_DATA_THLD`
    #[inline(always)]
    pub fn tx_data_thld_stat(&self) -> bool {
        ((self.0 >> 8) & 1) != 0
    }
    /// Pending Write was NACKed, because the `TX_DESC_STAT` event was not handled in time
    #[inline(always)]
    pub fn tx_desc_timeout(&self) -> bool {
        ((self.0 >> 3) & 1) != 0
    }
    /// Pending Read was NACKed, because the `RX_DESC_STAT` event was not handled in time
    #[inline(always)]
    pub fn rx_desc_timeout(&self) -> bool {
        ((self.0 >> 2) & 1) != 0
    }
    /// There is a pending Write Transaction on the I3C Bus. Software should write data to the TX Descriptor Queue and the TX Data Queue
    #[inline(always)]
    pub fn tx_desc_stat(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    /// There is a pending Read Transaction. Software should read data from the RX Descriptor Queue and the RX Data Queue
    #[inline(always)]
    pub fn rx_desc_stat(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> InterruptStatusO32WriteVal {
        InterruptStatusO32WriteVal(self.0)
    }
}
impl From<u32> for InterruptStatusO32ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<InterruptStatusO32ReadVal> for u32 {
    #[inline(always)]
    fn from(val: InterruptStatusO32ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct InterruptStatusO32WriteVal(u32);
impl InterruptStatusO32WriteVal {
    /// Bus error occurred
    #[inline(always)]
    pub fn transfer_err_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 31)) | (u32::from(val) << 31))
    }
    /// Bus aborted transaction
    #[inline(always)]
    pub fn transfer_abort_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 25)) | (u32::from(val) << 25))
    }
    /// TTI IBI Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI IBI Queue is >= the value defined in `TTI_IBI_THLD`
    #[inline(always)]
    pub fn ibi_thld_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 12)) | (u32::from(val) << 12))
    }
    /// TTI RX Descriptor Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI RX Descriptor Queue is >= the value defined in `TTI_RX_DESC_THLD`
    #[inline(always)]
    pub fn rx_desc_thld_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 11)) | (u32::from(val) << 11))
    }
    /// TTI TX Descriptor Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI TX Descriptor Queue is >= the value defined in `TTI_TX_DESC_THLD`
    #[inline(always)]
    pub fn tx_desc_thld_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 10)) | (u32::from(val) << 10))
    }
    /// TTI RX Data Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of entries in the TTI RX Data Queue is >= the value defined in `TTI_RX_DATA_THLD`
    #[inline(always)]
    pub fn rx_data_thld_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 9)) | (u32::from(val) << 9))
    }
    /// TTI TX Data Buffer Threshold Status, the Target Controller shall set this bit to 1 when the number of available entries in the TTI TX Data Queue is >= the value defined in `TTI_TX_DATA_THLD`
    #[inline(always)]
    pub fn tx_data_thld_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 8)) | (u32::from(val) << 8))
    }
    /// Pending Write was NACKed, because the `TX_DESC_STAT` event was not handled in time
    #[inline(always)]
    pub fn tx_desc_timeout(self, val: bool) -> Self {
        Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
    }
    /// Pending Read was NACKed, because the `RX_DESC_STAT` event was not handled in time
    #[inline(always)]
    pub fn rx_desc_timeout(self, val: bool) -> Self {
        Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
    }
    /// There is a pending Write Transaction on the I3C Bus. Software should write data to the TX Descriptor Queue and the TX Data Queue
    #[inline(always)]
    pub fn tx_desc_stat(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
    /// There is a pending Read Transaction. Software should read data from the RX Descriptor Queue and the RX Data Queue
    #[inline(always)]
    pub fn rx_desc_stat(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for InterruptStatusO32WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<InterruptStatusO32WriteVal> for u32 {
    #[inline(always)]
    fn from(val: InterruptStatusO32WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct InterruptEnableO40ReadVal(u32);
impl InterruptEnableO40ReadVal {
    /// Enables the corresponding interrupt bit `TTI_IBI_THLD_STAT`
    #[inline(always)]
    pub fn ibi_thld_stat_en(&self) -> bool {
        ((self.0 >> 4) & 1) != 0
    }
    /// Enables the corresponding interrupt bit `TTI_RX_DESC_THLD_STAT`
    #[inline(always)]
    pub fn rx_desc_thld_stat_en(&self) -> bool {
        ((self.0 >> 3) & 1) != 0
    }
    /// Enables the corresponding interrupt bit `TTI_TX_DESC_THLD_STAT`
    #[inline(always)]
    pub fn tx_desc_thld_stat_en(&self) -> bool {
        ((self.0 >> 2) & 1) != 0
    }
    /// Enables the corresponding interrupt bit `TTI_RX_DATA_THLD_STAT`
    #[inline(always)]
    pub fn rx_data_thld_stat_en(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    /// Enables the corresponding interrupt bit `TTI_TX_DATA_THLD_STAT`
    #[inline(always)]
    pub fn tx_data_thld_stat_en(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> InterruptEnableO40WriteVal {
        InterruptEnableO40WriteVal(self.0)
    }
}
impl From<u32> for InterruptEnableO40ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<InterruptEnableO40ReadVal> for u32 {
    #[inline(always)]
    fn from(val: InterruptEnableO40ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct InterruptEnableO40WriteVal(u32);
impl InterruptEnableO40WriteVal {
    /// Enables the corresponding interrupt bit `TTI_IBI_THLD_STAT`
    #[inline(always)]
    pub fn ibi_thld_stat_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
    }
    /// Enables the corresponding interrupt bit `TTI_RX_DESC_THLD_STAT`
    #[inline(always)]
    pub fn rx_desc_thld_stat_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
    }
    /// Enables the corresponding interrupt bit `TTI_TX_DESC_THLD_STAT`
    #[inline(always)]
    pub fn tx_desc_thld_stat_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
    }
    /// Enables the corresponding interrupt bit `TTI_RX_DATA_THLD_STAT`
    #[inline(always)]
    pub fn rx_data_thld_stat_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
    /// Enables the corresponding interrupt bit `TTI_TX_DATA_THLD_STAT`
    #[inline(always)]
    pub fn tx_data_thld_stat_en(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for InterruptEnableO40WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<InterruptEnableO40WriteVal> for u32 {
    #[inline(always)]
    fn from(val: InterruptEnableO40WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct InterruptForceO48ReadVal(u32);
impl InterruptForceO48ReadVal {
    /// Forces the corresponding interrupt bit `TTI_IBI_THLD_STAT` to be set to 1
    #[inline(always)]
    pub fn ibi_thld_force(&self) -> bool {
        ((self.0 >> 4) & 1) != 0
    }
    /// Forces the corresponding interrupt bit `TTI_RX_DESC_THLD_STAT` to be set to `1`
    #[inline(always)]
    pub fn rx_desc_thld_force(&self) -> bool {
        ((self.0 >> 3) & 1) != 0
    }
    /// Forces the corresponding interrupt bit `TTI_TX_DESC_THLD_STAT` to be set to `1`
    #[inline(always)]
    pub fn tx_desc_thld_force(&self) -> bool {
        ((self.0 >> 2) & 1) != 0
    }
    /// Forces the corresponding interrupt bit `TTI_RX_DATA_THLD_STAT` to be set to `1`
    #[inline(always)]
    pub fn rx_data_thld_force(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    /// Forces the corresponding interrupt bit `TTI_TX_DATA_THLD_STAT` to be set to `1`
    #[inline(always)]
    pub fn tx_data_thld_force(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> InterruptForceO48WriteVal {
        InterruptForceO48WriteVal(self.0)
    }
}
impl From<u32> for InterruptForceO48ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<InterruptForceO48ReadVal> for u32 {
    #[inline(always)]
    fn from(val: InterruptForceO48ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct InterruptForceO48WriteVal(u32);
impl InterruptForceO48WriteVal {
    /// Forces the corresponding interrupt bit `TTI_IBI_THLD_STAT` to be set to 1
    #[inline(always)]
    pub fn ibi_thld_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
    }
    /// Forces the corresponding interrupt bit `TTI_RX_DESC_THLD_STAT` to be set to `1`
    #[inline(always)]
    pub fn rx_desc_thld_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
    }
    /// Forces the corresponding interrupt bit `TTI_TX_DESC_THLD_STAT` to be set to `1`
    #[inline(always)]
    pub fn tx_desc_thld_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
    }
    /// Forces the corresponding interrupt bit `TTI_RX_DATA_THLD_STAT` to be set to `1`
    #[inline(always)]
    pub fn rx_data_thld_force(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
    /// Forces the corresponding interrupt bit `TTI_TX_DATA_THLD_STAT` to be set to `1`
    #[inline(always)]
    pub fn tx_data_thld_force(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for InterruptForceO48WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<InterruptForceO48WriteVal> for u32 {
    #[inline(always)]
    fn from(val: InterruptForceO48WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct RxDescQueuePortO56ReadVal(u32);
impl RxDescQueuePortO56ReadVal {
    /// RX Data
    #[inline(always)]
    pub fn rx_desc(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> RxDescQueuePortO56WriteVal {
        RxDescQueuePortO56WriteVal(self.0)
    }
}
impl From<u32> for RxDescQueuePortO56ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<RxDescQueuePortO56ReadVal> for u32 {
    #[inline(always)]
    fn from(val: RxDescQueuePortO56ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct RxDescQueuePortO56WriteVal(u32);
impl RxDescQueuePortO56WriteVal {
    /// RX Data
    #[inline(always)]
    pub fn rx_desc(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for RxDescQueuePortO56WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<RxDescQueuePortO56WriteVal> for u32 {
    #[inline(always)]
    fn from(val: RxDescQueuePortO56WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct RxDataPortO64ReadVal(u32);
impl RxDataPortO64ReadVal {
    /// RX Data
    #[inline(always)]
    pub fn rx_data(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> RxDataPortO64WriteVal {
        RxDataPortO64WriteVal(self.0)
    }
}
impl From<u32> for RxDataPortO64ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<RxDataPortO64ReadVal> for u32 {
    #[inline(always)]
    fn from(val: RxDataPortO64ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct RxDataPortO64WriteVal(u32);
impl RxDataPortO64WriteVal {
    /// RX Data
    #[inline(always)]
    pub fn rx_data(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for RxDataPortO64WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<RxDataPortO64WriteVal> for u32 {
    #[inline(always)]
    fn from(val: RxDataPortO64WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TxDescQueuePortO72ReadVal(u32);
impl TxDescQueuePortO72ReadVal {
    /// TX Data
    #[inline(always)]
    pub fn tx_desc(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> TxDescQueuePortO72WriteVal {
        TxDescQueuePortO72WriteVal(self.0)
    }
}
impl From<u32> for TxDescQueuePortO72ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TxDescQueuePortO72ReadVal> for u32 {
    #[inline(always)]
    fn from(val: TxDescQueuePortO72ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TxDescQueuePortO72WriteVal(u32);
impl TxDescQueuePortO72WriteVal {
    /// TX Data
    #[inline(always)]
    pub fn tx_desc(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for TxDescQueuePortO72WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TxDescQueuePortO72WriteVal> for u32 {
    #[inline(always)]
    fn from(val: TxDescQueuePortO72WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TxDataPortO80ReadVal(u32);
impl TxDataPortO80ReadVal {
    /// TX Data
    #[inline(always)]
    pub fn tx_data(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> TxDataPortO80WriteVal {
        TxDataPortO80WriteVal(self.0)
    }
}
impl From<u32> for TxDataPortO80ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TxDataPortO80ReadVal> for u32 {
    #[inline(always)]
    fn from(val: TxDataPortO80ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TxDataPortO80WriteVal(u32);
impl TxDataPortO80WriteVal {
    /// TX Data
    #[inline(always)]
    pub fn tx_data(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for TxDataPortO80WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TxDataPortO80WriteVal> for u32 {
    #[inline(always)]
    fn from(val: TxDataPortO80WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IbiPortO88ReadVal(u32);
impl IbiPortO88ReadVal {
    /// IBI Data
    #[inline(always)]
    pub fn ibi_data(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> IbiPortO88WriteVal {
        IbiPortO88WriteVal(self.0)
    }
}
impl From<u32> for IbiPortO88ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IbiPortO88ReadVal> for u32 {
    #[inline(always)]
    fn from(val: IbiPortO88ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IbiPortO88WriteVal(u32);
impl IbiPortO88WriteVal {
    /// IBI Data
    #[inline(always)]
    pub fn ibi_data(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for IbiPortO88WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IbiPortO88WriteVal> for u32 {
    #[inline(always)]
    fn from(val: IbiPortO88WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct QueueSizeO96ReadVal(u32);
impl QueueSizeO96ReadVal {
    /// Transmit Data Buffer Size in DWORDs calculated as `2^(N+1)`
    #[inline(always)]
    pub fn tx_data_buffer_size(&self) -> u32 {
        (self.0 >> 24) & 0xff
    }
    /// Receive Data Buffer Size in DWORDs calculated as `2^(N+1)`
    #[inline(always)]
    pub fn rx_data_buffer_size(&self) -> u32 {
        (self.0 >> 16) & 0xff
    }
    /// TX Descriptor Buffer Size in DWORDs calculated as `2^(N+1)`
    #[inline(always)]
    pub fn tx_desc_buffer_size(&self) -> u32 {
        (self.0 >> 8) & 0xff
    }
    /// RX Descriptor Buffer Size in DWORDs calculated as `2^(N+1)`
    #[inline(always)]
    pub fn rx_desc_buffer_size(&self) -> u32 {
        self.0 & 0xff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> QueueSizeO96WriteVal {
        QueueSizeO96WriteVal(self.0)
    }
}
impl From<u32> for QueueSizeO96ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<QueueSizeO96ReadVal> for u32 {
    #[inline(always)]
    fn from(val: QueueSizeO96ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct QueueSizeO96WriteVal(u32);
impl QueueSizeO96WriteVal {
    /// Transmit Data Buffer Size in DWORDs calculated as `2^(N+1)`
    #[inline(always)]
    pub fn tx_data_buffer_size(self, val: u32) -> Self {
        Self((self.0 & !(0xff << 24)) | ((val & 0xff) << 24))
    }
    /// Receive Data Buffer Size in DWORDs calculated as `2^(N+1)`
    #[inline(always)]
    pub fn rx_data_buffer_size(self, val: u32) -> Self {
        Self((self.0 & !(0xff << 16)) | ((val & 0xff) << 16))
    }
    /// TX Descriptor Buffer Size in DWORDs calculated as `2^(N+1)`
    #[inline(always)]
    pub fn tx_desc_buffer_size(self, val: u32) -> Self {
        Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
    }
    /// RX Descriptor Buffer Size in DWORDs calculated as `2^(N+1)`
    #[inline(always)]
    pub fn rx_desc_buffer_size(self, val: u32) -> Self {
        Self((self.0 & !(0xff)) | (val & 0xff))
    }
}
impl From<u32> for QueueSizeO96WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<QueueSizeO96WriteVal> for u32 {
    #[inline(always)]
    fn from(val: QueueSizeO96WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IbiQueueSizeO104ReadVal(u32);
impl IbiQueueSizeO104ReadVal {
    /// IBI Queue Size in DWORDs calculated as `2^(N+1)`
    #[inline(always)]
    pub fn ibi_queue_size(&self) -> u32 {
        self.0 & 0xff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> IbiQueueSizeO104WriteVal {
        IbiQueueSizeO104WriteVal(self.0)
    }
}
impl From<u32> for IbiQueueSizeO104ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IbiQueueSizeO104ReadVal> for u32 {
    #[inline(always)]
    fn from(val: IbiQueueSizeO104ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct IbiQueueSizeO104WriteVal(u32);
impl IbiQueueSizeO104WriteVal {
    /// IBI Queue Size in DWORDs calculated as `2^(N+1)`
    #[inline(always)]
    pub fn ibi_queue_size(self, val: u32) -> Self {
        Self((self.0 & !(0xff)) | (val & 0xff))
    }
}
impl From<u32> for IbiQueueSizeO104WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<IbiQueueSizeO104WriteVal> for u32 {
    #[inline(always)]
    fn from(val: IbiQueueSizeO104WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct QueueThldCtrlO112ReadVal(u32);
impl QueueThldCtrlO112ReadVal {
    /// Controls the minimum number of IBI Queue entries needed to trigger the IBI threshold interrupt.
    #[inline(always)]
    pub fn ibi_thld(&self) -> u32 {
        (self.0 >> 24) & 0xff
    }
    /// Controls the minimum number of TTI RX Descriptor Queue entries needed to trigger the TTI RX Descriptor interrupt.
    #[inline(always)]
    pub fn rx_desc_thld(&self) -> u32 {
        (self.0 >> 8) & 0xff
    }
    /// Controls the minimum number of empty TTI TX Descriptor Queue entries needed to trigger the TTI TX Descriptor interrupt.
    #[inline(always)]
    pub fn tx_desc_thld(&self) -> u32 {
        self.0 & 0xff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> QueueThldCtrlO112WriteVal {
        QueueThldCtrlO112WriteVal(self.0)
    }
}
impl From<u32> for QueueThldCtrlO112ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<QueueThldCtrlO112ReadVal> for u32 {
    #[inline(always)]
    fn from(val: QueueThldCtrlO112ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct QueueThldCtrlO112WriteVal(u32);
impl QueueThldCtrlO112WriteVal {
    /// Controls the minimum number of IBI Queue entries needed to trigger the IBI threshold interrupt.
    #[inline(always)]
    pub fn ibi_thld(self, val: u32) -> Self {
        Self((self.0 & !(0xff << 24)) | ((val & 0xff) << 24))
    }
    /// Controls the minimum number of TTI RX Descriptor Queue entries needed to trigger the TTI RX Descriptor interrupt.
    #[inline(always)]
    pub fn rx_desc_thld(self, val: u32) -> Self {
        Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
    }
    /// Controls the minimum number of empty TTI TX Descriptor Queue entries needed to trigger the TTI TX Descriptor interrupt.
    #[inline(always)]
    pub fn tx_desc_thld(self, val: u32) -> Self {
        Self((self.0 & !(0xff)) | (val & 0xff))
    }
}
impl From<u32> for QueueThldCtrlO112WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<QueueThldCtrlO112WriteVal> for u32 {
    #[inline(always)]
    fn from(val: QueueThldCtrlO112WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DataBufferThldCtrlO120ReadVal(u32);
impl DataBufferThldCtrlO120ReadVal {
    /// Minimum number of TTI RX Data queue entries of data received, in DWORDs, that will trigger the TTI RX Data interrupt. Interrupt triggers when `2^(N+1)` RX Buffer DWORD entries are received during the Read transfer.
    #[inline(always)]
    pub fn rx_start_thld(&self) -> u32 {
        (self.0 >> 24) & 7
    }
    /// Minimum number of available TTI TX Data queue entries, in DWORDs, that will trigger the TTI TX Data interrupt. Interrupt triggers when `2^(N+1)` TX Buffer DWORD entries are available.
    #[inline(always)]
    pub fn tx_start_thld(&self) -> u32 {
        (self.0 >> 16) & 7
    }
    /// Minimum number of TTI RX Data queue entries of data received, in DWORDs, that will trigger the TTI RX Data interrupt. Interrupt triggers when `2^(N+1)` RX Buffer DWORD entries are received during the Read transfer.
    #[inline(always)]
    pub fn rx_data_thld(&self) -> u32 {
        (self.0 >> 8) & 7
    }
    /// Minimum number of available TTI TX Data queue entries, in DWORDs, that will trigger the TTI TX Data interrupt. Interrupt triggers when `2^(N+1)` TX Buffer DWORD entries are available.
    #[inline(always)]
    pub fn tx_data_thld(&self) -> u32 {
        self.0 & 7
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> DataBufferThldCtrlO120WriteVal {
        DataBufferThldCtrlO120WriteVal(self.0)
    }
}
impl From<u32> for DataBufferThldCtrlO120ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DataBufferThldCtrlO120ReadVal> for u32 {
    #[inline(always)]
    fn from(val: DataBufferThldCtrlO120ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct DataBufferThldCtrlO120WriteVal(u32);
impl DataBufferThldCtrlO120WriteVal {
    /// Minimum number of TTI RX Data queue entries of data received, in DWORDs, that will trigger the TTI RX Data interrupt. Interrupt triggers when `2^(N+1)` RX Buffer DWORD entries are received during the Read transfer.
    #[inline(always)]
    pub fn rx_start_thld(self, val: u32) -> Self {
        Self((self.0 & !(7 << 24)) | ((val & 7) << 24))
    }
    /// Minimum number of available TTI TX Data queue entries, in DWORDs, that will trigger the TTI TX Data interrupt. Interrupt triggers when `2^(N+1)` TX Buffer DWORD entries are available.
    #[inline(always)]
    pub fn tx_start_thld(self, val: u32) -> Self {
        Self((self.0 & !(7 << 16)) | ((val & 7) << 16))
    }
    /// Minimum number of TTI RX Data queue entries of data received, in DWORDs, that will trigger the TTI RX Data interrupt. Interrupt triggers when `2^(N+1)` RX Buffer DWORD entries are received during the Read transfer.
    #[inline(always)]
    pub fn rx_data_thld(self, val: u32) -> Self {
        Self((self.0 & !(7 << 8)) | ((val & 7) << 8))
    }
    /// Minimum number of available TTI TX Data queue entries, in DWORDs, that will trigger the TTI TX Data interrupt. Interrupt triggers when `2^(N+1)` TX Buffer DWORD entries are available.
    #[inline(always)]
    pub fn tx_data_thld(self, val: u32) -> Self {
        Self((self.0 & !(7)) | (val & 7))
    }
}
impl From<u32> for DataBufferThldCtrlO120WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<DataBufferThldCtrlO120WriteVal> for u32 {
    #[inline(always)]
    fn from(val: DataBufferThldCtrlO120WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct SocMgmtControlO8ReadVal(u32);
impl SocMgmtControlO8ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> SocMgmtControlO8WriteVal {
        SocMgmtControlO8WriteVal(self.0)
    }
}
impl From<u32> for SocMgmtControlO8ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<SocMgmtControlO8ReadVal> for u32 {
    #[inline(always)]
    fn from(val: SocMgmtControlO8ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct SocMgmtControlO8WriteVal(u32);
impl SocMgmtControlO8WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for SocMgmtControlO8WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<SocMgmtControlO8WriteVal> for u32 {
    #[inline(always)]
    fn from(val: SocMgmtControlO8WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct SocMgmtStatusO16ReadVal(u32);
impl SocMgmtStatusO16ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> SocMgmtStatusO16WriteVal {
        SocMgmtStatusO16WriteVal(self.0)
    }
}
impl From<u32> for SocMgmtStatusO16ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<SocMgmtStatusO16ReadVal> for u32 {
    #[inline(always)]
    fn from(val: SocMgmtStatusO16ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct SocMgmtStatusO16WriteVal(u32);
impl SocMgmtStatusO16WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for SocMgmtStatusO16WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<SocMgmtStatusO16WriteVal> for u32 {
    #[inline(always)]
    fn from(val: SocMgmtStatusO16WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct SocMgmtRsvd0O24ReadVal(u32);
impl SocMgmtRsvd0O24ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> SocMgmtRsvd0O24WriteVal {
        SocMgmtRsvd0O24WriteVal(self.0)
    }
}
impl From<u32> for SocMgmtRsvd0O24ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<SocMgmtRsvd0O24ReadVal> for u32 {
    #[inline(always)]
    fn from(val: SocMgmtRsvd0O24ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct SocMgmtRsvd0O24WriteVal(u32);
impl SocMgmtRsvd0O24WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for SocMgmtRsvd0O24WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<SocMgmtRsvd0O24WriteVal> for u32 {
    #[inline(always)]
    fn from(val: SocMgmtRsvd0O24WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct SocMgmtRsvd1O32ReadVal(u32);
impl SocMgmtRsvd1O32ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> SocMgmtRsvd1O32WriteVal {
        SocMgmtRsvd1O32WriteVal(self.0)
    }
}
impl From<u32> for SocMgmtRsvd1O32ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<SocMgmtRsvd1O32ReadVal> for u32 {
    #[inline(always)]
    fn from(val: SocMgmtRsvd1O32ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct SocMgmtRsvd1O32WriteVal(u32);
impl SocMgmtRsvd1O32WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for SocMgmtRsvd1O32WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<SocMgmtRsvd1O32WriteVal> for u32 {
    #[inline(always)]
    fn from(val: SocMgmtRsvd1O32WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct SocMgmtRsvd2O40ReadVal(u32);
impl SocMgmtRsvd2O40ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> SocMgmtRsvd2O40WriteVal {
        SocMgmtRsvd2O40WriteVal(self.0)
    }
}
impl From<u32> for SocMgmtRsvd2O40ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<SocMgmtRsvd2O40ReadVal> for u32 {
    #[inline(always)]
    fn from(val: SocMgmtRsvd2O40ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct SocMgmtRsvd2O40WriteVal(u32);
impl SocMgmtRsvd2O40WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for SocMgmtRsvd2O40WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<SocMgmtRsvd2O40WriteVal> for u32 {
    #[inline(always)]
    fn from(val: SocMgmtRsvd2O40WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct SocMgmtRsvd3O48ReadVal(u32);
impl SocMgmtRsvd3O48ReadVal {
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> SocMgmtRsvd3O48WriteVal {
        SocMgmtRsvd3O48WriteVal(self.0)
    }
}
impl From<u32> for SocMgmtRsvd3O48ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<SocMgmtRsvd3O48ReadVal> for u32 {
    #[inline(always)]
    fn from(val: SocMgmtRsvd3O48ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct SocMgmtRsvd3O48WriteVal(u32);
impl SocMgmtRsvd3O48WriteVal {
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for SocMgmtRsvd3O48WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<SocMgmtRsvd3O48WriteVal> for u32 {
    #[inline(always)]
    fn from(val: SocMgmtRsvd3O48WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct SocPadConfO56ReadVal(u32);
impl SocPadConfO56ReadVal {
    /// Select pad type
    ///
    /// 0 - Bidirectional
    ///
    /// 1 - Open-drain
    ///
    /// 2 - Input-only
    ///
    /// 3 - Analog input
    #[inline(always)]
    pub fn pad_type(&self) -> u32 {
        (self.0 >> 24) & 0xff
    }
    /// Enable virtual open drain:
    ///
    /// 0 - disabled
    ///
    /// 1 - enabled
    #[inline(always)]
    pub fn virtual_od_en(&self) -> bool {
        ((self.0 >> 7) & 1) != 0
    }
    /// Enable Open-Drain:
    ///
    /// 0 - disabled
    ///
    /// 1 - enabled
    #[inline(always)]
    pub fn od_en(&self) -> bool {
        ((self.0 >> 6) & 1) != 0
    }
    /// Invert I/O signal:
    ///
    /// 0 - signals pass-through
    ///
    /// 1 - signals are inverted
    #[inline(always)]
    pub fn io_inversion(&self) -> bool {
        ((self.0 >> 5) & 1) != 0
    }
    /// Enable Pull:
    ///
    /// 0 - disabled
    ///
    /// 1 - enabled
    #[inline(always)]
    pub fn pull_en(&self) -> bool {
        ((self.0 >> 4) & 1) != 0
    }
    /// Direction of the pull:
    ///
    /// 0 - Pull down
    ///
    /// 1 - Pull up
    #[inline(always)]
    pub fn pull_dir(&self) -> bool {
        ((self.0 >> 3) & 1) != 0
    }
    /// Enable the High-Keeper:
    ///
    /// 0 - disabled
    ///
    /// 1 - enabled
    #[inline(always)]
    pub fn keeper_en(&self) -> bool {
        ((self.0 >> 2) & 1) != 0
    }
    /// Enable the Schmitt Trigger:
    ///
    /// 0 - disabled
    ///
    /// 1 - enabled
    #[inline(always)]
    pub fn schmitt_en(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    /// Enable input:
    ///
    /// 0 - enabled
    ///
    /// 1 - disabled
    #[inline(always)]
    pub fn input_enable(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> SocPadConfO56WriteVal {
        SocPadConfO56WriteVal(self.0)
    }
}
impl From<u32> for SocPadConfO56ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<SocPadConfO56ReadVal> for u32 {
    #[inline(always)]
    fn from(val: SocPadConfO56ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct SocPadConfO56WriteVal(u32);
impl SocPadConfO56WriteVal {
    /// Select pad type
    ///
    /// 0 - Bidirectional
    ///
    /// 1 - Open-drain
    ///
    /// 2 - Input-only
    ///
    /// 3 - Analog input
    #[inline(always)]
    pub fn pad_type(self, val: u32) -> Self {
        Self((self.0 & !(0xff << 24)) | ((val & 0xff) << 24))
    }
    /// Enable virtual open drain:
    ///
    /// 0 - disabled
    ///
    /// 1 - enabled
    #[inline(always)]
    pub fn virtual_od_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 7)) | (u32::from(val) << 7))
    }
    /// Enable Open-Drain:
    ///
    /// 0 - disabled
    ///
    /// 1 - enabled
    #[inline(always)]
    pub fn od_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 6)) | (u32::from(val) << 6))
    }
    /// Invert I/O signal:
    ///
    /// 0 - signals pass-through
    ///
    /// 1 - signals are inverted
    #[inline(always)]
    pub fn io_inversion(self, val: bool) -> Self {
        Self((self.0 & !(1 << 5)) | (u32::from(val) << 5))
    }
    /// Enable Pull:
    ///
    /// 0 - disabled
    ///
    /// 1 - enabled
    #[inline(always)]
    pub fn pull_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 4)) | (u32::from(val) << 4))
    }
    /// Direction of the pull:
    ///
    /// 0 - Pull down
    ///
    /// 1 - Pull up
    #[inline(always)]
    pub fn pull_dir(self, val: bool) -> Self {
        Self((self.0 & !(1 << 3)) | (u32::from(val) << 3))
    }
    /// Enable the High-Keeper:
    ///
    /// 0 - disabled
    ///
    /// 1 - enabled
    #[inline(always)]
    pub fn keeper_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 2)) | (u32::from(val) << 2))
    }
    /// Enable the Schmitt Trigger:
    ///
    /// 0 - disabled
    ///
    /// 1 - enabled
    #[inline(always)]
    pub fn schmitt_en(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
    /// Enable input:
    ///
    /// 0 - enabled
    ///
    /// 1 - disabled
    #[inline(always)]
    pub fn input_enable(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for SocPadConfO56WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<SocPadConfO56WriteVal> for u32 {
    #[inline(always)]
    fn from(val: SocPadConfO56WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct SocPadAttrO64ReadVal(u32);
impl SocPadAttrO64ReadVal {
    /// Select driver strength
    ///
    /// '0 - lowest
    ///
    /// '1 - highest
    #[inline(always)]
    pub fn drive_strength(&self) -> u32 {
        (self.0 >> 24) & 0xff
    }
    /// Select driver slew rate
    ///
    /// '0 - lowest
    ///
    /// '1 - highest
    #[inline(always)]
    pub fn drive_slew_rate(&self) -> u32 {
        (self.0 >> 8) & 0xff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> SocPadAttrO64WriteVal {
        SocPadAttrO64WriteVal(self.0)
    }
}
impl From<u32> for SocPadAttrO64ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<SocPadAttrO64ReadVal> for u32 {
    #[inline(always)]
    fn from(val: SocPadAttrO64ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct SocPadAttrO64WriteVal(u32);
impl SocPadAttrO64WriteVal {
    /// Select driver strength
    ///
    /// '0 - lowest
    ///
    /// '1 - highest
    #[inline(always)]
    pub fn drive_strength(self, val: u32) -> Self {
        Self((self.0 & !(0xff << 24)) | ((val & 0xff) << 24))
    }
    /// Select driver slew rate
    ///
    /// '0 - lowest
    ///
    /// '1 - highest
    #[inline(always)]
    pub fn drive_slew_rate(self, val: u32) -> Self {
        Self((self.0 & !(0xff << 8)) | ((val & 0xff) << 8))
    }
}
impl From<u32> for SocPadAttrO64WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<SocPadAttrO64WriteVal> for u32 {
    #[inline(always)]
    fn from(val: SocPadAttrO64WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct SocMgmtFeature2O72ReadVal(u32);
impl SocMgmtFeature2O72ReadVal {
    /// Reserved for: I/O ring and pad configuration
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> SocMgmtFeature2O72WriteVal {
        SocMgmtFeature2O72WriteVal(self.0)
    }
}
impl From<u32> for SocMgmtFeature2O72ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<SocMgmtFeature2O72ReadVal> for u32 {
    #[inline(always)]
    fn from(val: SocMgmtFeature2O72ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct SocMgmtFeature2O72WriteVal(u32);
impl SocMgmtFeature2O72WriteVal {
    /// Reserved for: I/O ring and pad configuration
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for SocMgmtFeature2O72WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<SocMgmtFeature2O72WriteVal> for u32 {
    #[inline(always)]
    fn from(val: SocMgmtFeature2O72WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct SocMgmtFeature3O80ReadVal(u32);
impl SocMgmtFeature3O80ReadVal {
    /// Reserved for: I/O ring and pad configuration
    #[inline(always)]
    pub fn placeholder(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> SocMgmtFeature3O80WriteVal {
        SocMgmtFeature3O80WriteVal(self.0)
    }
}
impl From<u32> for SocMgmtFeature3O80ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<SocMgmtFeature3O80ReadVal> for u32 {
    #[inline(always)]
    fn from(val: SocMgmtFeature3O80ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct SocMgmtFeature3O80WriteVal(u32);
impl SocMgmtFeature3O80WriteVal {
    /// Reserved for: I/O ring and pad configuration
    #[inline(always)]
    pub fn placeholder(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for SocMgmtFeature3O80WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<SocMgmtFeature3O80WriteVal> for u32 {
    #[inline(always)]
    fn from(val: SocMgmtFeature3O80WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TRRegO88ReadVal(u32);
impl TRRegO88ReadVal {
    /// Rise time of both SDA and SCL in clock units
    #[inline(always)]
    pub fn t_r(&self) -> u32 {
        self.0 & 0xfffff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> TRRegO88WriteVal {
        TRRegO88WriteVal(self.0)
    }
}
impl From<u32> for TRRegO88ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TRRegO88ReadVal> for u32 {
    #[inline(always)]
    fn from(val: TRRegO88ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TRRegO88WriteVal(u32);
impl TRRegO88WriteVal {
    /// Rise time of both SDA and SCL in clock units
    #[inline(always)]
    pub fn t_r(self, val: u32) -> Self {
        Self((self.0 & !(0xfffff)) | (val & 0xfffff))
    }
}
impl From<u32> for TRRegO88WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TRRegO88WriteVal> for u32 {
    #[inline(always)]
    fn from(val: TRRegO88WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TFRegO96ReadVal(u32);
impl TFRegO96ReadVal {
    /// Fall time of both SDA and SCL in clock units
    #[inline(always)]
    pub fn t_f(&self) -> u32 {
        self.0 & 0xfffff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> TFRegO96WriteVal {
        TFRegO96WriteVal(self.0)
    }
}
impl From<u32> for TFRegO96ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TFRegO96ReadVal> for u32 {
    #[inline(always)]
    fn from(val: TFRegO96ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TFRegO96WriteVal(u32);
impl TFRegO96WriteVal {
    /// Fall time of both SDA and SCL in clock units
    #[inline(always)]
    pub fn t_f(self, val: u32) -> Self {
        Self((self.0 & !(0xfffff)) | (val & 0xfffff))
    }
}
impl From<u32> for TFRegO96WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TFRegO96WriteVal> for u32 {
    #[inline(always)]
    fn from(val: TFRegO96WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TSuDatRegO104ReadVal(u32);
impl TSuDatRegO104ReadVal {
    /// Data setup time in clock units
    #[inline(always)]
    pub fn t_su_dat(&self) -> u32 {
        self.0 & 0xfffff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> TSuDatRegO104WriteVal {
        TSuDatRegO104WriteVal(self.0)
    }
}
impl From<u32> for TSuDatRegO104ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TSuDatRegO104ReadVal> for u32 {
    #[inline(always)]
    fn from(val: TSuDatRegO104ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TSuDatRegO104WriteVal(u32);
impl TSuDatRegO104WriteVal {
    /// Data setup time in clock units
    #[inline(always)]
    pub fn t_su_dat(self, val: u32) -> Self {
        Self((self.0 & !(0xfffff)) | (val & 0xfffff))
    }
}
impl From<u32> for TSuDatRegO104WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TSuDatRegO104WriteVal> for u32 {
    #[inline(always)]
    fn from(val: TSuDatRegO104WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct THdDatRegO112ReadVal(u32);
impl THdDatRegO112ReadVal {
    /// Data hold time in clock units
    #[inline(always)]
    pub fn t_hd_dat(&self) -> u32 {
        self.0 & 0xfffff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> THdDatRegO112WriteVal {
        THdDatRegO112WriteVal(self.0)
    }
}
impl From<u32> for THdDatRegO112ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<THdDatRegO112ReadVal> for u32 {
    #[inline(always)]
    fn from(val: THdDatRegO112ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct THdDatRegO112WriteVal(u32);
impl THdDatRegO112WriteVal {
    /// Data hold time in clock units
    #[inline(always)]
    pub fn t_hd_dat(self, val: u32) -> Self {
        Self((self.0 & !(0xfffff)) | (val & 0xfffff))
    }
}
impl From<u32> for THdDatRegO112WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<THdDatRegO112WriteVal> for u32 {
    #[inline(always)]
    fn from(val: THdDatRegO112WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct THighRegO120ReadVal(u32);
impl THighRegO120ReadVal {
    #[inline(always)]
    pub fn t_high(&self) -> u32 {
        self.0 & 0xfffff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> THighRegO120WriteVal {
        THighRegO120WriteVal(self.0)
    }
}
impl From<u32> for THighRegO120ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<THighRegO120ReadVal> for u32 {
    #[inline(always)]
    fn from(val: THighRegO120ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct THighRegO120WriteVal(u32);
impl THighRegO120WriteVal {
    #[inline(always)]
    pub fn t_high(self, val: u32) -> Self {
        Self((self.0 & !(0xfffff)) | (val & 0xfffff))
    }
}
impl From<u32> for THighRegO120WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<THighRegO120WriteVal> for u32 {
    #[inline(always)]
    fn from(val: THighRegO120WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TLowRegO128ReadVal(u32);
impl TLowRegO128ReadVal {
    /// Low period of the SCL in clock units
    #[inline(always)]
    pub fn t_low(&self) -> u32 {
        self.0 & 0xfffff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> TLowRegO128WriteVal {
        TLowRegO128WriteVal(self.0)
    }
}
impl From<u32> for TLowRegO128ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TLowRegO128ReadVal> for u32 {
    #[inline(always)]
    fn from(val: TLowRegO128ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TLowRegO128WriteVal(u32);
impl TLowRegO128WriteVal {
    /// Low period of the SCL in clock units
    #[inline(always)]
    pub fn t_low(self, val: u32) -> Self {
        Self((self.0 & !(0xfffff)) | (val & 0xfffff))
    }
}
impl From<u32> for TLowRegO128WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TLowRegO128WriteVal> for u32 {
    #[inline(always)]
    fn from(val: TLowRegO128WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct THdStaRegO136ReadVal(u32);
impl THdStaRegO136ReadVal {
    /// Hold time for (repeated) START in clock units
    #[inline(always)]
    pub fn t_hd_sta(&self) -> u32 {
        self.0 & 0xfffff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> THdStaRegO136WriteVal {
        THdStaRegO136WriteVal(self.0)
    }
}
impl From<u32> for THdStaRegO136ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<THdStaRegO136ReadVal> for u32 {
    #[inline(always)]
    fn from(val: THdStaRegO136ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct THdStaRegO136WriteVal(u32);
impl THdStaRegO136WriteVal {
    /// Hold time for (repeated) START in clock units
    #[inline(always)]
    pub fn t_hd_sta(self, val: u32) -> Self {
        Self((self.0 & !(0xfffff)) | (val & 0xfffff))
    }
}
impl From<u32> for THdStaRegO136WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<THdStaRegO136WriteVal> for u32 {
    #[inline(always)]
    fn from(val: THdStaRegO136WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TSuStaRegO144ReadVal(u32);
impl TSuStaRegO144ReadVal {
    /// Setup time for repeated START in clock units
    #[inline(always)]
    pub fn t_su_sta(&self) -> u32 {
        self.0 & 0xfffff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> TSuStaRegO144WriteVal {
        TSuStaRegO144WriteVal(self.0)
    }
}
impl From<u32> for TSuStaRegO144ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TSuStaRegO144ReadVal> for u32 {
    #[inline(always)]
    fn from(val: TSuStaRegO144ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TSuStaRegO144WriteVal(u32);
impl TSuStaRegO144WriteVal {
    /// Setup time for repeated START in clock units
    #[inline(always)]
    pub fn t_su_sta(self, val: u32) -> Self {
        Self((self.0 & !(0xfffff)) | (val & 0xfffff))
    }
}
impl From<u32> for TSuStaRegO144WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TSuStaRegO144WriteVal> for u32 {
    #[inline(always)]
    fn from(val: TSuStaRegO144WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TSuStoRegO152ReadVal(u32);
impl TSuStoRegO152ReadVal {
    /// Setup time for STOP in clock units
    #[inline(always)]
    pub fn t_su_sto(&self) -> u32 {
        self.0 & 0xfffff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> TSuStoRegO152WriteVal {
        TSuStoRegO152WriteVal(self.0)
    }
}
impl From<u32> for TSuStoRegO152ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TSuStoRegO152ReadVal> for u32 {
    #[inline(always)]
    fn from(val: TSuStoRegO152ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TSuStoRegO152WriteVal(u32);
impl TSuStoRegO152WriteVal {
    /// Setup time for STOP in clock units
    #[inline(always)]
    pub fn t_su_sto(self, val: u32) -> Self {
        Self((self.0 & !(0xfffff)) | (val & 0xfffff))
    }
}
impl From<u32> for TSuStoRegO152WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TSuStoRegO152WriteVal> for u32 {
    #[inline(always)]
    fn from(val: TSuStoRegO152WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TFreeRegO160ReadVal(u32);
impl TFreeRegO160ReadVal {
    #[inline(always)]
    pub fn t_free(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> TFreeRegO160WriteVal {
        TFreeRegO160WriteVal(self.0)
    }
}
impl From<u32> for TFreeRegO160ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TFreeRegO160ReadVal> for u32 {
    #[inline(always)]
    fn from(val: TFreeRegO160ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TFreeRegO160WriteVal(u32);
impl TFreeRegO160WriteVal {
    #[inline(always)]
    pub fn t_free(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for TFreeRegO160WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TFreeRegO160WriteVal> for u32 {
    #[inline(always)]
    fn from(val: TFreeRegO160WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TAvalRegO168ReadVal(u32);
impl TAvalRegO168ReadVal {
    #[inline(always)]
    pub fn t_aval(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> TAvalRegO168WriteVal {
        TAvalRegO168WriteVal(self.0)
    }
}
impl From<u32> for TAvalRegO168ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TAvalRegO168ReadVal> for u32 {
    #[inline(always)]
    fn from(val: TAvalRegO168ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TAvalRegO168WriteVal(u32);
impl TAvalRegO168WriteVal {
    #[inline(always)]
    pub fn t_aval(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for TAvalRegO168WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TAvalRegO168WriteVal> for u32 {
    #[inline(always)]
    fn from(val: TAvalRegO168WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TIdleRegO176ReadVal(u32);
impl TIdleRegO176ReadVal {
    #[inline(always)]
    pub fn t_idle(&self) -> u32 {
        self.0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> TIdleRegO176WriteVal {
        TIdleRegO176WriteVal(self.0)
    }
}
impl From<u32> for TIdleRegO176ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TIdleRegO176ReadVal> for u32 {
    #[inline(always)]
    fn from(val: TIdleRegO176ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct TIdleRegO176WriteVal(u32);
impl TIdleRegO176WriteVal {
    #[inline(always)]
    pub fn t_idle(self, val: u32) -> Self {
        Self((self.0) | (val))
    }
}
impl From<u32> for TIdleRegO176WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<TIdleRegO176WriteVal> for u32 {
    #[inline(always)]
    fn from(val: TIdleRegO176WriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ControllerConfigO8ReadVal(u32);
impl ControllerConfigO8ReadVal {
    #[inline(always)]
    pub fn operation_mode(&self) -> u32 {
        (self.0 >> 4) & 3
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> ControllerConfigO8WriteVal {
        ControllerConfigO8WriteVal(self.0)
    }
}
impl From<u32> for ControllerConfigO8ReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ControllerConfigO8ReadVal> for u32 {
    #[inline(always)]
    fn from(val: ControllerConfigO8ReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ControllerConfigO8WriteVal(u32);
impl ControllerConfigO8WriteVal {
    #[inline(always)]
    pub fn operation_mode(self, val: u32) -> Self {
        Self((self.0 & !(3 << 4)) | ((val & 3) << 4))
    }
}
impl From<u32> for ControllerConfigO8WriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ControllerConfigO8WriteVal> for u32 {
    #[inline(always)]
    fn from(val: ControllerConfigO8WriteVal) -> u32 {
        val.0
    }
}
pub struct I3cBus {
    pub periph: Box<dyn I3cPeripheral>,
}
impl emulator_bus::Bus for I3cBus {
    fn read(
        &mut self,
        size: emulator_types::RvSize,
        addr: emulator_types::RvAddr,
    ) -> Result<emulator_types::RvData, emulator_bus::BusError> {
        match (size, addr) {
            (emulator_types::RvSize::Word, 4) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_base_hc_control(),
            )),
            (emulator_types::RvSize::Word, 5..=7) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 8) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_base_controller_device_addr(),
            )),
            (emulator_types::RvSize::Word, 9..=0xb) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0xc) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_base_hc_capabilities(),
            )),
            (emulator_types::RvSize::Word, 0xd..=0xf) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x10) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_base_reset_control(),
            )),
            (emulator_types::RvSize::Word, 0x11..=0x13) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x14) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_base_present_state(),
            )),
            (emulator_types::RvSize::Word, 0x15..=0x17) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x20) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_base_intr_status(),
            )),
            (emulator_types::RvSize::Word, 0x21..=0x23) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x24) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_base_intr_status_enable(),
            )),
            (emulator_types::RvSize::Word, 0x25..=0x27) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x28) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_base_intr_signal_enable(),
            )),
            (emulator_types::RvSize::Word, 0x29..=0x2b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x2c) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_base_intr_force(),
            )),
            (emulator_types::RvSize::Word, 0x2d..=0x2f) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x30) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_base_dat_section_offset(),
            )),
            (emulator_types::RvSize::Word, 0x31..=0x33) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x34) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_base_dct_section_offset(),
            )),
            (emulator_types::RvSize::Word, 0x35..=0x37) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x38) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_base_ring_headers_section_offset(),
            )),
            (emulator_types::RvSize::Word, 0x39..=0x3b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x3c) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_base_pio_section_offset(),
            )),
            (emulator_types::RvSize::Word, 0x3d..=0x3f) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x40) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_base_ext_caps_section_offset(),
            )),
            (emulator_types::RvSize::Word, 0x41..=0x43) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x4c) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_base_int_ctrl_cmds_en(),
            )),
            (emulator_types::RvSize::Word, 0x4d..=0x4f) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x58) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_base_ibi_notify_ctrl(),
            )),
            (emulator_types::RvSize::Word, 0x59..=0x5b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x5c) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_base_ibi_data_abort_ctrl(),
            )),
            (emulator_types::RvSize::Word, 0x5d..=0x5f) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x60) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_base_dev_ctx_base_lo(),
            )),
            (emulator_types::RvSize::Word, 0x61..=0x63) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x64) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_base_dev_ctx_base_hi(),
            )),
            (emulator_types::RvSize::Word, 0x65..=0x67) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x68) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_base_dev_ctx_sg(),
            )),
            (emulator_types::RvSize::Word, 0x69..=0x6b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x80) => Ok(emulator_types::RvData::from(
                self.periph.read_piocontrol_command_port(),
            )),
            (emulator_types::RvSize::Word, 0x81..=0x83) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x88) => Ok(emulator_types::RvData::from(
                self.periph.read_piocontrol_tx_data_port(),
            )),
            (emulator_types::RvSize::Word, 0x89..=0x8b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x8c) => Ok(emulator_types::RvData::from(
                self.periph.read_piocontrol_ibi_port(),
            )),
            (emulator_types::RvSize::Word, 0x8d..=0x8f) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x90) => Ok(emulator_types::RvData::from(
                self.periph.read_piocontrol_queue_thld_ctrl(),
            )),
            (emulator_types::RvSize::Word, 0x91..=0x93) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x94) => Ok(emulator_types::RvData::from(
                self.periph.read_piocontrol_data_buffer_thld_ctrl(),
            )),
            (emulator_types::RvSize::Word, 0x95..=0x97) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x98) => Ok(emulator_types::RvData::from(
                self.periph.read_piocontrol_queue_size(),
            )),
            (emulator_types::RvSize::Word, 0x99..=0x9b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x9c) => Ok(emulator_types::RvData::from(
                self.periph.read_piocontrol_alt_queue_size(),
            )),
            (emulator_types::RvSize::Word, 0x9d..=0x9f) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0xa0) => Ok(emulator_types::RvData::from(
                self.periph.read_piocontrol_pio_intr_status(),
            )),
            (emulator_types::RvSize::Word, 0xa1..=0xa3) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0xa4) => Ok(emulator_types::RvData::from(
                self.periph.read_piocontrol_pio_intr_status_enable(),
            )),
            (emulator_types::RvSize::Word, 0xa5..=0xa7) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0xa8) => Ok(emulator_types::RvData::from(
                self.periph.read_piocontrol_pio_intr_signal_enable(),
            )),
            (emulator_types::RvSize::Word, 0xa9..=0xab) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0xac) => Ok(emulator_types::RvData::from(
                self.periph.read_piocontrol_pio_intr_force(),
            )),
            (emulator_types::RvSize::Word, 0xad..=0xaf) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0xb0) => Ok(emulator_types::RvData::from(
                self.periph.read_piocontrol_pio_control(),
            )),
            (emulator_types::RvSize::Word, 0xb1..=0xb3) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x100) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_sec_fw_recovery_if_extcap_header(),
            )),
            (emulator_types::RvSize::Word, 0x101..=0x103) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x104) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_sec_fw_recovery_if_prot_cap_0(),
            )),
            (emulator_types::RvSize::Word, 0x105..=0x107) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x108) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_sec_fw_recovery_if_prot_cap_1(),
            )),
            (emulator_types::RvSize::Word, 0x109..=0x10b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x10c) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_sec_fw_recovery_if_prot_cap_2(),
            )),
            (emulator_types::RvSize::Word, 0x10d..=0x10f) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x110) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_sec_fw_recovery_if_prot_cap_3(),
            )),
            (emulator_types::RvSize::Word, 0x111..=0x113) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x114) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_sec_fw_recovery_if_device_id_0(),
            )),
            (emulator_types::RvSize::Word, 0x115..=0x117) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x118) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_sec_fw_recovery_if_device_id_1(),
            )),
            (emulator_types::RvSize::Word, 0x119..=0x11b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x11c) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_sec_fw_recovery_if_device_id_2(),
            )),
            (emulator_types::RvSize::Word, 0x11d..=0x11f) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x120) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_sec_fw_recovery_if_device_id_3(),
            )),
            (emulator_types::RvSize::Word, 0x121..=0x123) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x124) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_sec_fw_recovery_if_device_id_4(),
            )),
            (emulator_types::RvSize::Word, 0x125..=0x127) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x128) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_sec_fw_recovery_if_device_id_5(),
            )),
            (emulator_types::RvSize::Word, 0x129..=0x12b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x12c) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_sec_fw_recovery_if_device_id_6(),
            )),
            (emulator_types::RvSize::Word, 0x12d..=0x12f) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x130) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_sec_fw_recovery_if_device_status_0(),
            )),
            (emulator_types::RvSize::Word, 0x131..=0x133) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x134) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_sec_fw_recovery_if_device_status_1(),
            )),
            (emulator_types::RvSize::Word, 0x135..=0x137) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x138) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_sec_fw_recovery_if_device_reset(),
            )),
            (emulator_types::RvSize::Word, 0x139..=0x13b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x13c) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_sec_fw_recovery_if_recovery_ctrl(),
            )),
            (emulator_types::RvSize::Word, 0x13d..=0x13f) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x140) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_sec_fw_recovery_if_recovery_status(),
            )),
            (emulator_types::RvSize::Word, 0x141..=0x143) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x144) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_sec_fw_recovery_if_hw_status(),
            )),
            (emulator_types::RvSize::Word, 0x145..=0x147) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x148) => Ok(emulator_types::RvData::from(
                self.periph
                    .read_i3c_ec_sec_fw_recovery_if_indirect_fifo_ctrl_0(),
            )),
            (emulator_types::RvSize::Word, 0x149..=0x14b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x14c) => Ok(emulator_types::RvData::from(
                self.periph
                    .read_i3c_ec_sec_fw_recovery_if_indirect_fifo_ctrl_1(),
            )),
            (emulator_types::RvSize::Word, 0x14d..=0x14f) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x150) => Ok(emulator_types::RvData::from(
                self.periph
                    .read_i3c_ec_sec_fw_recovery_if_indirect_fifo_status_0(),
            )),
            (emulator_types::RvSize::Word, 0x151..=0x153) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x154) => Ok(emulator_types::RvData::from(
                self.periph
                    .read_i3c_ec_sec_fw_recovery_if_indirect_fifo_status_1(),
            )),
            (emulator_types::RvSize::Word, 0x155..=0x157) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x158) => Ok(emulator_types::RvData::from(
                self.periph
                    .read_i3c_ec_sec_fw_recovery_if_indirect_fifo_status_2(),
            )),
            (emulator_types::RvSize::Word, 0x159..=0x15b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x15c) => Ok(emulator_types::RvData::from(
                self.periph
                    .read_i3c_ec_sec_fw_recovery_if_indirect_fifo_status_3(),
            )),
            (emulator_types::RvSize::Word, 0x15d..=0x15f) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x160) => Ok(emulator_types::RvData::from(
                self.periph
                    .read_i3c_ec_sec_fw_recovery_if_indirect_fifo_status_4(),
            )),
            (emulator_types::RvSize::Word, 0x161..=0x163) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x164) => Ok(emulator_types::RvData::from(
                self.periph
                    .read_i3c_ec_sec_fw_recovery_if_indirect_fifo_status_5(),
            )),
            (emulator_types::RvSize::Word, 0x165..=0x167) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x168) => Ok(emulator_types::RvData::from(
                self.periph
                    .read_i3c_ec_sec_fw_recovery_if_indirect_fifo_data(),
            )),
            (emulator_types::RvSize::Word, 0x169..=0x16b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x180) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_stdby_ctrl_mode_extcap_header(),
            )),
            (emulator_types::RvSize::Word, 0x181..=0x183) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x184) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_stdby_ctrl_mode_stby_cr_control(),
            )),
            (emulator_types::RvSize::Word, 0x185..=0x187) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x188) => Ok(emulator_types::RvData::from(
                self.periph
                    .read_i3c_ec_stdby_ctrl_mode_stby_cr_device_addr(),
            )),
            (emulator_types::RvSize::Word, 0x189..=0x18b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x18c) => Ok(emulator_types::RvData::from(
                self.periph
                    .read_i3c_ec_stdby_ctrl_mode_stby_cr_capabilities(),
            )),
            (emulator_types::RvSize::Word, 0x18d..=0x18f) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x190) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_stdby_ctrl_mode_rsvd_0(),
            )),
            (emulator_types::RvSize::Word, 0x191..=0x193) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x194) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_stdby_ctrl_mode_stby_cr_status(),
            )),
            (emulator_types::RvSize::Word, 0x195..=0x197) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x198) => Ok(emulator_types::RvData::from(
                self.periph
                    .read_i3c_ec_stdby_ctrl_mode_stby_cr_device_char(),
            )),
            (emulator_types::RvSize::Word, 0x199..=0x19b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x19c) => Ok(emulator_types::RvData::from(
                self.periph
                    .read_i3c_ec_stdby_ctrl_mode_stby_cr_device_pid_lo(),
            )),
            (emulator_types::RvSize::Word, 0x19d..=0x19f) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1a0) => Ok(emulator_types::RvData::from(
                self.periph
                    .read_i3c_ec_stdby_ctrl_mode_stby_cr_intr_status(),
            )),
            (emulator_types::RvSize::Word, 0x1a1..=0x1a3) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1a4) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_stdby_ctrl_mode_rsvd_1(),
            )),
            (emulator_types::RvSize::Word, 0x1a5..=0x1a7) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1a8) => Ok(emulator_types::RvData::from(
                self.periph
                    .read_i3c_ec_stdby_ctrl_mode_stby_cr_intr_signal_enable(),
            )),
            (emulator_types::RvSize::Word, 0x1a9..=0x1ab) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1ac) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_stdby_ctrl_mode_stby_cr_intr_force(),
            )),
            (emulator_types::RvSize::Word, 0x1ad..=0x1af) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1b0) => Ok(emulator_types::RvData::from(
                self.periph
                    .read_i3c_ec_stdby_ctrl_mode_stby_cr_ccc_config_getcaps(),
            )),
            (emulator_types::RvSize::Word, 0x1b1..=0x1b3) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1b4) => Ok(emulator_types::RvData::from(
                self.periph
                    .read_i3c_ec_stdby_ctrl_mode_stby_cr_ccc_config_rstact_params(),
            )),
            (emulator_types::RvSize::Word, 0x1b5..=0x1b7) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1b8) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_stdby_ctrl_mode_rsvd_2(),
            )),
            (emulator_types::RvSize::Word, 0x1b9..=0x1bb) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1bc) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_stdby_ctrl_mode_rsvd_3(),
            )),
            (emulator_types::RvSize::Word, 0x1bd..=0x1bf) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1c0) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_tti_extcap_header(),
            )),
            (emulator_types::RvSize::Word, 0x1c1..=0x1c3) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1c4) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_tti_control(),
            )),
            (emulator_types::RvSize::Word, 0x1c5..=0x1c7) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1c8) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_tti_status(),
            )),
            (emulator_types::RvSize::Word, 0x1c9..=0x1cb) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1cc) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_tti_reset_control(),
            )),
            (emulator_types::RvSize::Word, 0x1cd..=0x1cf) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1d0) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_tti_interrupt_status(),
            )),
            (emulator_types::RvSize::Word, 0x1d1..=0x1d3) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1d4) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_tti_interrupt_enable(),
            )),
            (emulator_types::RvSize::Word, 0x1d5..=0x1d7) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1d8) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_tti_interrupt_force(),
            )),
            (emulator_types::RvSize::Word, 0x1d9..=0x1db) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1e4) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_tti_tx_desc_queue_port(),
            )),
            (emulator_types::RvSize::Word, 0x1e5..=0x1e7) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1e8) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_tti_tx_data_port(),
            )),
            (emulator_types::RvSize::Word, 0x1e9..=0x1eb) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1ec) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_tti_ibi_port(),
            )),
            (emulator_types::RvSize::Word, 0x1ed..=0x1ef) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1f0) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_tti_queue_size(),
            )),
            (emulator_types::RvSize::Word, 0x1f1..=0x1f3) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1f4) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_tti_ibi_queue_size(),
            )),
            (emulator_types::RvSize::Word, 0x1f5..=0x1f7) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1f8) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_tti_queue_thld_ctrl(),
            )),
            (emulator_types::RvSize::Word, 0x1f9..=0x1fb) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1fc) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_tti_data_buffer_thld_ctrl(),
            )),
            (emulator_types::RvSize::Word, 0x1fd..=0x1ff) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x200) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_so_cmgmt_if_extcap_header(),
            )),
            (emulator_types::RvSize::Word, 0x201..=0x203) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x204) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_so_cmgmt_if_soc_mgmt_control(),
            )),
            (emulator_types::RvSize::Word, 0x205..=0x207) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x208) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_so_cmgmt_if_soc_mgmt_status(),
            )),
            (emulator_types::RvSize::Word, 0x209..=0x20b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x20c) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_so_cmgmt_if_soc_mgmt_rsvd_0(),
            )),
            (emulator_types::RvSize::Word, 0x20d..=0x20f) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x210) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_so_cmgmt_if_soc_mgmt_rsvd_1(),
            )),
            (emulator_types::RvSize::Word, 0x211..=0x213) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x214) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_so_cmgmt_if_soc_mgmt_rsvd_2(),
            )),
            (emulator_types::RvSize::Word, 0x215..=0x217) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x218) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_so_cmgmt_if_soc_mgmt_rsvd_3(),
            )),
            (emulator_types::RvSize::Word, 0x219..=0x21b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x21c) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_so_cmgmt_if_soc_pad_conf(),
            )),
            (emulator_types::RvSize::Word, 0x21d..=0x21f) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x220) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_so_cmgmt_if_soc_pad_attr(),
            )),
            (emulator_types::RvSize::Word, 0x221..=0x223) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x224) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_so_cmgmt_if_soc_mgmt_feature_2(),
            )),
            (emulator_types::RvSize::Word, 0x225..=0x227) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x228) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_so_cmgmt_if_soc_mgmt_feature_3(),
            )),
            (emulator_types::RvSize::Word, 0x229..=0x22b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x22c) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_so_cmgmt_if_t_r_reg(),
            )),
            (emulator_types::RvSize::Word, 0x22d..=0x22f) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x230) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_so_cmgmt_if_t_f_reg(),
            )),
            (emulator_types::RvSize::Word, 0x231..=0x233) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x234) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_so_cmgmt_if_t_su_dat_reg(),
            )),
            (emulator_types::RvSize::Word, 0x235..=0x237) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x238) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_so_cmgmt_if_t_hd_dat_reg(),
            )),
            (emulator_types::RvSize::Word, 0x239..=0x23b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x23c) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_so_cmgmt_if_t_high_reg(),
            )),
            (emulator_types::RvSize::Word, 0x23d..=0x23f) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x240) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_so_cmgmt_if_t_low_reg(),
            )),
            (emulator_types::RvSize::Word, 0x241..=0x243) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x244) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_so_cmgmt_if_t_hd_sta_reg(),
            )),
            (emulator_types::RvSize::Word, 0x245..=0x247) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x248) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_so_cmgmt_if_t_su_sta_reg(),
            )),
            (emulator_types::RvSize::Word, 0x249..=0x24b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x24c) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_so_cmgmt_if_t_su_sto_reg(),
            )),
            (emulator_types::RvSize::Word, 0x24d..=0x24f) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x250) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_so_cmgmt_if_t_free_reg(),
            )),
            (emulator_types::RvSize::Word, 0x251..=0x253) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x254) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_so_cmgmt_if_t_aval_reg(),
            )),
            (emulator_types::RvSize::Word, 0x255..=0x257) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x258) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_so_cmgmt_if_t_idle_reg(),
            )),
            (emulator_types::RvSize::Word, 0x259..=0x25b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x260) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_ctrl_cfg_extcap_header(),
            )),
            (emulator_types::RvSize::Word, 0x261..=0x263) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x264) => Ok(emulator_types::RvData::from(
                self.periph.read_i3c_ec_ctrl_cfg_controller_config(),
            )),
            (emulator_types::RvSize::Word, 0x265..=0x267) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            _ => Err(emulator_bus::BusError::LoadAccessFault),
        }
    }
    fn write(
        &mut self,
        size: emulator_types::RvSize,
        addr: emulator_types::RvAddr,
        val: emulator_types::RvData,
    ) -> Result<(), emulator_bus::BusError> {
        match (size, addr) {
            (emulator_types::RvSize::Word, 0) => {
                self.periph.write_i3c_base_hci_version(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 1..=3) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 4) => {
                self.periph
                    .write_i3c_base_hc_control(HcControlReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 5..=7) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 8) => {
                self.periph
                    .write_i3c_base_controller_device_addr(ControllerDeviceAddrReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 9..=0xb) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0xc) => {
                self.periph
                    .write_i3c_base_hc_capabilities(HcCapabilitiesReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0xd..=0xf) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x10) => {
                self.periph
                    .write_i3c_base_reset_control(ResetControlReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x11..=0x13) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x14) => {
                self.periph
                    .write_i3c_base_present_state(PresentStateReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x15..=0x17) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x20) => {
                self.periph
                    .write_i3c_base_intr_status(IntrStatusReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x21..=0x23) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x24) => {
                self.periph
                    .write_i3c_base_intr_status_enable(IntrStatusEnableReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x25..=0x27) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x28) => {
                self.periph
                    .write_i3c_base_intr_signal_enable(IntrSignalEnableReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x29..=0x2b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x2c) => {
                self.periph
                    .write_i3c_base_intr_force(IntrForceReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x2d..=0x2f) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x30) => {
                self.periph
                    .write_i3c_base_dat_section_offset(DatSectionOffsetReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x31..=0x33) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x34) => {
                self.periph
                    .write_i3c_base_dct_section_offset(DctSectionOffsetReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x35..=0x37) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x38) => {
                self.periph.write_i3c_base_ring_headers_section_offset(
                    RingHeadersSectionOffsetReadVal::from(val),
                );
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x39..=0x3b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x3c) => {
                self.periph
                    .write_i3c_base_pio_section_offset(PioSectionOffsetReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x3d..=0x3f) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x40) => {
                self.periph
                    .write_i3c_base_ext_caps_section_offset(ExtCapsSectionOffsetReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x41..=0x43) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x4c) => {
                self.periph
                    .write_i3c_base_int_ctrl_cmds_en(IntCtrlCmdsEnReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x4d..=0x4f) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x58) => {
                self.periph
                    .write_i3c_base_ibi_notify_ctrl(IbiNotifyCtrlReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x59..=0x5b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x5c) => {
                self.periph
                    .write_i3c_base_ibi_data_abort_ctrl(IbiDataAbortCtrlReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x5d..=0x5f) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x60) => {
                self.periph
                    .write_i3c_base_dev_ctx_base_lo(DevCtxBaseLoReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x61..=0x63) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x64) => {
                self.periph
                    .write_i3c_base_dev_ctx_base_hi(DevCtxBaseHiReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x65..=0x67) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x68) => {
                self.periph
                    .write_i3c_base_dev_ctx_sg(DevCtxSgReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x69..=0x6b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x84) => {
                self.periph.write_piocontrol_response_port(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x85..=0x87) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x88) => {
                self.periph.write_piocontrol_rx_data_port(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x89..=0x8b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x8c) => {
                self.periph
                    .write_piocontrol_ibi_port(IbiPortReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x8d..=0x8f) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x90) => {
                self.periph
                    .write_piocontrol_queue_thld_ctrl(QueueThldCtrlReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x91..=0x93) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x94) => {
                self.periph
                    .write_piocontrol_data_buffer_thld_ctrl(DataBufferThldCtrlReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x95..=0x97) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x98) => {
                self.periph
                    .write_piocontrol_queue_size(QueueSizeReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x99..=0x9b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x9c) => {
                self.periph
                    .write_piocontrol_alt_queue_size(AltQueueSizeReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x9d..=0x9f) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0xa0) => {
                self.periph
                    .write_piocontrol_pio_intr_status(PioIntrStatusReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0xa1..=0xa3) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0xa4) => {
                self.periph
                    .write_piocontrol_pio_intr_status_enable(PioIntrStatusEnableReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0xa5..=0xa7) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0xa8) => {
                self.periph
                    .write_piocontrol_pio_intr_signal_enable(PioIntrSignalEnableReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0xa9..=0xab) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0xac) => {
                self.periph
                    .write_piocontrol_pio_intr_force(PioIntrForceReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0xad..=0xaf) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0xb0) => {
                self.periph
                    .write_piocontrol_pio_control(PioControlReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0xb1..=0xb3) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x100) => {
                self.periph.write_i3c_ec_sec_fw_recovery_if_extcap_header(
                    ExtcapHeaderO0ReadVal::from(val),
                );
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x101..=0x103) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x104) => {
                self.periph.write_i3c_ec_sec_fw_recovery_if_prot_cap_0(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x105..=0x107) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x108) => {
                self.periph.write_i3c_ec_sec_fw_recovery_if_prot_cap_1(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x109..=0x10b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x10c) => {
                self.periph.write_i3c_ec_sec_fw_recovery_if_prot_cap_2(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x10d..=0x10f) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x110) => {
                self.periph.write_i3c_ec_sec_fw_recovery_if_prot_cap_3(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x111..=0x113) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x114) => {
                self.periph.write_i3c_ec_sec_fw_recovery_if_device_id_0(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x115..=0x117) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x118) => {
                self.periph.write_i3c_ec_sec_fw_recovery_if_device_id_1(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x119..=0x11b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x11c) => {
                self.periph.write_i3c_ec_sec_fw_recovery_if_device_id_2(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x11d..=0x11f) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x120) => {
                self.periph.write_i3c_ec_sec_fw_recovery_if_device_id_3(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x121..=0x123) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x124) => {
                self.periph.write_i3c_ec_sec_fw_recovery_if_device_id_4(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x125..=0x127) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x128) => {
                self.periph.write_i3c_ec_sec_fw_recovery_if_device_id_5(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x129..=0x12b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x12c) => {
                self.periph.write_i3c_ec_sec_fw_recovery_if_device_id_6(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x12d..=0x12f) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x130) => {
                self.periph
                    .write_i3c_ec_sec_fw_recovery_if_device_status_0(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x131..=0x133) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x134) => {
                self.periph
                    .write_i3c_ec_sec_fw_recovery_if_device_status_1(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x135..=0x137) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x138) => {
                self.periph
                    .write_i3c_ec_sec_fw_recovery_if_device_reset(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x139..=0x13b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x13c) => {
                self.periph
                    .write_i3c_ec_sec_fw_recovery_if_recovery_ctrl(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x13d..=0x13f) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x140) => {
                self.periph
                    .write_i3c_ec_sec_fw_recovery_if_recovery_status(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x141..=0x143) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x144) => {
                self.periph.write_i3c_ec_sec_fw_recovery_if_hw_status(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x145..=0x147) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x148) => {
                self.periph
                    .write_i3c_ec_sec_fw_recovery_if_indirect_fifo_ctrl_0(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x149..=0x14b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x14c) => {
                self.periph
                    .write_i3c_ec_sec_fw_recovery_if_indirect_fifo_ctrl_1(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x14d..=0x14f) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x150) => {
                self.periph
                    .write_i3c_ec_sec_fw_recovery_if_indirect_fifo_status_0(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x151..=0x153) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x154) => {
                self.periph
                    .write_i3c_ec_sec_fw_recovery_if_indirect_fifo_status_1(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x155..=0x157) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x158) => {
                self.periph
                    .write_i3c_ec_sec_fw_recovery_if_indirect_fifo_status_2(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x159..=0x15b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x15c) => {
                self.periph
                    .write_i3c_ec_sec_fw_recovery_if_indirect_fifo_status_3(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x15d..=0x15f) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x160) => {
                self.periph
                    .write_i3c_ec_sec_fw_recovery_if_indirect_fifo_status_4(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x161..=0x163) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x164) => {
                self.periph
                    .write_i3c_ec_sec_fw_recovery_if_indirect_fifo_status_5(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x165..=0x167) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x168) => {
                self.periph
                    .write_i3c_ec_sec_fw_recovery_if_indirect_fifo_data(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x169..=0x16b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x180) => {
                self.periph
                    .write_i3c_ec_stdby_ctrl_mode_extcap_header(ExtcapHeaderO0ReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x181..=0x183) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x184) => {
                self.periph.write_i3c_ec_stdby_ctrl_mode_stby_cr_control(
                    StbyCrControlO8ReadVal::from(val),
                );
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x185..=0x187) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x188) => {
                self.periph
                    .write_i3c_ec_stdby_ctrl_mode_stby_cr_device_addr(
                        StbyCrDeviceAddrO16ReadVal::from(val),
                    );
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x189..=0x18b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x18c) => {
                self.periph
                    .write_i3c_ec_stdby_ctrl_mode_stby_cr_capabilities(
                        StbyCrCapabilitiesO24ReadVal::from(val),
                    );
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x18d..=0x18f) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x190) => {
                self.periph.write_i3c_ec_stdby_ctrl_mode_rsvd_0(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x191..=0x193) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x194) => {
                self.periph
                    .write_i3c_ec_stdby_ctrl_mode_stby_cr_status(StbyCrStatusO40ReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x195..=0x197) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x198) => {
                self.periph
                    .write_i3c_ec_stdby_ctrl_mode_stby_cr_device_char(
                        StbyCrDeviceCharO48ReadVal::from(val),
                    );
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x199..=0x19b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x19c) => {
                self.periph
                    .write_i3c_ec_stdby_ctrl_mode_stby_cr_device_pid_lo(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x19d..=0x19f) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1a0) => {
                self.periph
                    .write_i3c_ec_stdby_ctrl_mode_stby_cr_intr_status(
                        StbyCrIntrStatusO64ReadVal::from(val),
                    );
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x1a1..=0x1a3) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1a4) => {
                self.periph.write_i3c_ec_stdby_ctrl_mode_rsvd_1(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x1a5..=0x1a7) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1a8) => {
                self.periph
                    .write_i3c_ec_stdby_ctrl_mode_stby_cr_intr_signal_enable(
                        StbyCrIntrSignalEnableO80ReadVal::from(val),
                    );
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x1a9..=0x1ab) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1ac) => {
                self.periph.write_i3c_ec_stdby_ctrl_mode_stby_cr_intr_force(
                    StbyCrIntrForceO88ReadVal::from(val),
                );
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x1ad..=0x1af) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1b0) => {
                self.periph
                    .write_i3c_ec_stdby_ctrl_mode_stby_cr_ccc_config_getcaps(
                        StbyCrCccConfigGetcapsO96ReadVal::from(val),
                    );
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x1b1..=0x1b3) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1b4) => {
                self.periph
                    .write_i3c_ec_stdby_ctrl_mode_stby_cr_ccc_config_rstact_params(
                        StbyCrCccConfigRstactParamsO104ReadVal::from(val),
                    );
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x1b5..=0x1b7) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1b8) => {
                self.periph.write_i3c_ec_stdby_ctrl_mode_rsvd_2(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x1b9..=0x1bb) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1bc) => {
                self.periph.write_i3c_ec_stdby_ctrl_mode_rsvd_3(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x1bd..=0x1bf) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1c0) => {
                self.periph
                    .write_i3c_ec_tti_extcap_header(ExtcapHeaderO0ReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x1c1..=0x1c3) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1c4) => {
                self.periph.write_i3c_ec_tti_control(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x1c5..=0x1c7) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1c8) => {
                self.periph.write_i3c_ec_tti_status(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x1c9..=0x1cb) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1cc) => {
                self.periph
                    .write_i3c_ec_tti_reset_control(ResetControlO24ReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x1cd..=0x1cf) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1d0) => {
                self.periph
                    .write_i3c_ec_tti_interrupt_status(InterruptStatusO32ReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x1d1..=0x1d3) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1d4) => {
                self.periph
                    .write_i3c_ec_tti_interrupt_enable(InterruptEnableO40ReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x1d5..=0x1d7) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1d8) => {
                self.periph
                    .write_i3c_ec_tti_interrupt_force(InterruptForceO48ReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x1d9..=0x1db) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1dc) => {
                self.periph.write_i3c_ec_tti_rx_desc_queue_port(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x1dd..=0x1df) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1e0) => {
                self.periph.write_i3c_ec_tti_rx_data_port(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x1e1..=0x1e3) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1f0) => {
                self.periph
                    .write_i3c_ec_tti_queue_size(QueueSizeO96ReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x1f1..=0x1f3) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1f4) => {
                self.periph
                    .write_i3c_ec_tti_ibi_queue_size(IbiQueueSizeO104ReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x1f5..=0x1f7) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1f8) => {
                self.periph
                    .write_i3c_ec_tti_queue_thld_ctrl(QueueThldCtrlO112ReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x1f9..=0x1fb) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1fc) => {
                self.periph.write_i3c_ec_tti_data_buffer_thld_ctrl(
                    DataBufferThldCtrlO120ReadVal::from(val),
                );
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x1fd..=0x1ff) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x200) => {
                self.periph
                    .write_i3c_ec_so_cmgmt_if_extcap_header(ExtcapHeaderO0ReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x201..=0x203) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x204) => {
                self.periph.write_i3c_ec_so_cmgmt_if_soc_mgmt_control(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x205..=0x207) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x208) => {
                self.periph.write_i3c_ec_so_cmgmt_if_soc_mgmt_status(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x209..=0x20b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x20c) => {
                self.periph.write_i3c_ec_so_cmgmt_if_soc_mgmt_rsvd_0(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x20d..=0x20f) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x210) => {
                self.periph.write_i3c_ec_so_cmgmt_if_soc_mgmt_rsvd_1(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x211..=0x213) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x214) => {
                self.periph.write_i3c_ec_so_cmgmt_if_soc_mgmt_rsvd_2(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x215..=0x217) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x218) => {
                self.periph.write_i3c_ec_so_cmgmt_if_soc_mgmt_rsvd_3(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x219..=0x21b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x21c) => {
                self.periph
                    .write_i3c_ec_so_cmgmt_if_soc_pad_conf(SocPadConfO56ReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x21d..=0x21f) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x220) => {
                self.periph
                    .write_i3c_ec_so_cmgmt_if_soc_pad_attr(SocPadAttrO64ReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x221..=0x223) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x224) => {
                self.periph.write_i3c_ec_so_cmgmt_if_soc_mgmt_feature_2(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x225..=0x227) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x228) => {
                self.periph.write_i3c_ec_so_cmgmt_if_soc_mgmt_feature_3(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x229..=0x22b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x22c) => {
                self.periph
                    .write_i3c_ec_so_cmgmt_if_t_r_reg(TRRegO88ReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x22d..=0x22f) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x230) => {
                self.periph
                    .write_i3c_ec_so_cmgmt_if_t_f_reg(TFRegO96ReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x231..=0x233) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x234) => {
                self.periph
                    .write_i3c_ec_so_cmgmt_if_t_su_dat_reg(TSuDatRegO104ReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x235..=0x237) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x238) => {
                self.periph
                    .write_i3c_ec_so_cmgmt_if_t_hd_dat_reg(THdDatRegO112ReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x239..=0x23b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x23c) => {
                self.periph
                    .write_i3c_ec_so_cmgmt_if_t_high_reg(THighRegO120ReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x23d..=0x23f) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x240) => {
                self.periph
                    .write_i3c_ec_so_cmgmt_if_t_low_reg(TLowRegO128ReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x241..=0x243) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x244) => {
                self.periph
                    .write_i3c_ec_so_cmgmt_if_t_hd_sta_reg(THdStaRegO136ReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x245..=0x247) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x248) => {
                self.periph
                    .write_i3c_ec_so_cmgmt_if_t_su_sta_reg(TSuStaRegO144ReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x249..=0x24b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x24c) => {
                self.periph
                    .write_i3c_ec_so_cmgmt_if_t_su_sto_reg(TSuStoRegO152ReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x24d..=0x24f) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x250) => {
                self.periph.write_i3c_ec_so_cmgmt_if_t_free_reg(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x251..=0x253) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x254) => {
                self.periph.write_i3c_ec_so_cmgmt_if_t_aval_reg(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x255..=0x257) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x258) => {
                self.periph.write_i3c_ec_so_cmgmt_if_t_idle_reg(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x259..=0x25b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x260) => {
                self.periph
                    .write_i3c_ec_ctrl_cfg_extcap_header(ExtcapHeaderO0ReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x261..=0x263) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x264) => {
                self.periph
                    .write_i3c_ec_ctrl_cfg_controller_config(ControllerConfigO8ReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x265..=0x267) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            _ => Err(emulator_bus::BusError::StoreAccessFault),
        }
    }
    fn poll(&mut self) {
        self.periph.poll();
    }
    fn warm_reset(&mut self) {
        self.periph.warm_reset();
    }
    fn update_reset(&mut self) {
        self.periph.update_reset();
    }
}
