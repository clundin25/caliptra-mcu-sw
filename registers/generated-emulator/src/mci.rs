// Licensed under the Apache-2.0 license.
//
// generated by registers_generator with caliptra-rtl repo at 9f80a2bebb755233696929bf1da5ca0b90eba9a1
// , caliptra-ss repo at 9911c2b0e4bac9e4b48f6c2155c86cb116159734
// , and i3c-core repo at d5c715103f529ade0e5d375a53c5692daaa9c54b
//
#[derive(Clone, Copy, Default)]
pub struct CapabilitiesReadVal(u32);
impl CapabilitiesReadVal {
    /// Number of Mailboxes in MCI
    #[inline(always)]
    pub fn num_mbox(&self) -> u32 {
        self.0 & 0xf
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> CapabilitiesWriteVal {
        CapabilitiesWriteVal(self.0)
    }
}
impl From<u32> for CapabilitiesReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<CapabilitiesReadVal> for u32 {
    #[inline(always)]
    fn from(val: CapabilitiesReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct CapabilitiesWriteVal(u32);
impl CapabilitiesWriteVal {
    /// Number of Mailboxes in MCI
    #[inline(always)]
    pub fn num_mbox(self, val: u32) -> Self {
        Self((self.0 & !(0xf)) | (val & 0xf))
    }
}
impl From<u32> for CapabilitiesWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<CapabilitiesWriteVal> for u32 {
    #[inline(always)]
    fn from(val: CapabilitiesWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct HwRevIdReadVal(u32);
impl HwRevIdReadVal {
    /// Official release version. Bit field encoding is:
    /// [br][lb]15:12[rb] Major version
    /// [br][lb]11: 8[rb] Minor version
    /// [br][lb] 7: 0[rb] Patch version
    #[inline(always)]
    pub fn mc_generation(&self) -> u32 {
        self.0 & 0xffff
    }
    #[inline(always)]
    pub fn soc_stepping_id(&self) -> u32 {
        (self.0 >> 16) & 0xffff
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> HwRevIdWriteVal {
        HwRevIdWriteVal(self.0)
    }
}
impl From<u32> for HwRevIdReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<HwRevIdReadVal> for u32 {
    #[inline(always)]
    fn from(val: HwRevIdReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct HwRevIdWriteVal(u32);
impl HwRevIdWriteVal {
    /// Official release version. Bit field encoding is:
    /// [br][lb]15:12[rb] Major version
    /// [br][lb]11: 8[rb] Minor version
    /// [br][lb] 7: 0[rb] Patch version
    #[inline(always)]
    pub fn mc_generation(self, val: u32) -> Self {
        Self((self.0 & !(0xffff)) | (val & 0xffff))
    }
    #[inline(always)]
    pub fn soc_stepping_id(self, val: u32) -> Self {
        Self((self.0 & !(0xffff << 16)) | ((val & 0xffff) << 16))
    }
}
impl From<u32> for HwRevIdWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<HwRevIdWriteVal> for u32 {
    #[inline(always)]
    fn from(val: HwRevIdWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct FlowStatusReadVal(u32);
impl FlowStatusReadVal {
    /// Generic Status
    #[inline(always)]
    pub fn status(&self) -> u32 {
        self.0 & 0xffffff
    }
    /// DEV ID CSR ready
    #[inline(always)]
    pub fn rsvd(&self) -> u32 {
        (self.0 >> 24) & 7
    }
    /// Boot FSM State
    #[inline(always)]
    pub fn boot_fsm_ps(&self) -> u32 {
        (self.0 >> 27) & 0x1f
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> FlowStatusWriteVal {
        FlowStatusWriteVal(self.0)
    }
}
impl From<u32> for FlowStatusReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<FlowStatusReadVal> for u32 {
    #[inline(always)]
    fn from(val: FlowStatusReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct FlowStatusWriteVal(u32);
impl FlowStatusWriteVal {
    /// Generic Status
    #[inline(always)]
    pub fn status(self, val: u32) -> Self {
        Self((self.0 & !(0xffffff)) | (val & 0xffffff))
    }
    /// DEV ID CSR ready
    #[inline(always)]
    pub fn rsvd(self, val: u32) -> Self {
        Self((self.0 & !(7 << 24)) | ((val & 7) << 24))
    }
    /// Boot FSM State
    #[inline(always)]
    pub fn boot_fsm_ps(self, val: u32) -> Self {
        Self((self.0 & !(0x1f << 27)) | ((val & 0x1f) << 27))
    }
}
impl From<u32> for FlowStatusWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<FlowStatusWriteVal> for u32 {
    #[inline(always)]
    fn from(val: FlowStatusWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ResetReasonReadVal(u32);
impl ResetReasonReadVal {
    /// FW update reset has been executed
    #[inline(always)]
    pub fn fw_upd_reset(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Warm reset has been executed
    #[inline(always)]
    pub fn warm_reset(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> ResetReasonWriteVal {
        ResetReasonWriteVal(self.0)
    }
}
impl From<u32> for ResetReasonReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ResetReasonReadVal> for u32 {
    #[inline(always)]
    fn from(val: ResetReasonReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ResetReasonWriteVal(u32);
impl ResetReasonWriteVal {
    /// FW update reset has been executed
    #[inline(always)]
    pub fn fw_upd_reset(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
    /// Warm reset has been executed
    #[inline(always)]
    pub fn warm_reset(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
}
impl From<u32> for ResetReasonWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ResetReasonWriteVal> for u32 {
    #[inline(always)]
    fn from(val: ResetReasonWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct HwErrorReadVal(u32);
impl HwErrorReadVal {
    #[inline(always)]
    pub fn rsvd(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> HwErrorWriteVal {
        HwErrorWriteVal(self.0)
    }
}
impl From<u32> for HwErrorReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<HwErrorReadVal> for u32 {
    #[inline(always)]
    fn from(val: HwErrorReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct HwErrorWriteVal(u32);
impl HwErrorWriteVal {
    #[inline(always)]
    pub fn rsvd(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for HwErrorWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<HwErrorWriteVal> for u32 {
    #[inline(always)]
    fn from(val: HwErrorWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct WdtTimer1EnReadVal(u32);
impl WdtTimer1EnReadVal {
    /// WDT timer1 enable
    #[inline(always)]
    pub fn timer1_en(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> WdtTimer1EnWriteVal {
        WdtTimer1EnWriteVal(self.0)
    }
}
impl From<u32> for WdtTimer1EnReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<WdtTimer1EnReadVal> for u32 {
    #[inline(always)]
    fn from(val: WdtTimer1EnReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct WdtTimer1EnWriteVal(u32);
impl WdtTimer1EnWriteVal {
    /// WDT timer1 enable
    #[inline(always)]
    pub fn timer1_en(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for WdtTimer1EnWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<WdtTimer1EnWriteVal> for u32 {
    #[inline(always)]
    fn from(val: WdtTimer1EnWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct WdtTimer1CtrlReadVal(u32);
impl WdtTimer1CtrlReadVal {
    /// WDT timer1 restart
    #[inline(always)]
    pub fn timer1_restart(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> WdtTimer1CtrlWriteVal {
        WdtTimer1CtrlWriteVal(self.0)
    }
}
impl From<u32> for WdtTimer1CtrlReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<WdtTimer1CtrlReadVal> for u32 {
    #[inline(always)]
    fn from(val: WdtTimer1CtrlReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct WdtTimer1CtrlWriteVal(u32);
impl WdtTimer1CtrlWriteVal {
    /// WDT timer1 restart
    #[inline(always)]
    pub fn timer1_restart(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for WdtTimer1CtrlWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<WdtTimer1CtrlWriteVal> for u32 {
    #[inline(always)]
    fn from(val: WdtTimer1CtrlWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct WdtTimer2EnReadVal(u32);
impl WdtTimer2EnReadVal {
    /// WDT timer2 enable
    #[inline(always)]
    pub fn timer2_en(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> WdtTimer2EnWriteVal {
        WdtTimer2EnWriteVal(self.0)
    }
}
impl From<u32> for WdtTimer2EnReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<WdtTimer2EnReadVal> for u32 {
    #[inline(always)]
    fn from(val: WdtTimer2EnReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct WdtTimer2EnWriteVal(u32);
impl WdtTimer2EnWriteVal {
    /// WDT timer2 enable
    #[inline(always)]
    pub fn timer2_en(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for WdtTimer2EnWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<WdtTimer2EnWriteVal> for u32 {
    #[inline(always)]
    fn from(val: WdtTimer2EnWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct WdtTimer2CtrlReadVal(u32);
impl WdtTimer2CtrlReadVal {
    /// WDT timer2 restart
    #[inline(always)]
    pub fn timer2_restart(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> WdtTimer2CtrlWriteVal {
        WdtTimer2CtrlWriteVal(self.0)
    }
}
impl From<u32> for WdtTimer2CtrlReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<WdtTimer2CtrlReadVal> for u32 {
    #[inline(always)]
    fn from(val: WdtTimer2CtrlReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct WdtTimer2CtrlWriteVal(u32);
impl WdtTimer2CtrlWriteVal {
    /// WDT timer2 restart
    #[inline(always)]
    pub fn timer2_restart(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for WdtTimer2CtrlWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<WdtTimer2CtrlWriteVal> for u32 {
    #[inline(always)]
    fn from(val: WdtTimer2CtrlWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct CptraWdtStatusReadVal(u32);
impl CptraWdtStatusReadVal {
    /// Timer1 timed out, timer2 enabled
    #[inline(always)]
    pub fn t1_timeout(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Timer2 timed out
    #[inline(always)]
    pub fn t2_timeout(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> CptraWdtStatusWriteVal {
        CptraWdtStatusWriteVal(self.0)
    }
}
impl From<u32> for CptraWdtStatusReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<CptraWdtStatusReadVal> for u32 {
    #[inline(always)]
    fn from(val: CptraWdtStatusReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct CptraWdtStatusWriteVal(u32);
impl CptraWdtStatusWriteVal {
    /// Timer1 timed out, timer2 enabled
    #[inline(always)]
    pub fn t1_timeout(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
    /// Timer2 timed out
    #[inline(always)]
    pub fn t2_timeout(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
}
impl From<u32> for CptraWdtStatusWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<CptraWdtStatusWriteVal> for u32 {
    #[inline(always)]
    fn from(val: CptraWdtStatusWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ResetRequestReadVal(u32);
impl ResetRequestReadVal {
    /// Request. Writable by Caliptra. Causes MCU interrupt to assert.
    #[inline(always)]
    pub fn req(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Clear. Writable by Caliptra. On set, this bit autoclears, RESET_REQUEST.req clears, and MCU reset deasserts.
    #[inline(always)]
    pub fn clr(&self) -> bool {
        ((self.0 >> 1) & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> ResetRequestWriteVal {
        ResetRequestWriteVal(self.0)
    }
}
impl From<u32> for ResetRequestReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ResetRequestReadVal> for u32 {
    #[inline(always)]
    fn from(val: ResetRequestReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ResetRequestWriteVal(u32);
impl ResetRequestWriteVal {
    /// Request. Writable by Caliptra. Causes MCU interrupt to assert.
    #[inline(always)]
    pub fn req(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
    /// Clear. Writable by Caliptra. On set, this bit autoclears, RESET_REQUEST.req clears, and MCU reset deasserts.
    #[inline(always)]
    pub fn clr(self, val: bool) -> Self {
        Self((self.0 & !(1 << 1)) | (u32::from(val) << 1))
    }
}
impl From<u32> for ResetRequestWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ResetRequestWriteVal> for u32 {
    #[inline(always)]
    fn from(val: ResetRequestWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ResetAckReadVal(u32);
impl ResetAckReadVal {
    /// Ack. Writable by MCU. Causes MCU reset to assert (if RESET_REQUEST.req is also set)
    #[inline(always)]
    pub fn ack(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> ResetAckWriteVal {
        ResetAckWriteVal(self.0)
    }
}
impl From<u32> for ResetAckReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ResetAckReadVal> for u32 {
    #[inline(always)]
    fn from(val: ResetAckReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct ResetAckWriteVal(u32);
impl ResetAckWriteVal {
    /// Ack. Writable by MCU. Causes MCU reset to assert (if RESET_REQUEST.req is also set)
    #[inline(always)]
    pub fn ack(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for ResetAckWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<ResetAckWriteVal> for u32 {
    #[inline(always)]
    fn from(val: ResetAckWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct CaliptraBootGoReadVal(u32);
impl CaliptraBootGoReadVal {
    /// fixme
    #[inline(always)]
    pub fn go(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> CaliptraBootGoWriteVal {
        CaliptraBootGoWriteVal(self.0)
    }
}
impl From<u32> for CaliptraBootGoReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<CaliptraBootGoReadVal> for u32 {
    #[inline(always)]
    fn from(val: CaliptraBootGoReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct CaliptraBootGoWriteVal(u32);
impl CaliptraBootGoWriteVal {
    /// fixme
    #[inline(always)]
    pub fn go(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for CaliptraBootGoWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<CaliptraBootGoWriteVal> for u32 {
    #[inline(always)]
    fn from(val: CaliptraBootGoWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct CaliptraAxiIdReadVal(u32);
impl CaliptraAxiIdReadVal {
    #[inline(always)]
    pub fn id(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> CaliptraAxiIdWriteVal {
        CaliptraAxiIdWriteVal(self.0)
    }
}
impl From<u32> for CaliptraAxiIdReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<CaliptraAxiIdReadVal> for u32 {
    #[inline(always)]
    fn from(val: CaliptraAxiIdReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct CaliptraAxiIdWriteVal(u32);
impl CaliptraAxiIdWriteVal {
    #[inline(always)]
    pub fn id(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for CaliptraAxiIdWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<CaliptraAxiIdWriteVal> for u32 {
    #[inline(always)]
    fn from(val: CaliptraAxiIdWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct FwSramExecRegionSizeReadVal(u32);
impl FwSramExecRegionSizeReadVal {
    /// Size (in multiples of 4KiB)
    #[inline(always)]
    pub fn size(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> FwSramExecRegionSizeWriteVal {
        FwSramExecRegionSizeWriteVal(self.0)
    }
}
impl From<u32> for FwSramExecRegionSizeReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<FwSramExecRegionSizeReadVal> for u32 {
    #[inline(always)]
    fn from(val: FwSramExecRegionSizeReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct FwSramExecRegionSizeWriteVal(u32);
impl FwSramExecRegionSizeWriteVal {
    /// Size (in multiples of 4KiB)
    #[inline(always)]
    pub fn size(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for FwSramExecRegionSizeWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<FwSramExecRegionSizeWriteVal> for u32 {
    #[inline(always)]
    fn from(val: FwSramExecRegionSizeWriteVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct LockReadVal(u32);
impl LockReadVal {
    #[inline(always)]
    pub fn lock(&self) -> bool {
        (self.0 & 1) != 0
    }
    /// Construct a WriteVal that can be used to modify the contents of this register value.
    #[inline(always)]
    pub fn modify(self) -> LockWriteVal {
        LockWriteVal(self.0)
    }
}
impl From<u32> for LockReadVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<LockReadVal> for u32 {
    #[inline(always)]
    fn from(val: LockReadVal) -> u32 {
        val.0
    }
}
#[derive(Clone, Copy, Default)]
pub struct LockWriteVal(u32);
impl LockWriteVal {
    #[inline(always)]
    pub fn lock(self, val: bool) -> Self {
        Self((self.0 & !(1)) | (u32::from(val)))
    }
}
impl From<u32> for LockWriteVal {
    #[inline(always)]
    fn from(val: u32) -> Self {
        Self(val)
    }
}
impl From<LockWriteVal> for u32 {
    #[inline(always)]
    fn from(val: LockWriteVal) -> u32 {
        val.0
    }
}
pub mod enums {
    //! Enumerations used by some register fields.
    pub mod selector {}
}
pub trait MciPeripheral {
    fn poll(&mut self) {}
    fn warm_reset(&mut self) {}
    fn update_reset(&mut self) {}
    fn read_capabilities(&mut self) -> CapabilitiesWriteVal {
        CapabilitiesWriteVal::default()
    }
    fn write_capabilities(&mut self, _val: CapabilitiesReadVal) {}
    fn read_hw_rev_id(&mut self) -> HwRevIdWriteVal {
        HwRevIdWriteVal::default()
    }
    fn write_hw_rev_id(&mut self, _val: HwRevIdReadVal) {}
    fn read_rom_rev_id(&mut self) -> u32 {
        0
    }
    fn write_rom_rev_id(&mut self, _val: u32) {}
    fn read_fw_rev_id(&mut self) -> u32 {
        0
    }
    fn write_fw_rev_id(&mut self, _val: u32) {}
    fn read_boot_status(&mut self) -> u32 {
        0
    }
    fn write_boot_status(&mut self, _val: u32) {}
    fn read_flow_status(&mut self) -> FlowStatusWriteVal {
        FlowStatusWriteVal::default()
    }
    fn write_flow_status(&mut self, _val: FlowStatusReadVal) {}
    fn read_reset_reason(&mut self) -> ResetReasonWriteVal {
        ResetReasonWriteVal::default()
    }
    fn write_reset_reason(&mut self, _val: ResetReasonReadVal) {}
    fn read_hw_error_fatal(&mut self) -> HwErrorWriteVal {
        HwErrorWriteVal::default()
    }
    fn write_hw_error_fatal(&mut self, _val: HwErrorReadVal) {}
    fn read_hw_error_non_fatal(&mut self) -> HwErrorWriteVal {
        HwErrorWriteVal::default()
    }
    fn write_hw_error_non_fatal(&mut self, _val: HwErrorReadVal) {}
    fn read_fw_error_fatal(&mut self) -> u32 {
        0
    }
    fn write_fw_error_fatal(&mut self, _val: u32) {}
    fn read_fw_error_non_fatal(&mut self) -> u32 {
        0
    }
    fn write_fw_error_non_fatal(&mut self, _val: u32) {}
    fn read_wdt_timer1_en(&mut self) -> WdtTimer1EnWriteVal {
        WdtTimer1EnWriteVal::default()
    }
    fn write_wdt_timer1_en(&mut self, _val: WdtTimer1EnReadVal) {}
    fn read_wdt_timer1_ctrl(&mut self) -> WdtTimer1CtrlWriteVal {
        WdtTimer1CtrlWriteVal::default()
    }
    fn write_wdt_timer1_ctrl(&mut self, _val: WdtTimer1CtrlReadVal) {}
    fn read_wdt_timer1_timeout_period(&mut self) -> u32 {
        0
    }
    fn write_wdt_timer1_timeout_period(&mut self, _val: u32) {}
    fn read_wdt_timer2_en(&mut self) -> WdtTimer2EnWriteVal {
        WdtTimer2EnWriteVal::default()
    }
    fn write_wdt_timer2_en(&mut self, _val: WdtTimer2EnReadVal) {}
    fn read_wdt_timer2_ctrl(&mut self) -> WdtTimer2CtrlWriteVal {
        WdtTimer2CtrlWriteVal::default()
    }
    fn write_wdt_timer2_ctrl(&mut self, _val: WdtTimer2CtrlReadVal) {}
    fn read_wdt_timer2_timeout_period(&mut self) -> u32 {
        0
    }
    fn write_wdt_timer2_timeout_period(&mut self, _val: u32) {}
    fn read_cptra_wdt_status(&mut self) -> CptraWdtStatusWriteVal {
        CptraWdtStatusWriteVal::default()
    }
    fn write_cptra_wdt_status(&mut self, _val: CptraWdtStatusReadVal) {}
    fn read_wdt_cfg(&mut self) -> u32 {
        0
    }
    fn write_wdt_cfg(&mut self, _val: u32) {}
    fn read_mcu_timer_config(&mut self) -> u32 {
        0
    }
    fn write_mcu_timer_config(&mut self, _val: u32) {}
    fn read_reset_request(&mut self) -> ResetRequestWriteVal {
        ResetRequestWriteVal::default()
    }
    fn write_reset_request(&mut self, _val: ResetRequestReadVal) {}
    fn read_reset_ack(&mut self) -> ResetAckWriteVal {
        ResetAckWriteVal::default()
    }
    fn write_reset_ack(&mut self, _val: ResetAckReadVal) {}
    fn read_caliptra_boot_go(&mut self) -> CaliptraBootGoWriteVal {
        CaliptraBootGoWriteVal::default()
    }
    fn write_caliptra_boot_go(&mut self, _val: CaliptraBootGoReadVal) {}
    fn read_caliptra_axi_id(&mut self) -> CaliptraAxiIdWriteVal {
        CaliptraAxiIdWriteVal::default()
    }
    fn write_caliptra_axi_id(&mut self, _val: CaliptraAxiIdReadVal) {}
    fn read_fw_sram_exec_region_size(&mut self) -> FwSramExecRegionSizeWriteVal {
        FwSramExecRegionSizeWriteVal::default()
    }
    fn write_fw_sram_exec_region_size(&mut self, _val: FwSramExecRegionSizeReadVal) {}
    fn read_runtime_lock(&mut self) -> LockWriteVal {
        LockWriteVal::default()
    }
    fn write_runtime_lock(&mut self, _val: LockReadVal) {}
    fn read_mbox0_valid_axi_id(&mut self) -> u32 {
        0
    }
    fn write_mbox0_valid_axi_id(&mut self, _val: u32) {}
    fn read_mbox0_valid_axi_id_lock(&mut self) -> LockWriteVal {
        LockWriteVal::default()
    }
    fn write_mbox0_valid_axi_id_lock(&mut self, _val: LockReadVal) {}
    fn read_mbox1_valid_axi_id(&mut self) -> u32 {
        0
    }
    fn write_mbox1_valid_axi_id(&mut self, _val: u32) {}
    fn read_mbox1_valid_axi_id_lock(&mut self) -> LockWriteVal {
        LockWriteVal::default()
    }
    fn write_mbox1_valid_axi_id_lock(&mut self, _val: LockReadVal) {}
    fn read_generic_input_wires(&mut self) -> u32 {
        0
    }
    fn write_generic_input_wires(&mut self, _val: u32) {}
    fn read_generic_output_wires(&mut self) -> u32 {
        0
    }
    fn write_generic_output_wires(&mut self, _val: u32) {}
    fn read_rsvd_rw_reg(&mut self) -> u32 {
        0
    }
    fn write_rsvd_rw_reg(&mut self, _val: u32) {}
    fn read_rsvd_rw_s_reg(&mut self) -> u32 {
        0
    }
    fn write_rsvd_rw_s_reg(&mut self, _val: u32) {}
    fn read_rsvd_cptra_rw_reg(&mut self) -> u32 {
        0
    }
    fn write_rsvd_cptra_rw_reg(&mut self, _val: u32) {}
    fn read_rsvd_cptra_rw_s_reg(&mut self) -> u32 {
        0
    }
    fn write_rsvd_cptra_rw_s_reg(&mut self, _val: u32) {}
    fn read_rsvd_mcu_rw_reg(&mut self) -> u32 {
        0
    }
    fn write_rsvd_mcu_rw_reg(&mut self, _val: u32) {}
    fn read_rsvd_mcu_rw_s_reg(&mut self) -> u32 {
        0
    }
    fn write_rsvd_mcu_rw_s_reg(&mut self, _val: u32) {}
    fn read_rsvd_rw_l_reg(&mut self) -> u32 {
        0
    }
    fn write_rsvd_rw_l_reg(&mut self, _val: u32) {}
    fn read_rsvd_rw_l_reg_lock(&mut self) -> u32 {
        0
    }
    fn write_rsvd_rw_l_reg_lock(&mut self, _val: u32) {}
    fn read_rsvd_rw_l_s_reg(&mut self) -> u32 {
        0
    }
    fn write_rsvd_rw_l_s_reg(&mut self, _val: u32) {}
    fn read_rsvd_rw_l_s_reg_lock(&mut self) -> u32 {
        0
    }
    fn write_rsvd_rw_l_s_reg_lock(&mut self, _val: u32) {}
}
pub struct MciBus {
    pub periph: Box<dyn MciPeripheral>,
}
impl emulator_bus::Bus for MciBus {
    fn read(
        &mut self,
        size: emulator_types::RvSize,
        addr: emulator_types::RvAddr,
    ) -> Result<emulator_types::RvData, emulator_bus::BusError> {
        match (size, addr) {
            (emulator_types::RvSize::Word, 0) => Ok(emulator_types::RvData::from(
                self.periph.read_capabilities(),
            )),
            (emulator_types::RvSize::Word, 1..=3) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 4) => {
                Ok(emulator_types::RvData::from(self.periph.read_hw_rev_id()))
            }
            (emulator_types::RvSize::Word, 5..=7) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 8) => {
                Ok(emulator_types::RvData::from(self.periph.read_rom_rev_id()))
            }
            (emulator_types::RvSize::Word, 9..=0xb) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0xc) => {
                Ok(emulator_types::RvData::from(self.periph.read_fw_rev_id()))
            }
            (emulator_types::RvSize::Word, 0xd..=0xf) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x20) => {
                Ok(emulator_types::RvData::from(self.periph.read_boot_status()))
            }
            (emulator_types::RvSize::Word, 0x21..=0x23) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x24) => {
                Ok(emulator_types::RvData::from(self.periph.read_flow_status()))
            }
            (emulator_types::RvSize::Word, 0x25..=0x27) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x28) => Ok(emulator_types::RvData::from(
                self.periph.read_reset_reason(),
            )),
            (emulator_types::RvSize::Word, 0x29..=0x2b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x40) => Ok(emulator_types::RvData::from(
                self.periph.read_hw_error_fatal(),
            )),
            (emulator_types::RvSize::Word, 0x41..=0x43) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x44) => Ok(emulator_types::RvData::from(
                self.periph.read_hw_error_non_fatal(),
            )),
            (emulator_types::RvSize::Word, 0x45..=0x47) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x48) => Ok(emulator_types::RvData::from(
                self.periph.read_fw_error_fatal(),
            )),
            (emulator_types::RvSize::Word, 0x49..=0x4b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x4c) => Ok(emulator_types::RvData::from(
                self.periph.read_fw_error_non_fatal(),
            )),
            (emulator_types::RvSize::Word, 0x4d..=0x4f) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x80) => Ok(emulator_types::RvData::from(
                self.periph.read_wdt_timer1_en(),
            )),
            (emulator_types::RvSize::Word, 0x81..=0x83) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x84) => Ok(emulator_types::RvData::from(
                self.periph.read_wdt_timer1_ctrl(),
            )),
            (emulator_types::RvSize::Word, 0x85..=0x87) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x88) => Ok(emulator_types::RvData::from(
                self.periph.read_wdt_timer1_timeout_period(),
            )),
            (emulator_types::RvSize::Word, 0x89..=0x8b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x90) => Ok(emulator_types::RvData::from(
                self.periph.read_wdt_timer2_en(),
            )),
            (emulator_types::RvSize::Word, 0x91..=0x93) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x94) => Ok(emulator_types::RvData::from(
                self.periph.read_wdt_timer2_ctrl(),
            )),
            (emulator_types::RvSize::Word, 0x95..=0x97) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x98) => Ok(emulator_types::RvData::from(
                self.periph.read_wdt_timer2_timeout_period(),
            )),
            (emulator_types::RvSize::Word, 0x99..=0x9b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0xa0) => Ok(emulator_types::RvData::from(
                self.periph.read_cptra_wdt_status(),
            )),
            (emulator_types::RvSize::Word, 0xa1..=0xa3) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0xb0) => {
                Ok(emulator_types::RvData::from(self.periph.read_wdt_cfg()))
            }
            (emulator_types::RvSize::Word, 0xb1..=0xb3) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0xc0) => Ok(emulator_types::RvData::from(
                self.periph.read_mcu_timer_config(),
            )),
            (emulator_types::RvSize::Word, 0xc1..=0xc3) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x100) => Ok(emulator_types::RvData::from(
                self.periph.read_reset_request(),
            )),
            (emulator_types::RvSize::Word, 0x101..=0x103) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x104) => {
                Ok(emulator_types::RvData::from(self.periph.read_reset_ack()))
            }
            (emulator_types::RvSize::Word, 0x105..=0x107) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x108) => Ok(emulator_types::RvData::from(
                self.periph.read_caliptra_boot_go(),
            )),
            (emulator_types::RvSize::Word, 0x109..=0x10b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x10c) => Ok(emulator_types::RvData::from(
                self.periph.read_caliptra_axi_id(),
            )),
            (emulator_types::RvSize::Word, 0x10d..=0x10f) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x110) => Ok(emulator_types::RvData::from(
                self.periph.read_fw_sram_exec_region_size(),
            )),
            (emulator_types::RvSize::Word, 0x111..=0x113) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x114) => Ok(emulator_types::RvData::from(
                self.periph.read_runtime_lock(),
            )),
            (emulator_types::RvSize::Word, 0x115..=0x117) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x180) => Ok(emulator_types::RvData::from(
                self.periph.read_mbox0_valid_axi_id(),
            )),
            (emulator_types::RvSize::Word, 0x181..=0x183) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1a0) => Ok(emulator_types::RvData::from(
                self.periph.read_mbox0_valid_axi_id_lock(),
            )),
            (emulator_types::RvSize::Word, 0x1a1..=0x1a3) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1c0) => Ok(emulator_types::RvData::from(
                self.periph.read_mbox1_valid_axi_id(),
            )),
            (emulator_types::RvSize::Word, 0x1c1..=0x1c3) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1e0) => Ok(emulator_types::RvData::from(
                self.periph.read_mbox1_valid_axi_id_lock(),
            )),
            (emulator_types::RvSize::Word, 0x1e1..=0x1e3) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x408) => Ok(emulator_types::RvData::from(
                self.periph.read_generic_output_wires(),
            )),
            (emulator_types::RvSize::Word, 0x409..=0x40b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x410) => {
                Ok(emulator_types::RvData::from(self.periph.read_rsvd_rw_reg()))
            }
            (emulator_types::RvSize::Word, 0x411..=0x413) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x418) => Ok(emulator_types::RvData::from(
                self.periph.read_rsvd_rw_s_reg(),
            )),
            (emulator_types::RvSize::Word, 0x419..=0x41b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x420) => Ok(emulator_types::RvData::from(
                self.periph.read_rsvd_cptra_rw_reg(),
            )),
            (emulator_types::RvSize::Word, 0x421..=0x423) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x428) => Ok(emulator_types::RvData::from(
                self.periph.read_rsvd_cptra_rw_s_reg(),
            )),
            (emulator_types::RvSize::Word, 0x429..=0x42b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x430) => Ok(emulator_types::RvData::from(
                self.periph.read_rsvd_mcu_rw_reg(),
            )),
            (emulator_types::RvSize::Word, 0x431..=0x433) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x438) => Ok(emulator_types::RvData::from(
                self.periph.read_rsvd_mcu_rw_s_reg(),
            )),
            (emulator_types::RvSize::Word, 0x439..=0x43b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x440) => Ok(emulator_types::RvData::from(
                self.periph.read_rsvd_rw_l_reg(),
            )),
            (emulator_types::RvSize::Word, 0x441..=0x443) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x448) => Ok(emulator_types::RvData::from(
                self.periph.read_rsvd_rw_l_reg_lock(),
            )),
            (emulator_types::RvSize::Word, 0x449..=0x44b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x450) => Ok(emulator_types::RvData::from(
                self.periph.read_rsvd_rw_l_s_reg(),
            )),
            (emulator_types::RvSize::Word, 0x451..=0x453) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x458) => Ok(emulator_types::RvData::from(
                self.periph.read_rsvd_rw_l_s_reg_lock(),
            )),
            (emulator_types::RvSize::Word, 0x459..=0x45b) => {
                Err(emulator_bus::BusError::LoadAddrMisaligned)
            }
            _ => Err(emulator_bus::BusError::LoadAccessFault),
        }
    }
    fn write(
        &mut self,
        size: emulator_types::RvSize,
        addr: emulator_types::RvAddr,
        val: emulator_types::RvData,
    ) -> Result<(), emulator_bus::BusError> {
        match (size, addr) {
            (emulator_types::RvSize::Word, 0) => {
                self.periph
                    .write_capabilities(CapabilitiesReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 1..=3) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 4) => {
                self.periph.write_hw_rev_id(HwRevIdReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 5..=7) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 8) => {
                self.periph.write_rom_rev_id(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 9..=0xb) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0xc) => {
                self.periph.write_fw_rev_id(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0xd..=0xf) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x20) => {
                self.periph.write_boot_status(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x21..=0x23) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x24) => {
                self.periph.write_flow_status(FlowStatusReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x25..=0x27) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x28) => {
                self.periph
                    .write_reset_reason(ResetReasonReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x29..=0x2b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x40) => {
                self.periph.write_hw_error_fatal(HwErrorReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x41..=0x43) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x44) => {
                self.periph
                    .write_hw_error_non_fatal(HwErrorReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x45..=0x47) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x48) => {
                self.periph.write_fw_error_fatal(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x49..=0x4b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x4c) => {
                self.periph.write_fw_error_non_fatal(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x4d..=0x4f) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x80) => {
                self.periph
                    .write_wdt_timer1_en(WdtTimer1EnReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x81..=0x83) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x84) => {
                self.periph
                    .write_wdt_timer1_ctrl(WdtTimer1CtrlReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x85..=0x87) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x88) => {
                self.periph.write_wdt_timer1_timeout_period(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x89..=0x8b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x90) => {
                self.periph
                    .write_wdt_timer2_en(WdtTimer2EnReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x91..=0x93) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x94) => {
                self.periph
                    .write_wdt_timer2_ctrl(WdtTimer2CtrlReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x95..=0x97) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x98) => {
                self.periph.write_wdt_timer2_timeout_period(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x99..=0x9b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0xa0) => {
                self.periph
                    .write_cptra_wdt_status(CptraWdtStatusReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0xa1..=0xa3) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0xb0) => {
                self.periph.write_wdt_cfg(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0xb1..=0xb3) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0xc0) => {
                self.periph.write_mcu_timer_config(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0xc1..=0xc3) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x100) => {
                self.periph
                    .write_reset_request(ResetRequestReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x101..=0x103) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x104) => {
                self.periph.write_reset_ack(ResetAckReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x105..=0x107) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x108) => {
                self.periph
                    .write_caliptra_boot_go(CaliptraBootGoReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x109..=0x10b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x10c) => {
                self.periph
                    .write_caliptra_axi_id(CaliptraAxiIdReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x10d..=0x10f) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x110) => {
                self.periph
                    .write_fw_sram_exec_region_size(FwSramExecRegionSizeReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x111..=0x113) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x114) => {
                self.periph.write_runtime_lock(LockReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x115..=0x117) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x180) => {
                self.periph.write_mbox0_valid_axi_id(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x181..=0x183) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1a0) => {
                self.periph
                    .write_mbox0_valid_axi_id_lock(LockReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x1a1..=0x1a3) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1c0) => {
                self.periph.write_mbox1_valid_axi_id(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x1c1..=0x1c3) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x1e0) => {
                self.periph
                    .write_mbox1_valid_axi_id_lock(LockReadVal::from(val));
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x1e1..=0x1e3) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x400) => {
                self.periph.write_generic_input_wires(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x401..=0x403) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x408) => {
                self.periph.write_generic_output_wires(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x409..=0x40b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x410) => {
                self.periph.write_rsvd_rw_reg(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x411..=0x413) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x418) => {
                self.periph.write_rsvd_rw_s_reg(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x419..=0x41b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x420) => {
                self.periph.write_rsvd_cptra_rw_reg(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x421..=0x423) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x428) => {
                self.periph.write_rsvd_cptra_rw_s_reg(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x429..=0x42b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x430) => {
                self.periph.write_rsvd_mcu_rw_reg(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x431..=0x433) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x438) => {
                self.periph.write_rsvd_mcu_rw_s_reg(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x439..=0x43b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x440) => {
                self.periph.write_rsvd_rw_l_reg(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x441..=0x443) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x448) => {
                self.periph.write_rsvd_rw_l_reg_lock(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x449..=0x44b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x450) => {
                self.periph.write_rsvd_rw_l_s_reg(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x451..=0x453) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            (emulator_types::RvSize::Word, 0x458) => {
                self.periph.write_rsvd_rw_l_s_reg_lock(val);
                Ok(())
            }
            (emulator_types::RvSize::Word, 0x459..=0x45b) => {
                Err(emulator_bus::BusError::StoreAddrMisaligned)
            }
            _ => Err(emulator_bus::BusError::StoreAccessFault),
        }
    }
    fn poll(&mut self) {
        self.periph.poll();
    }
    fn warm_reset(&mut self) {
        self.periph.warm_reset();
    }
    fn update_reset(&mut self) {
        self.periph.update_reset();
    }
}
