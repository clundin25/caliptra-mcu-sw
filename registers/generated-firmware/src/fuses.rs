// Licensed under the Apache-2.0 license.
//
// generated by registers_generator with otp_ctrl_mmap.hjson
use zeroize::Zeroize;
/// Fuses contains the data in the OTP controller laid out as described in the controller configuration.
#[derive(Zeroize)]
pub struct Fuses {
    /// Vendor test partition.
    /// This is reserved for manufacturing smoke checks. The OTP wrapper
    /// control logic inside prim_otp is allowed to read/write to this
    /// region. ECC uncorrectable errors seen on the functional prim_otp
    /// interface will not lead to an alert for this partition.
    /// Instead, such errors will be reported as correctable ECC errors.
    #[zeroize(skip)]
    pub vendor_test: [u32; 16],

    /// Non Secret Fuses partition.
    /// This contains data such IDEVID, public key hash mask, owner
    /// key hash, SoC Stepping ID etc.
    #[zeroize(skip)]
    pub non_secret_fuses: [u32; 51],

    /// Secret partition 0.
    /// This contains TEST lifecycle unlock tokens.
    pub secret0: [u32; 10],

    /// Secret partition 1.
    /// This contains Obfuscated UDS seed.
    pub secret1: [u32; 14],

    /// Secret partition 2.
    /// This contains obfuscated field entropy.
    pub secret2: [u32; 10],

    /// Secret partition 3.
    /// This contains public key hash and RMA unlock token.
    pub secret3: [u32; 18],

    /// Lifecycle partition.
    /// This contains lifecycle transition count and state. This partition
    /// cannot be locked since the life cycle state needs to advance to RMA
    /// in-field. Note that while this partition is not marked secret, it
    /// is not readable nor writeable via the DAI. Only the LC controller
    /// can access this partition, and even via the LC controller it is not
    /// possible to read the raw manufacturing life cycle state in encoded
    /// form, since that encoding is considered a netlist secret. The LC
    /// controller only exposes a decoded version of this state.
    #[zeroize(skip)]
    pub life_cycle: [u32; 22],
}
impl Fuses {
    pub fn scratch(&self) -> &[u32] {
        &self.vendor_test[0..14]
    }
    pub fn fmc_key_manifest_svn(&self) -> u32 {
        self.non_secret_fuses[0]
    }
    pub fn runtime_svn(&self) -> &[u32] {
        &self.non_secret_fuses[1..5]
    }
    pub fn lms_verify(&self) -> u32 {
        self.non_secret_fuses[5]
    }
    pub fn lms_revocation(&self) -> u32 {
        self.non_secret_fuses[6]
    }
    pub fn key_manifest_pk_hash_mask(&self) -> u32 {
        self.non_secret_fuses[7]
    }
    pub fn owner_pk_hash(&self) -> &[u32] {
        &self.non_secret_fuses[8..20]
    }
    pub fn idevid_cert_attr(&self) -> &[u32] {
        &self.non_secret_fuses[20..44]
    }
    pub fn idevid_manuf_hsm_id(&self) -> &[u32] {
        &self.non_secret_fuses[44..48]
    }
    pub fn soc_stepping_id(&self) -> u32 {
        self.non_secret_fuses[48]
    }
    pub fn test_unlock_token(&self) -> &[u32] {
        &self.secret0[0..4]
    }
    pub fn test_exit_token(&self) -> &[u32] {
        &self.secret0[4..8]
    }
    pub fn uds_seed(&self) -> &[u32] {
        &self.secret1[0..12]
    }
    pub fn field_entropy(&self) -> &[u32] {
        &self.secret2[0..8]
    }
    pub fn key_manifest_pk_hash(&self) -> &[u32] {
        &self.secret3[0..12]
    }
    pub fn rma_token(&self) -> &[u32] {
        &self.secret3[12..16]
    }
    pub fn lc_transition_cnt(&self) -> &[u32] {
        &self.life_cycle[0..12]
    }
    pub fn lc_state(&self) -> &[u32] {
        &self.life_cycle[12..22]
    }
}
impl Default for Fuses {
    fn default() -> Self {
        Self {
            vendor_test: [0; 16],
            non_secret_fuses: [0; 51],
            secret0: [0; 10],
            secret1: [0; 14],
            secret2: [0; 10],
            secret3: [0; 18],
            life_cycle: [0; 22],
        }
    }
}
pub const VENDOR_TEST_WORD_OFFSET: usize = 0;
pub const VENDOR_TEST_WORD_SIZE: usize = 16;
pub const NON_SECRET_FUSES_WORD_OFFSET: usize = 16;
pub const NON_SECRET_FUSES_WORD_SIZE: usize = 51;
pub const SECRET0_WORD_OFFSET: usize = 67;
pub const SECRET0_WORD_SIZE: usize = 10;
pub const SECRET1_WORD_OFFSET: usize = 77;
pub const SECRET1_WORD_SIZE: usize = 14;
pub const SECRET2_WORD_OFFSET: usize = 91;
pub const SECRET2_WORD_SIZE: usize = 10;
pub const SECRET3_WORD_OFFSET: usize = 101;
pub const SECRET3_WORD_SIZE: usize = 18;
pub const LIFE_CYCLE_WORD_OFFSET: usize = 119;
pub const LIFE_CYCLE_WORD_SIZE: usize = 22;
