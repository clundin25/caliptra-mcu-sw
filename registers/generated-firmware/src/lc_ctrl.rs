// Licensed under the Apache-2.0 license.
//
// generated by registers_generator with caliptra-ss repo at 4f006115433f926f4e599bc8718a39168f70ce5f
//
//
// Warning: caliptra-ss was dirty: M third_party/caliptra-rtl
// M third_party/i3c-core
//
pub const LC_CTRL_ADDR: u32 = 0x7000_0400;
pub mod bits {
    //! Types that represent individual registers (bitfields).
    use tock_registers::register_bitfields;
    register_bitfields! {
        u32,
            pub AlertTest [
                /// Write 1 to trigger one alert event of this kind.
                FatalProgError OFFSET(0) NUMBITS(1) [],
                /// Write 1 to trigger one alert event of this kind.
                FatalStateError OFFSET(1) NUMBITS(1) [],
                /// Write 1 to trigger one alert event of this kind.
                FatalBusIntegError OFFSET(2) NUMBITS(1) [],
            ],
            pub ClaimTransitionIf [
                /// Mutex
                Mutex OFFSET(0) NUMBITS(8) [],
            ],
            pub ClaimTransitionIfRegwen [
                /// This bit is managed by software and is set to 1 by default. When cleared to 0, the CLAIM_TRANSITION_IF mutex register cannot be written to anymore. Write 0 to clear this bit.
                Regwen OFFSET(0) NUMBITS(1) [],
            ],
            pub HwRevision0 [
                /// Used to identify a class of devices. Assigned by the Silicon Creator. Zero is an invalid value.
                ProductId OFFSET(0) NUMBITS(16) [],
                /// ID of the silicon creator. Assigned by the OpenTitan project. Zero is an invalid value.
                SiliconCreatorId OFFSET(16) NUMBITS(16) [],
            ],
            pub HwRevision1 [
                /// Product revision ID. Assigned by the Silicon Creator. The encoding is not specified other than that different tapeouts must be assigned different revision numbers. I.e., each base or metal layer respin must be reflected so that software can rely on it to modify firmware and driver behavior. Zero is an invalid value.
                RevisionId OFFSET(0) NUMBITS(8) [],
                /// Reserved bits. Set to zero.
                Reserved OFFSET(8) NUMBITS(24) [],
            ],
            pub LcState [
                /// OT vendor test control
                State OFFSET(0) NUMBITS(30) [],
            ],
            pub LcTransitionCnt [
                /// OT vendor test control
                Cnt OFFSET(0) NUMBITS(5) [],
            ],
            pub Status [
                /// This bit is set to 1 if the life cycle controller has successfully initialized and the state exposed in LC_STATE and LC_TRANSITION_CNT is valid.
                Initialized OFFSET(0) NUMBITS(1) [],
                /// This bit is set to 1 if the life cycle controller has successfully initialized and is ready to accept a life cycle transition command.
                Ready OFFSET(1) NUMBITS(1) [],
                /// This bit is set to 1 if the clock manager has successfully switched to the external clock due to EXT_CLOCK_EN being set to 1.
                ExtClockSwitched OFFSET(2) NUMBITS(1) [],
                /// This bit is set to 1 if the last life cycle transition request was successful. Note that each transition attempt increments the LC_TRANSITION_CNT and moves the life cycle state into POST_TRANSITION.
                TransitionSuccessful OFFSET(3) NUMBITS(1) [],
                /// This bit is set to 1 if the LC_TRANSITION_CNT has reached its maximum. If this is the case, no more state transitions can be performed. Note that each transition attempt increments the LC_TRANSITION_CNT and moves the life cycle state into POST_TRANSITION.
                TransitionCountError OFFSET(4) NUMBITS(1) [],
                /// This bit is set to 1 if the last transition command requested an invalid state transition (e.g. DEV -> RAW). Note that each transition attempt increments the LC_TRANSITION_CNT and moves the life cycle state into POST_TRANSITION.
                TransitionError OFFSET(5) NUMBITS(1) [],
                /// This bit is set to 1 if the token supplied for a conditional transition was invalid. Note that each transition attempt increments the LC_TRANSITION_CNT and moves the life cycle state into POST_TRANSITION.
                TokenError OFFSET(6) NUMBITS(1) [],
                /// This bit is set to 1 if flash failed to correctly respond to an RMA request. Note that each transition attempt increments the LC_TRANSITION_CNT and moves the life cycle state into POST_TRANSITION.
                FlashRmaError OFFSET(7) NUMBITS(1) [],
                /// This bit is set to 1 if an error occurred during an OTP programming operation. This error will move the life cycle state automatically to POST_TRANSITION and raise a fatal_prog_error alert.
                OtpError OFFSET(8) NUMBITS(1) [],
                /// This bit is set to 1 if either the controller FSM state or the life cycle state is invalid or has been corrupted as part of a tampering attempt. This error will move the life cycle state automatically to INVALID and raise a fatal_state_error alert.
                StateError OFFSET(9) NUMBITS(1) [],
                /// This bit is set to 1 if a fatal bus integrity fault is detected. This error triggers a fatal_bus_integ_error alert.
                BusIntegError OFFSET(10) NUMBITS(1) [],
                /// This bit is set to 1 if the life cycle partition in OTP is in error state. This bit is intended for production testing during the RAW life cycle state, where the OTP control and status registers are not accessible. This error does not trigger an alert in the life cycle controller.
                OtpPartitionError OFFSET(11) NUMBITS(1) [],
            ],
            pub TransitionCmd [
                /// Start
                Start OFFSET(0) NUMBITS(1) [],
            ],
            pub TransitionCtrl [
                /// When set to 1, the OTP clock will be switched to an externally supplied clock right away when the device is in a non-PROD life cycle state. The clock mux will remain switched until the next system reset.
                ExtClockEn OFFSET(0) NUMBITS(1) [],
                /// Volatile raw unlock
                VolatileRawUnlock OFFSET(1) NUMBITS(1) [],
            ],
            pub TransitionRegwen [
                /// This bit is managed by software and is set to 1 by default. When cleared to 0, the CLAIM_TRANSITION_IF mutex register cannot be written to anymore. Write 0 to clear this bit.
                Regwen OFFSET(0) NUMBITS(1) [],
            ],
            pub TransitionTarget [
                /// This field encodes the target life cycle state in a redundant enum format. The 5bit state enum is repeated 6x so that it fills the entire 32bit register. The encoding is straightforward replication: [val, val, val, val, val, val].
                State OFFSET(0) NUMBITS(30) [],
            ],
    }
}
pub mod regs {
    //! Types that represent registers.
    use tock_registers::register_structs;
    register_structs! {
        pub LcCtrl {
            (0x0 => pub alert_test: tock_registers::registers::WriteOnly<u32, crate::lc_ctrl::bits::AlertTest::Register>),
            (0x4 => pub status: tock_registers::registers::ReadOnly<u32, crate::lc_ctrl::bits::Status::Register>),
            (0x8 => pub claim_transition_if_regwen: tock_registers::registers::ReadWrite<u32, crate::lc_ctrl::bits::ClaimTransitionIfRegwen::Register>),
            (0xc => pub claim_transition_if: tock_registers::registers::ReadWrite<u32, crate::lc_ctrl::bits::ClaimTransitionIf::Register>),
            (0x10 => pub transition_regwen: tock_registers::registers::ReadOnly<u32, crate::lc_ctrl::bits::TransitionRegwen::Register>),
            (0x14 => pub transition_cmd: tock_registers::registers::ReadWrite<u32, crate::lc_ctrl::bits::TransitionCmd::Register>),
            (0x18 => pub transition_ctrl: tock_registers::registers::ReadWrite<u32, crate::lc_ctrl::bits::TransitionCtrl::Register>),
            (0x1c => pub transition_token_0: tock_registers::registers::ReadWrite<u32>),
            (0x20 => pub transition_token_1: tock_registers::registers::ReadWrite<u32>),
            (0x24 => pub transition_token_2: tock_registers::registers::ReadWrite<u32>),
            (0x28 => pub transition_token_3: tock_registers::registers::ReadWrite<u32>),
            (0x2c => pub transition_target: tock_registers::registers::ReadWrite<u32, crate::lc_ctrl::bits::TransitionTarget::Register>),
            (0x30 => pub otp_vendor_test_ctrl: tock_registers::registers::ReadWrite<u32>),
            (0x34 => pub otp_vendor_test_status: tock_registers::registers::ReadOnly<u32>),
            (0x38 => pub lc_state: tock_registers::registers::ReadOnly<u32, crate::lc_ctrl::bits::LcState::Register>),
            (0x3c => pub lc_transition_cnt: tock_registers::registers::ReadOnly<u32, crate::lc_ctrl::bits::LcTransitionCnt::Register>),
            (0x40 => pub lc_id_state: tock_registers::registers::ReadOnly<u32>),
            (0x44 => pub hw_revision0: tock_registers::registers::ReadOnly<u32, crate::lc_ctrl::bits::HwRevision0::Register>),
            (0x48 => pub hw_revision1: tock_registers::registers::ReadOnly<u32, crate::lc_ctrl::bits::HwRevision1::Register>),
            (0x4c => pub device_id_0: tock_registers::registers::ReadOnly<u32>),
            (0x50 => pub device_id_1: tock_registers::registers::ReadOnly<u32>),
            (0x54 => pub device_id_2: tock_registers::registers::ReadOnly<u32>),
            (0x58 => pub device_id_3: tock_registers::registers::ReadOnly<u32>),
            (0x5c => pub device_id_4: tock_registers::registers::ReadOnly<u32>),
            (0x60 => pub device_id_5: tock_registers::registers::ReadOnly<u32>),
            (0x64 => pub device_id_6: tock_registers::registers::ReadOnly<u32>),
            (0x68 => pub device_id_7: tock_registers::registers::ReadOnly<u32>),
            (0x6c => pub manuf_state_0: tock_registers::registers::ReadOnly<u32>),
            (0x70 => pub manuf_state_1: tock_registers::registers::ReadOnly<u32>),
            (0x74 => pub manuf_state_2: tock_registers::registers::ReadOnly<u32>),
            (0x78 => pub manuf_state_3: tock_registers::registers::ReadOnly<u32>),
            (0x7c => pub manuf_state_4: tock_registers::registers::ReadOnly<u32>),
            (0x80 => pub manuf_state_5: tock_registers::registers::ReadOnly<u32>),
            (0x84 => pub manuf_state_6: tock_registers::registers::ReadOnly<u32>),
            (0x88 => pub manuf_state_7: tock_registers::registers::ReadOnly<u32>),
            (0x8c => @END),
        }
    }
}
