// Licensed under the Apache-2.0 license.
//
// generated by registers_generator with caliptra-ss repo at 4f006115433f926f4e599bc8718a39168f70ce5f
//
//
// Warning: caliptra-ss was dirty: M third_party/caliptra-rtl
// M third_party/i3c-core
//
pub const MAIN_FLASH_CTRL_ADDR: u32 = 0x2000_8000;
pub mod bits {
    //! Types that represent individual registers (bitfields).
    use tock_registers::register_bitfields;
    register_bitfields! {
        u32,
            pub CtrlRegwen [
                /// This register ensures the contents of OP_CONTROL cannot be changed by software once a flash operation has begun. \
                /// This bit defaults to 1 and is set to 0 by hardware when flash operation is initiated. When the controller completes the flash operation, \
                /// It unlocks whenever the existing flash operation completes, regardless of success or error.
                En OFFSET(0) NUMBITS(1) [],
            ],
            pub FlControl [
                /// "0" = Read page , "1" = Write Page, "2" Erase Page
                Op OFFSET(1) NUMBITS(2) [],
                /// Start the operation
                Start OFFSET(0) NUMBITS(1) [],
            ],
            pub FlInterruptEnable [
                /// Enable error interrupt
                Error OFFSET(0) NUMBITS(1) [],
                /// Enable event interrupt
                Event OFFSET(1) NUMBITS(1) [],
            ],
            pub FlInterruptState [
                /// Error-related interrupts
                Error OFFSET(0) NUMBITS(1) [],
                /// Event-related interrupts
                Event OFFSET(1) NUMBITS(1) [],
            ],
            pub OpStatus [
                /// Flash operation error. Set by HW, cleared by SW .
                /// "0" = Read Error , "1" = Write Error, "2" Erase Error
                Err OFFSET(1) NUMBITS(3) [],
                /// Flash operation done. Set by HW, cleared by SW
                Done OFFSET(0) NUMBITS(1) [],
            ],
    }
}
pub mod regs {
    //! Types that represent registers.
    use tock_registers::register_structs;
    register_structs! {
        pub MainFlashCtrl {
            (0x0 => pub fl_interrupt_state: tock_registers::registers::ReadWrite<u32, crate::main_flash_ctrl::bits::FlInterruptState::Register>),
            (0x4 => pub fl_interrupt_enable: tock_registers::registers::ReadWrite<u32, crate::main_flash_ctrl::bits::FlInterruptEnable::Register>),
            (0x8 => pub page_size: tock_registers::registers::ReadWrite<u32>),
            (0xc => pub page_num: tock_registers::registers::ReadWrite<u32>),
            (0x10 => pub page_addr: tock_registers::registers::ReadWrite<u32>),
            (0x14 => pub fl_control: tock_registers::registers::ReadWrite<u32, crate::main_flash_ctrl::bits::FlControl::Register>),
            (0x18 => pub op_status: tock_registers::registers::ReadWrite<u32, crate::main_flash_ctrl::bits::OpStatus::Register>),
            (0x1c => pub ctrl_regwen: tock_registers::registers::ReadOnly<u32, crate::main_flash_ctrl::bits::CtrlRegwen::Register>),
            (0x20 => @END),
        }
    }
}
